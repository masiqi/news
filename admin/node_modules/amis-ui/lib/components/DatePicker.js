/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var moment = require('moment');
var icons = require('./icons.js');
var amisCore = require('amis-core');
var PopUp = require('./PopUp.js');
var Calendar = require('./calendar/Calendar.js');
var CalendarMobile = require('./CalendarMobile.js');
var Input = require('./Input.js');
var Button = require('./Button.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var availableShortcuts = {
    now: {
        label: 'Date.now',
        date: function (now) {
            return now;
        }
    },
    today: {
        label: 'Date.today',
        date: function (now) {
            return now.startOf('day');
        }
    },
    yesterday: {
        label: 'Date.yesterday',
        date: function (now) {
            return now.add(-1, 'days').startOf('day');
        }
    },
    thisweek: {
        label: 'Date.monday',
        date: function (now) {
            return now.startOf('week').startOf('day');
        }
    },
    thismonth: {
        label: 'Date.startOfMonth',
        date: function (now) {
            return now.startOf('month');
        }
    },
    prevmonth: {
        label: 'Date.startOfLastMonth',
        date: function (now) {
            return now.startOf('month').add(-1, 'month');
        }
    },
    prevquarter: {
        label: 'Date.startOfLastQuarter',
        date: function (now) {
            return now.startOf('quarter').add(-1, 'quarter');
        }
    },
    thisquarter: {
        label: 'Date.startOfQuarter',
        date: function (now) {
            return now.startOf('quarter');
        }
    },
    tomorrow: {
        label: 'Date.tomorrow',
        date: function (now) {
            return now.add(1, 'days').startOf('day');
        }
    },
    endofthisweek: {
        label: 'Date.endOfWeek',
        date: function (now) {
            return now.endOf('week');
        }
    },
    endofthismonth: {
        label: 'Date.endOfMonth',
        date: function (now) {
            return now.endOf('month');
        }
    },
    endoflastmonth: {
        label: 'Date.endOfLastMonth',
        date: function (now) {
            return now.add(-1, 'month').endOf('month');
        }
    }
};
var advancedShortcuts = [
    {
        regexp: /^(\d+)hoursago$/,
        resolve: function (__, _, hours) {
            return {
                label: __('Date.hoursago', { hours: hours }),
                date: function (now) {
                    return now.subtract(hours, 'hours');
                }
            };
        }
    },
    {
        regexp: /^(\d+)hourslater$/,
        resolve: function (__, _, hours) {
            return {
                label: __('Date.hourslater', { hours: hours }),
                date: function (now) {
                    return now.add(hours, 'hours');
                }
            };
        }
    },
    {
        regexp: /^(\d+)daysago$/,
        resolve: function (__, _, days) {
            return {
                label: __('Date.daysago', { days: days }),
                date: function (now) {
                    return now.subtract(days, 'days');
                }
            };
        }
    },
    {
        regexp: /^(\d+)dayslater$/,
        resolve: function (__, _, days) {
            return {
                label: __('Date.dayslater', { days: days }),
                date: function (now) {
                    return now.add(days, 'days');
                }
            };
        }
    },
    {
        regexp: /^(\d+)weeksago$/,
        resolve: function (__, _, weeks) {
            return {
                label: __('Date.weeksago', { weeks: weeks }),
                date: function (now) {
                    return now.subtract(weeks, 'weeks');
                }
            };
        }
    },
    {
        regexp: /^(\d+)weekslater$/,
        resolve: function (__, _, weeks) {
            return {
                label: __('Date.weekslater', { weeks: weeks }),
                date: function (now) {
                    return now.add(weeks, 'weeks');
                }
            };
        }
    },
    {
        regexp: /^(\d+)monthsago$/,
        resolve: function (__, _, months) {
            return {
                label: __('Date.monthsago', { months: months }),
                date: function (now) {
                    return now.subtract(months, 'months');
                }
            };
        }
    },
    {
        regexp: /^(\d+)monthslater$/,
        resolve: function (__, _, months) {
            return {
                label: __('Date.monthslater', { months: months }),
                date: function (now) {
                    return now.add(months, 'months');
                }
            };
        }
    },
    {
        regexp: /^(\d+)quartersago$/,
        resolve: function (__, _, quarters) {
            return {
                label: __('Date.quartersago', { quarters: quarters }),
                date: function (now) {
                    return now.subtract(quarters, 'quarters');
                }
            };
        }
    },
    {
        regexp: /^(\d+)quarterslater$/,
        resolve: function (__, _, quarters) {
            return {
                label: __('Date.quarterslater', { quarters: quarters }),
                date: function (now) {
                    return now.add(quarters, 'quarters');
                }
            };
        }
    }
];
var dateFormats = {
    Y: { format: 'YYYY' },
    Q: { format: 'YYYY [Q]Q' },
    M: { format: 'YYYY-MM' },
    D: { format: 'YYYY-MM-DD' }
};
var timeFormats = {
    h: { format: 'HH' },
    H: { format: 'HH' },
    m: { format: 'mm' },
    s: { format: 'ss' },
    S: { format: 'ss' }
};
var DatePicker = /** @class */ (function (_super) {
    tslib.__extends(DatePicker, _super);
    function DatePicker(props) {
        var _this = this;
        var _a;
        _this = _super.call(this, props) || this;
        _this.domRef = function (ref) {
            _this.dom = ref;
        };
        _this.inputRef = React__default["default"].createRef();
        _this.handleChange = _this.handleChange.bind(_this);
        _this.selectShortcut = _this.selectShortcut.bind(_this);
        _this.checkIsValidDate = _this.checkIsValidDate.bind(_this);
        _this.open = _this.open.bind(_this);
        _this.close = _this.close.bind(_this);
        _this.handleFocus = _this.handleFocus.bind(_this);
        _this.handleBlur = _this.handleBlur.bind(_this);
        _this.clearValue = _this.clearValue.bind(_this);
        _this.handleClick = _this.handleClick.bind(_this);
        _this.handleKeyPress = _this.handleKeyPress.bind(_this);
        _this.getParent = _this.getParent.bind(_this);
        _this.getTarget = _this.getTarget.bind(_this);
        _this.handlePopOverClick = _this.handlePopOverClick.bind(_this);
        _this.renderShortCuts = _this.renderShortCuts.bind(_this);
        _this.inputChange = _this.inputChange.bind(_this);
        _this.onInputBlur = _this.onInputBlur.bind(_this);
        var _b = _this.props, value = _b.value, format = _b.format, valueFormat = _b.valueFormat, displayFormat = _b.displayFormat, inputFormat = _b.inputFormat, dateFormat = _b.dateFormat, timeFormat = _b.timeFormat;
        var curDateFormat = dateFormat !== null && dateFormat !== void 0 ? dateFormat : '';
        var curTimeFormat = timeFormat !== null && timeFormat !== void 0 ? timeFormat : '';
        var curTimeFormatArr = [];
        !dateFormat &&
            Object.keys(dateFormats).forEach(function (item) {
                var _a;
                if ((_a = (displayFormat || inputFormat)) === null || _a === void 0 ? void 0 : _a.includes(item)) {
                    curDateFormat = dateFormats[item].format;
                }
            });
        !timeFormat &&
            Object.keys(timeFormats).forEach(function (item) {
                var _a;
                if ((_a = (displayFormat || inputFormat)) === null || _a === void 0 ? void 0 : _a.includes(item)) {
                    curTimeFormatArr.push(timeFormats[item].format);
                }
            });
        curTimeFormat = curTimeFormatArr.length
            ? curTimeFormatArr.join(':')
            : curTimeFormat;
        _this.state = {
            isOpened: false,
            isFocused: false,
            value: amisCore.normalizeDate(value, valueFormat || format),
            inputValue: ((_a = amisCore.normalizeDate(value, valueFormat || format)) === null || _a === void 0 ? void 0 : _a.format(displayFormat || inputFormat)) || '',
            curTimeFormat: curTimeFormat,
            curDateFormat: curDateFormat,
            isModified: false
        };
        return _this;
    }
    DatePicker.prototype.componentDidMount = function () {
        var _a, _b;
        (_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        var _c = this.props, value = _c.value, format = _c.format, valueFormat = _c.valueFormat, inputFormat = _c.inputFormat, displayFormat = _c.displayFormat, dateFormat = _c.dateFormat, timeFormat = _c.timeFormat;
        if (value) {
            var valueCache = amisCore.normalizeDate(value, valueFormat || format);
            this.inputValueCache =
                (valueCache === null || valueCache === void 0 ? void 0 : valueCache.format(displayFormat || inputFormat)) || '';
        }
        var curDateFormat = dateFormat !== null && dateFormat !== void 0 ? dateFormat : '';
        var curTimeFormat = timeFormat !== null && timeFormat !== void 0 ? timeFormat : '';
        var curTimeFormatArr = [];
        !dateFormat &&
            Object.keys(dateFormats).forEach(function (item) {
                var _a;
                if ((_a = (displayFormat || inputFormat)) === null || _a === void 0 ? void 0 : _a.includes(item)) {
                    curDateFormat = dateFormats[item].format;
                }
            });
        !timeFormat &&
            Object.keys(timeFormats).forEach(function (item) {
                var _a;
                if ((_a = (displayFormat || inputFormat)) === null || _a === void 0 ? void 0 : _a.includes(item)) {
                    curTimeFormatArr.push(timeFormats[item].format);
                }
            });
        curTimeFormat = curTimeFormatArr.length
            ? curTimeFormatArr.join(':')
            : curTimeFormat;
        this.setState({ curDateFormat: curDateFormat, curTimeFormat: curTimeFormat });
    };
    DatePicker.prototype.componentDidUpdate = function (prevProps) {
        var _a;
        var props = this.props;
        var prevValue = prevProps.value;
        if (prevValue !== props.value) {
            var newState = {
                value: amisCore.normalizeDate(props.value, props.valueFormat || props.format, {
                    utc: props.utc
                })
            };
            newState.inputValue =
                ((_a = newState.value) === null || _a === void 0 ? void 0 : _a.format(this.props.displayFormat || this.props.inputFormat)) || '';
            this.inputValueCache = newState.inputValue;
            this.setState(newState);
        }
    };
    DatePicker.prototype.isConfirmMode = function () {
        var _a = this.props, closeOnSelect = _a.closeOnSelect, embed = _a.embed, mobileUI = _a.mobileUI;
        var curTimeFormat = this.state.curTimeFormat;
        /** 日期时间选择器才支持confirm */
        return closeOnSelect === false && !!curTimeFormat && !embed && !mobileUI;
    };
    DatePicker.prototype.focus = function () {
        if (!this.dom) {
            return;
        }
        this.dom.focus();
    };
    DatePicker.prototype.handleFocus = function (e) {
        this.setState({
            isFocused: true
        });
        var onFocus = this.props.onFocus;
        onFocus && onFocus(e);
    };
    DatePicker.prototype.handleBlur = function (e) {
        var targetElement = e.nativeEvent.relatedTarget;
        if (targetElement === this.dom || targetElement === this.inputRef.current) {
            return;
        }
        this.setState({
            isFocused: false
        });
        var onBlur = this.props.onBlur;
        onBlur && onBlur(e);
    };
    DatePicker.prototype.handleKeyPress = function (e) {
        if (e.key === ' ') {
            this.handleClick();
            e.preventDefault();
        }
    };
    DatePicker.prototype.handleClick = function () {
        this.state.isOpened ? this.close() : this.open();
    };
    DatePicker.prototype.handlePopOverClick = function (e) {
        e.stopPropagation();
        e.preventDefault();
    };
    DatePicker.prototype.open = function (fn) {
        if (this.props.disabled) {
            return;
        }
        this.setState({
            isOpened: true
        }, fn);
        var input = this.inputRef.current;
        input && input.focus();
    };
    DatePicker.prototype.close = function () {
        var _a;
        var isConfirmMode = this.isConfirmMode();
        if (isConfirmMode) {
            var _b = this.props, value = _b.value, valueFormat = _b.valueFormat, format = _b.format, displayFormat = _b.displayFormat, inputFormat = _b.inputFormat;
            this.setState({
                value: amisCore.normalizeDate(value, valueFormat || format),
                inputValue: ((_a = amisCore.normalizeDate(value, valueFormat || format)) === null || _a === void 0 ? void 0 : _a.format(displayFormat || inputFormat)) || ''
            });
        }
        this.setState({ isOpened: false, isModified: false });
    };
    DatePicker.prototype.clearValue = function (e) {
        e.preventDefault();
        e.stopPropagation();
        var onChange = this.props.onChange;
        onChange('');
        this.setState({ inputValue: '', isModified: false });
    };
    // 清空
    DatePicker.prototype.clear = function () {
        var onChange = this.props.onChange;
        onChange('');
        this.setState({ inputValue: '', isModified: false });
    };
    // 重置
    DatePicker.prototype.reset = function (resetValue) {
        var _a;
        if (!resetValue) {
            return;
        }
        var _b = this.props, format = _b.format, valueFormat = _b.valueFormat, inputFormat = _b.inputFormat, displayFormat = _b.displayFormat, onChange = _b.onChange;
        onChange(resetValue);
        this.setState({
            inputValue: (_a = amisCore.normalizeDate(resetValue, valueFormat || format)) === null || _a === void 0 ? void 0 : _a.format(displayFormat || inputFormat || ''),
            isModified: false
        });
    };
    /**
     * 如果为日期时间选择器，则单独处理时间选择事件，点击确认的时候才触发onChange
     */
    DatePicker.prototype.handleConfirm = function () {
        var _a = this.props, onChange = _a.onChange, format = _a.format, valueFormat = _a.valueFormat, minDate = _a.minDate, maxDate = _a.maxDate, inputFormat = _a.inputFormat, displayFormat = _a.displayFormat, utc = _a.utc;
        var value = this.state.value;
        var isConfirmMode = this.isConfirmMode();
        if (!isConfirmMode || !value) {
            return;
        }
        if (minDate && value && value.isBefore(minDate, 'second')) {
            value = minDate;
        }
        else if (maxDate && value && value.isAfter(maxDate, 'second')) {
            value = maxDate;
        }
        onChange(utc
            ? moment__default["default"].utc(value).format(valueFormat || format)
            : value.format(valueFormat || format));
        this.setState({
            inputValue: utc
                ? moment__default["default"].utc(value).format(displayFormat || inputFormat)
                : value.format(displayFormat || inputFormat),
            isOpened: false,
            isModified: true
        });
    };
    DatePicker.prototype.handleChange = function (value, viewMode) {
        var _a = this.props, onChange = _a.onChange, format = _a.format, valueFormat = _a.valueFormat, minDate = _a.minDate, maxDate = _a.maxDate, inputFormat = _a.inputFormat, displayFormat = _a.displayFormat, closeOnSelect = _a.closeOnSelect, utc = _a.utc; _a.value;
        var _b = this.state, curDateFormat = _b.curDateFormat, curTimeFormat = _b.curTimeFormat; _b.isModified;
        var isConfirmMode = this.isConfirmMode();
        if (!moment__default["default"].isMoment(value)) {
            return;
        }
        if (minDate && value && value.isBefore(minDate, 'second')) {
            value = minDate;
        }
        else if (maxDate && value && value.isAfter(maxDate, 'second')) {
            value = maxDate;
        }
        //  这段逻辑会导致视图上看着选择了0，但实际上是选择了当前时间
        /** 首次选择且当前未绑定值，则默认使用当前时间 */
        // if (!defaultValue && !!curTimeFormat && !isModified) {
        //   const now = moment();
        //   const timePart: Record<MutableUnitOfTime, number> = {
        //     date: value.get('date'),
        //     hour: value.get('hour'),
        //     minute: value.get('minute'),
        //     second: value.get('second'),
        //     millisecond: value.get('millisecond')
        //   };
        //   Object.keys(timePart).forEach((unit: MutableUnitOfTime) => {
        //     /** 首次选择时间，日期使用当前时间; 将未设置过的时间字段设置为当前值 */
        //     if (
        //       (unit === 'date' && viewMode === 'time') ||
        //       (unit !== 'date' && timePart[unit] === 0)
        //     ) {
        //       timePart[unit] = now.get(unit);
        //     }
        //   });
        //   value.set(timePart);
        // }
        var updatedValue = utc
            ? moment__default["default"].utc(value).format(valueFormat || format)
            : value.format(valueFormat || format);
        var updatedInputValue = value.format(displayFormat || inputFormat);
        if (isConfirmMode) {
            this.setState({ value: value, inputValue: updatedInputValue });
            this.inputValueCache = updatedInputValue;
        }
        else {
            onChange(updatedValue);
            if (closeOnSelect && curDateFormat && !curTimeFormat) {
                this.close();
            }
            this.setState({ inputValue: updatedInputValue });
        }
        this.setState({ isModified: true });
    };
    // 手动输入日期
    DatePicker.prototype.inputChange = function (e) {
        var _a = this.props, onChange = _a.onChange, inputFormat = _a.inputFormat, format = _a.format, displayFormat = _a.displayFormat, valueFormat = _a.valueFormat, utc = _a.utc, minDate = _a.minDate, maxDate = _a.maxDate;
        var value = e.currentTarget.value;
        this.setState({ inputValue: value });
        if (value === '') {
            onChange('');
        }
        else {
            // 将输入的格式转成正则匹配，比如 YYYY-MM-DD HH:mm:ss 改成 \d\d\d\d\-
            // 只有匹配成功才更新
            var inputCheckRegex = new RegExp((inputFormat || displayFormat)
                .replace(/[ymdhs]/gi, '\\d')
                .replace(/-/gi, '\\-'));
            if (inputCheckRegex.test(value)) {
                var newDate = moment__default["default"](value, displayFormat || inputFormat);
                var dateValue = utc
                    ? moment__default["default"].utc(newDate).format(valueFormat || format)
                    : newDate.format(valueFormat || format);
                // 判断大小值是否是合法的日期，并且当前日期在范围内
                var isMinDateValid = (minDate === null || minDate === void 0 ? void 0 : minDate.isValid())
                    ? newDate.isSameOrAfter(minDate)
                    : true;
                var isMaxDateValid = (maxDate === null || maxDate === void 0 ? void 0 : maxDate.isValid())
                    ? newDate.isSameOrBefore(maxDate)
                    : true;
                // 小于 0 的日期丢弃
                if (!dateValue.startsWith('-') && isMinDateValid && isMaxDateValid) {
                    onChange(dateValue);
                }
            }
        }
    };
    DatePicker.prototype.onInputBlur = function () {
        this.setState({
            inputValue: this.inputValueCache
        });
    };
    DatePicker.prototype.selectShortcut = function (shortcut) {
        var _a = this.props, closeOnSelect = _a.closeOnSelect, minDateRaw = _a.minDateRaw, maxDateRaw = _a.maxDateRaw, data = _a.data, format = _a.format, valueFormat = _a.valueFormat;
        var now = moment__default["default"]();
        /** minDate和maxDate要实时计算，因为用户可能设置为${NOW()}，暂时不考虑毫秒级的时间差 */
        var minDate = minDateRaw
            ? amisCore.filterDate(minDateRaw, data, valueFormat || format)
            : undefined;
        var maxDate = maxDateRaw
            ? amisCore.filterDate(maxDateRaw, data, valueFormat || format)
            : undefined;
        var date = shortcut.date(now.clone());
        if (minDate && moment__default["default"].isMoment(minDate) && (minDate === null || minDate === void 0 ? void 0 : minDate.isValid())) {
            date = moment__default["default"].max(date, minDate);
        }
        if (maxDate && moment__default["default"].isMoment(maxDate) && (maxDate === null || maxDate === void 0 ? void 0 : maxDate.isValid())) {
            date = moment__default["default"].min(maxDate, date);
        }
        this.handleChange(date);
        closeOnSelect && this.close();
    };
    DatePicker.prototype.checkIsValidDate = function (currentDate) {
        var _a = this.props, minDate = _a.minDate, maxDate = _a.maxDate, disabledDate = _a.disabledDate;
        if (minDate && currentDate.isBefore(minDate, 'day')) {
            return false;
        }
        else if (maxDate && currentDate.isAfter(maxDate, 'day')) {
            return false;
        }
        if (typeof disabledDate === 'function') {
            return !disabledDate(currentDate);
        }
        return true;
    };
    DatePicker.prototype.getTarget = function () {
        return this.dom;
    };
    DatePicker.prototype.getParent = function () {
        return this.dom;
    };
    DatePicker.prototype.getAvailableShortcuts = function (key) {
        if (availableShortcuts[key]) {
            return availableShortcuts[key];
        }
        var __ = this.props.translate;
        for (var i = 0, len = advancedShortcuts.length; i < len; i++) {
            var item = advancedShortcuts[i];
            var m = item.regexp.exec(key);
            if (m) {
                return item.resolve.apply(item, tslib.__spreadArray([__], tslib.__read(m), false));
            }
        }
        return null;
    };
    DatePicker.prototype.renderShortCuts = function (shortcuts) {
        var _this = this;
        if (!shortcuts) {
            return null;
        }
        var _a = this.props; _a.classPrefix; var cx = _a.classnames, __ = _a.translate, format = _a.format, valueFormat = _a.valueFormat, data = _a.data;
        var shortcutArr;
        if (typeof shortcuts === 'string') {
            shortcutArr = shortcuts.split(',');
        }
        else {
            shortcutArr = shortcuts;
        }
        return (_J$X_("ul", { className: cx("DatePicker-shortcuts") }, shortcutArr.map(function (item, index) {
            if (!item) {
                return null;
            }
            var shortcut = {};
            if (typeof item === 'string') {
                shortcut = _this.getAvailableShortcuts(item);
                shortcut.key = item;
            }
            else if (item.date) {
                var shortcutRaw_1 = tslib.__assign({}, item);
                shortcut = tslib.__assign(tslib.__assign({}, item), { date: function () {
                        var date = amisCore.isExpression(shortcutRaw_1.date)
                            ? moment__default["default"](amisCore.FormulaExec['formula'](shortcutRaw_1.date, data), valueFormat || format)
                            : shortcutRaw_1.date;
                        return date && moment__default["default"].isMoment(date) && (date === null || date === void 0 ? void 0 : date.isValid())
                            ? date
                            : item.date;
                    } });
            }
            return (_J$X_("li", { className: cx("DatePicker-shortcut"), onClick: function () { return _this.selectShortcut(shortcut); }, key: index },
                _J$X_("a", null, __(shortcut.label))));
        })));
    };
    DatePicker.prototype.render = function () {
        var _a;
        var _b = this.props, ns = _b.classPrefix, cx = _b.classnames, className = _b.className, popoverClassName = _b.popoverClassName, value = _b.value, placeholder = _b.placeholder, disabled = _b.disabled, inputFormat = _b.inputFormat, displayFormat = _b.displayFormat; _b.dateFormat; _b.timeFormat; var viewMode = _b.viewMode, timeConstraints = _b.timeConstraints, popOverContainer = _b.popOverContainer, popOverContainerSelector = _b.popOverContainerSelector, clearable = _b.clearable, shortcuts = _b.shortcuts; _b.utc; var isEndDate = _b.isEndDate, overlayPlacement = _b.overlayPlacement, locale = _b.locale, format = _b.format, valueFormat = _b.valueFormat, borderMode = _b.borderMode, embed = _b.embed, minDate = _b.minDate, mobileUI = _b.mobileUI, maxDate = _b.maxDate, schedules = _b.schedules, largeMode = _b.largeMode, scheduleClassNames = _b.scheduleClassNames, todayActiveStyle = _b.todayActiveStyle, onScheduleClick = _b.onScheduleClick, mobileCalendarMode = _b.mobileCalendarMode, label = _b.label, env = _b.env, testIdBuilder = _b.testIdBuilder, onClick = _b.onClick, onMouseEnter = _b.onMouseEnter, onMouseLeave = _b.onMouseLeave, inputForbid = _b.inputForbid; _b.closeOnSelect;
        var __ = this.props.translate;
        var _c = this.state, curTimeFormat = _c.curTimeFormat, curDateFormat = _c.curDateFormat, isOpened = _c.isOpened;
        var isConfirmMode = this.isConfirmMode();
        var date = this.state.value;
        var isConfirmBtnDisbaled = false;
        if (isConfirmMode) {
            var lastModifiedValue = amisCore.normalizeDate(value, valueFormat || format);
            isConfirmBtnDisbaled =
                date && lastModifiedValue
                    ? moment__default["default"](date).isSame(lastModifiedValue, 'second')
                    : date === lastModifiedValue;
        }
        var calendarMobile = (_J$X_(CalendarMobile["default"], { isDatePicker: true, timeFormat: curTimeFormat, displayForamt: displayFormat || inputFormat, startDate: date, defaultDate: date, minDate: minDate, maxDate: maxDate, dateFormat: curDateFormat, embed: embed, viewMode: viewMode, close: this.close, confirm: this.handleChange, footerExtra: this.renderShortCuts(shortcuts), showViewMode: viewMode === 'quarters' || viewMode === 'months' ? 'years' : 'months', timeConstraints: timeConstraints, isEndDate: isEndDate }));
        var CalendarMobileTitle = (_J$X_("div", { className: "".concat(ns, "CalendarMobile-title") }, label && typeof label === 'string' ? label : __('Calendar.datepicker')));
        var useCalendarMobile = mobileUI && ['days', 'months', 'quarters'].indexOf(viewMode) > -1;
        if (embed) {
            var schedulesData = undefined;
            if (schedules && Array.isArray(schedules)) {
                // 设置日程颜色
                var index_1 = 0;
                schedulesData = schedules.map(function (schedule) {
                    var className = schedule.className;
                    if (!className && scheduleClassNames) {
                        className = scheduleClassNames[index_1];
                        index_1++;
                        if (index_1 >= scheduleClassNames.length) {
                            index_1 = 0;
                        }
                    }
                    return tslib.__assign(tslib.__assign({}, schedule), { className: className });
                });
            }
            return (_J$X_("div", { className: cx("DateCalendar", {
                    'is-disabled': disabled,
                    'ScheduleCalendar': schedulesData,
                    'ScheduleCalendar-large': largeMode
                }, className) },
                _J$X_(Calendar["default"], { value: date, onChange: this.handleChange, requiredConfirm: false, dateFormat: curDateFormat, timeFormat: curTimeFormat, isValidDate: this.checkIsValidDate, viewMode: viewMode, timeConstraints: timeConstraints, input: false, onClose: this.close, locale: locale, minDate: minDate, maxDate: maxDate, 
                    // utc={utc}
                    schedules: schedulesData, env: env, largeMode: largeMode, todayActiveStyle: todayActiveStyle, onScheduleClick: onScheduleClick, embed: embed, mobileUI: mobileUI, isEndDate: isEndDate, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, testIdBuilder: testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('calendar') })));
        }
        return (_J$X_("div", tslib.__assign({ tabIndex: 0, onKeyPress: this.handleKeyPress, onFocus: this.handleFocus, onBlur: this.handleBlur, className: cx("DatePicker", (_a = {
                    'is-disabled': disabled,
                    'is-focused': !disabled && this.state.isFocused
                },
                _a["DatePicker--border".concat(amisCore.ucFirst(borderMode))] = borderMode,
                _a['is-mobile'] = mobileUI,
                _a), className), ref: this.domRef, onClick: this.handleClick }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getTestId()),
            _J$X_(Input["default"], tslib.__assign({ className: cx('DatePicker-input'), onChange: this.inputChange, onBlur: this.onInputBlur, ref: this.inputRef, placeholder: placeholder, autoComplete: "off", value: this.state.inputValue || '', disabled: disabled, readOnly: mobileUI || inputForbid }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('input').getTestId())),
            clearable &&
                !disabled &&
                amisCore.normalizeDate(value, valueFormat || format) ? (_J$X_("a", tslib.__assign({ className: cx("DatePicker-clear"), onClick: this.clearValue }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('clear').getTestId()),
                _J$X_(icons.Icon, { icon: "input-clear", className: "icon" }))) : null,
            _J$X_("a", tslib.__assign({ className: cx("DatePicker-toggler") }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('toggler').getTestId()),
                _J$X_(icons.Icon, { icon: viewMode === 'time' ? 'clock' : 'date', className: "icon", iconContent: viewMode === 'time'
                        ? 'DatePicker-toggler-clock'
                        : 'DatePicker-toggler-date' })),
            !mobileUI && isOpened ? (_J$X_(amisCore.Overlay, { target: this.getTarget, container: popOverContainer || this.getParent, containerSelector: popOverContainerSelector, rootClose: false, placement: overlayPlacement, show: true },
                _J$X_(amisCore.PopOver, { classPrefix: ns, className: cx("DatePicker-popover", popoverClassName), onHide: this.close, overlay: true, testIdBuilder: testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('popover'), onClick: this.handlePopOverClick },
                    this.renderShortCuts(shortcuts),
                    _J$X_(Calendar["default"], { value: date, onChange: this.handleChange, requiredConfirm: viewMode === 'time', dateFormat: curDateFormat, displayForamt: displayFormat || inputFormat, timeFormat: curTimeFormat, isValidDate: this.checkIsValidDate, viewMode: viewMode, timeConstraints: timeConstraints, input: false, onClose: this.close, locale: locale, minDate: minDate, maxDate: maxDate, mobileUI: mobileUI, isEndDate: isEndDate, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, testIdBuilder: testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('calendar') }),
                    isConfirmMode ? (_J$X_("div", { className: "".concat(ns, "DateRangePicker-actions") },
                        _J$X_(Button["default"], { size: "sm", onClick: this.close }, __('cancel')),
                        _J$X_(Button["default"], { level: "primary", size: "sm", disabled: isConfirmBtnDisbaled, className: cx('m-l-sm'), onClick: this.handleConfirm }, __('confirm')))) : null))) : null,
            mobileUI ? (mobileCalendarMode === 'calendar' && useCalendarMobile ? (_J$X_(PopUp["default"], { isShow: isOpened, className: cx("".concat(ns, "CalendarMobile-pop")), onHide: this.close, header: CalendarMobileTitle }, calendarMobile)) : (_J$X_(PopUp["default"], { className: cx("".concat(ns, "DatePicker-popup DatePicker-mobile")), container: popOverContainer, isShow: isOpened, showClose: false, onHide: this.handleClick },
                _J$X_(Calendar["default"], { value: date, onChange: this.handleChange, requiredConfirm: false, dateFormat: curDateFormat, displayForamt: displayFormat || inputFormat, timeFormat: curTimeFormat, isValidDate: this.checkIsValidDate, viewMode: viewMode, timeConstraints: timeConstraints, input: false, onClose: this.close, locale: locale, minDate: minDate, maxDate: maxDate, mobileUI: mobileUI, onClick: onClick, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, testIdBuilder: testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('calendar') })))) : null));
    };
    DatePicker.defaultProps = {
        viewMode: 'days',
        shortcuts: '',
        closeOnSelect: true,
        overlayPlacement: 'auto',
        scheduleClassNames: [
            'bg-warning',
            'bg-danger',
            'bg-success',
            'bg-info',
            'bg-secondary'
        ]
    };
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], DatePicker.prototype, "handleConfirm", null);
    return DatePicker;
}(React__default["default"].Component));
var DatePicker$1 = amisCore.themeable(amisCore.localeable(DatePicker));

exports.DatePicker = DatePicker;
exports["default"] = DatePicker$1;
