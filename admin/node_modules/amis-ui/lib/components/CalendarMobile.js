/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var moment = require('moment');
var Calendar = require('./calendar/Calendar.js');
var amisCore = require('amis-core');
var PopUp = require('./PopUp.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var moment__default = /*#__PURE__*/_interopDefaultLegacy(moment);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var CalendarMobile = /** @class */ (function (_super) {
    tslib.__extends(CalendarMobile, _super);
    function CalendarMobile(props) {
        var _this = _super.call(this, props) || this;
        _this.mobileBody = React__default["default"].createRef();
        _this.mobileHeader = React__default["default"].createRef();
        var _a = _this.props, startDate = _a.startDate, endDate = _a.endDate, defaultDate = _a.defaultDate, minDate = _a.minDate, maxDate = _a.maxDate;
        var dateRange = _this.getDateRange(minDate, maxDate, defaultDate);
        _this.state = {
            minDate: dateRange.minDate,
            maxDate: dateRange.maxDate,
            startDate: startDate,
            endDate: endDate,
            showToast: false,
            currentDate: dateRange.currentDate,
            isScrollToBottom: false,
            dateTime: endDate ? [endDate.hour(), endDate.minute()] : [0, 0],
            isPopupOpen: false
        };
        return _this;
    }
    CalendarMobile.prototype.getDateRange = function (minDate, maxDate, defaultDate) {
        !moment__default["default"].isMoment(minDate) || (!minDate.isValid() && (minDate = undefined));
        !moment__default["default"].isMoment(maxDate) || (!maxDate.isValid() && (maxDate = undefined));
        var currentDate = defaultDate || moment__default["default"]();
        var dateRange = {
            minDate: currentDate.clone().subtract(1, 'year').startOf('months'),
            maxDate: currentDate.clone().add(1, 'year').endOf('months')
        };
        if (minDate && maxDate) {
            dateRange = {
                minDate: minDate,
                maxDate: maxDate
            };
        }
        else if (minDate && !maxDate) {
            dateRange = {
                minDate: minDate,
                maxDate: moment__default["default"](minDate).add(2, 'year')
            };
            currentDate = minDate.clone();
        }
        else if (!minDate && maxDate) {
            dateRange = {
                minDate: moment__default["default"](maxDate).subtract(2, 'year'),
                maxDate: maxDate
            };
            currentDate = maxDate.clone();
        }
        if (!currentDate.isBetween(dateRange.minDate, dateRange.maxDate, 'days', '[]')) {
            currentDate = dateRange.minDate.clone();
        }
        return tslib.__assign(tslib.__assign({}, dateRange), { currentDate: currentDate });
    };
    CalendarMobile.prototype.componentDidMount = function () {
        this.initMonths();
    };
    CalendarMobile.prototype.componentDidUpdate = function (prevProps) {
        var _this = this;
        var props = this.props;
        var ns = props.classPrefix;
        if (prevProps.minDate !== props.minDate ||
            prevProps.maxDate !== props.maxDate) {
            var currentDate = this.state.currentDate;
            var dateRange = this.getDateRange(props.minDate, props.maxDate, moment__default["default"](currentDate));
            this.setState({
                minDate: dateRange.minDate,
                maxDate: dateRange.maxDate,
                currentDate: dateRange.currentDate
            }, function () { return _this.initMonths(); });
        }
        if ((prevProps.startDate !== props.startDate &&
            props.startDate !== this.state.startDate) ||
            (prevProps.endDate !== props.endDate &&
                props.endDate !== this.state.endDate)) {
            this.setState({
                startDate: props.startDate,
                endDate: props.endDate
            }, function () {
                return requestAnimationFrame(function () {
                    var _a;
                    (_a = document
                        .querySelector(".".concat(ns, "CalendarMobile:not(.").concat(ns, "CalendarMobile-embed) .rdtRangeStart:not(.rdtNew)"))) === null || _a === void 0 ? void 0 : _a.scrollIntoView();
                });
            });
        }
    };
    CalendarMobile.prototype.componentWillUnmount = function () {
        this.setState({ showToast: false });
        clearTimeout(this.timer);
    };
    CalendarMobile.prototype.initMonths = function () {
        if (this.mobileBody.current) {
            var defaultDate = this.props.defaultDate || this.state.currentDate;
            this.scollToDate(defaultDate ? moment__default["default"](defaultDate) : moment__default["default"]());
        }
    };
    CalendarMobile.prototype.scollToDate = function (date) {
        var index = date.month();
        var currentEl = this.mobileBody.current.children[index];
        if (!currentEl) {
            return;
        }
        var header = this.mobileHeader.current;
        this.mobileBody.current.scrollBy(0, currentEl.offsetTop -
            this.mobileBody.current.scrollTop -
            header.clientHeight);
    };
    CalendarMobile.prototype.scrollPreYear = function () {
        if (!this.state.currentDate) {
            return;
        }
        var _a = this.state, currentDate = _a.currentDate, minDate = _a.minDate;
        currentDate = currentDate.clone().subtract(1, 'years');
        if (minDate && currentDate.isBefore(minDate)) {
            currentDate = minDate;
        }
        this.setState({
            currentDate: currentDate
        });
        this.scollToDate(currentDate);
    };
    CalendarMobile.prototype.scrollAfterYear = function () {
        if (!this.state.currentDate) {
            return;
        }
        var _a = this.state, currentDate = _a.currentDate, maxDate = _a.maxDate;
        currentDate = currentDate.clone().add(1, 'years');
        if (maxDate && currentDate.isAfter(maxDate)) {
            currentDate = maxDate;
        }
        this.setState({
            currentDate: currentDate
        });
        this.scollToDate(currentDate);
    };
    CalendarMobile.prototype.getDaysOfWeek = function () {
        var locale = moment__default["default"]().localeData();
        var days = locale.weekdaysMin();
        var first = locale.firstDayOfWeek();
        var dow = [];
        var i = 0;
        days.forEach(function (day) {
            dow[(7 + i++ - first) % 7] = day;
        });
        return dow;
    };
    CalendarMobile.prototype.handleCalendarClick = function (isDisabled) {
        var _this = this;
        if (isDisabled) {
            this.setState({ showToast: true });
            this.timer = setTimeout(function () {
                _this.setState({ showToast: false });
            }, 2000);
        }
    };
    CalendarMobile.prototype.getRenderProps = function (props, currentDate) {
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        var _b = this.props, __ = _b.translate, viewMode = _b.viewMode, isDatePicker = _b.isDatePicker;
        var precision = viewMode === 'time' ? 'hours' : viewMode || 'day';
        var footerText = '';
        if (startDate &&
            endDate &&
            currentDate.isBetween(startDate, endDate, precision, '()')) {
            props.className += ' rdtBetween';
        }
        else if (startDate &&
            endDate &&
            startDate.isSame(endDate, precision) &&
            currentDate.isSame(startDate, precision)) {
            props.className += ' rdtRangeStart';
            footerText = __('Calendar.beginAndEnd');
        }
        else if (startDate && currentDate.isSame(startDate, precision)) {
            props.className += ' rdtRangeStart';
            footerText = __('Calendar.begin');
            if (endDate) {
                props.className += ' rdtRangeHasEnd';
            }
        }
        else if (endDate && currentDate.isSame(endDate, precision)) {
            props.className += ' rdtRangeEnd';
            footerText = __('Calendar.end');
        }
        if (precision === 'day' &&
            currentDate.date() === 1 &&
            currentDate.day() === 1) {
            props.className += ' rdtOldNone';
        }
        if (isDatePicker) {
            footerText = '';
        }
        var rdtDisabled = props.className.indexOf('rdtDisabled') > -1;
        return {
            props: props,
            footerText: footerText,
            rdtDisabled: rdtDisabled
        };
    };
    CalendarMobile.prototype.handleTimeChange = function (newTime) {
        var _this = this;
        if (!newTime) {
            return;
        }
        var onChange = this.props.onChange;
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate;
        if (startDate) {
            var obj = {
                dateTime: newTime,
                startDate: endDate
                    ? startDate
                    : startDate === null || startDate === void 0 ? void 0 : startDate.clone().set({
                        hour: newTime[0],
                        minute: newTime[1],
                        second: newTime[2] || 0
                    }),
                endDate: !endDate
                    ? endDate
                    : endDate === null || endDate === void 0 ? void 0 : endDate.clone().set({
                        hour: newTime[0],
                        minute: newTime[1],
                        second: newTime[2] || 0
                    })
            };
            this.setState(obj, function () {
                onChange && onChange(_this.state);
            });
        }
    };
    CalendarMobile.prototype.checkIsValidDate = function (currentDate) {
        var _a = this.state, startDate = _a.startDate, endDate = _a.endDate, minDate = _a.minDate, maxDate = _a.maxDate;
        var _b = this.props, minDuration = _b.minDuration, maxDuration = _b.maxDuration, viewMode = _b.viewMode;
        var precision = viewMode === 'time' ? 'hours' : viewMode || 'day';
        if (minDate && currentDate.isBefore(minDate, precision)) {
            return false;
        }
        else if (maxDate && currentDate.isAfter(maxDate, precision)) {
            return false;
        }
        else if (startDate && !endDate) {
            if (minDuration &&
                currentDate.isBefore(startDate.clone().add(minDuration)) &&
                currentDate.isSameOrAfter(startDate)) {
                return false;
            }
            else if (maxDuration &&
                currentDate.isAfter(startDate.clone().add(maxDuration))) {
                return false;
            }
        }
        return true;
    };
    CalendarMobile.prototype.renderMobileDay = function (props, currentDate) {
        var _this = this;
        var cx = this.props.classnames;
        var renderProps = this.getRenderProps(props, currentDate);
        return (_J$X_("td", tslib.__assign({}, renderProps.props),
            _J$X_("div", { className: "calendar-wrap", onClick: function () { return _this.handleCalendarClick(renderProps.rdtDisabled); } },
                currentDate.date(),
                _J$X_("div", { className: cx('CalendarMobile-range-text') }, renderProps.footerText))));
    };
    CalendarMobile.prototype.renderMonth = function (props, month, year) {
        var _this = this;
        var cx = this.props.classnames;
        var currentDate = moment__default["default"]().year(year).month(month);
        var monthStr = currentDate
            .localeData()
            .monthsShort(currentDate.month(month));
        var strLength = 3;
        var monthStrFixedLength = monthStr.substring(0, strLength);
        var renderProps = this.getRenderProps(props, currentDate);
        return (_J$X_("td", tslib.__assign({}, renderProps.props),
            _J$X_("div", { className: "calendar-wrap", onClick: function () { return _this.handleCalendarClick(renderProps.rdtDisabled); } },
                monthStrFixedLength,
                _J$X_("div", { className: cx('CalendarMobile-range-text') }, renderProps.footerText))));
    };
    CalendarMobile.prototype.renderQuarter = function (props, quarter, year) {
        var _this = this;
        var cx = this.props.classnames;
        var currentDate = moment__default["default"]().year(year).quarter(quarter);
        var renderProps = this.getRenderProps(props, currentDate);
        return (_J$X_("td", tslib.__assign({}, props),
            _J$X_("div", { className: "calendar-wrap", onClick: function () { return _this.handleCalendarClick(renderProps.rdtDisabled); } },
                "Q",
                quarter,
                _J$X_("div", { className: cx('CalendarMobile-range-text') }, renderProps.footerText))));
    };
    CalendarMobile.prototype.handleMobileChange = function (newValue) {
        var _this = this;
        var _a = this.props, embed = _a.embed, minDuration = _a.minDuration, maxDuration = _a.maxDuration, confirm = _a.confirm, onChange = _a.onChange, viewMode = _a.viewMode, isDatePicker = _a.isDatePicker;
        var _b = this.state, startDate = _b.startDate, endDate = _b.endDate, dateTime = _b.dateTime, minDate = _b.minDate, maxDate = _b.maxDate;
        var precision = viewMode === 'time' ? 'hours' : viewMode || 'day';
        if (minDate && newValue && newValue.isBefore(minDate, 'second')) {
            newValue = minDate;
        }
        if (maxDate && newValue && newValue.isAfter(maxDate, 'second')) {
            newValue = maxDate;
        }
        if (!isDatePicker &&
            startDate &&
            !endDate &&
            newValue.isSameOrAfter(startDate) &&
            (!minDuration ||
                newValue.isSameOrAfter(startDate.clone().add(minDuration))) &&
            (!maxDuration ||
                newValue.isSameOrBefore(startDate.clone().add(maxDuration)))) {
            return this.setState({
                endDate: newValue.clone().endOf(precision)
                // .set({
                //   hour: dateTime[0],
                //   minute: dateTime[1],
                //   second: dateTime[2] || 0
                // })
            }, function () {
                onChange &&
                    onChange(_this.state, function () { return embed && confirm && confirm(startDate, endDate); });
            });
        }
        this.setState({
            startDate: newValue
                .clone()
                .startOf(precision)
                .set({
                hour: dateTime[0],
                minute: dateTime[1],
                second: dateTime[2] || 0
            }),
            endDate: undefined
        }, function () {
            onChange && onChange(_this.state);
        });
    };
    CalendarMobile.prototype.renderMobileCalendarBody = function () {
        var _this = this;
        var _a = this.props, cx = _a.classnames, dateFormat = _a.dateFormat; _a.timeFormat; var inputFormat = _a.inputFormat, displayForamt = _a.displayForamt, locale = _a.locale, _b = _a.viewMode, viewMode = _b === void 0 ? 'days' : _b, close = _a.close, defaultDate = _a.defaultDate, showViewMode = _a.showViewMode, isEndDate = _a.isEndDate;
        var __ = this.props.translate;
        var _c = this.state, minDate = _c.minDate, maxDate = _c.maxDate, currentDate = _c.currentDate;
        if (!minDate || !maxDate) {
            return;
        }
        var calendarDates = [];
        var currentYear = moment__default["default"](currentDate).format('YYYY');
        for (var minDateClone = minDate.clone(); minDateClone.isSameOrBefore(maxDate); minDateClone.add(1, showViewMode)) {
            var date = minDateClone.clone();
            if (defaultDate) {
                date = moment__default["default"](defaultDate).set({
                    year: date.get('year'),
                    month: date.get('month')
                });
            }
            if (date.year() === +currentYear) {
                calendarDates.push(date);
            }
        }
        return (_J$X_("div", { className: cx('CalendarMobile-body'), ref: this.mobileBody }, calendarDates.map(function (calendarDate, index) {
            var rdtOldNone = showViewMode === 'months' &&
                calendarDate.clone().startOf('month').day() === 1
                ? 'rdtOldNone'
                : '';
            return (_J$X_("div", { className: cx('CalendarMobile-calendar-wrap', rdtOldNone), key: 'calendar-wrap' + index },
                showViewMode === 'months' && (_J$X_("div", { className: cx('CalendarMobile-calendar-mark'), key: 'calendar-mark' + index }, calendarDate.month() + 1)),
                _J$X_("div", { className: cx('CalendarMobile-calendar-header') },
                    _J$X_("span", { className: "rdtSwitch" }, calendarDate.format(__('dateformat.year'))),
                    showViewMode === 'months' && (_J$X_("span", { className: "rdtSwitch" }, calendarDate.format(__('MMM'))))),
                _J$X_(Calendar["default"], { className: cx('CalendarMobile-calendar', rdtOldNone), viewDate: calendarDate, value: calendarDate, onChange: _this.handleMobileChange, requiredConfirm: false, dateFormat: dateFormat, displayForamt: displayForamt || inputFormat, timeFormat: "", isValidDate: _this.checkIsValidDate, viewMode: viewMode, input: false, onClose: close, renderDay: _this.renderMobileDay, renderMonth: _this.renderMonth, renderQuarter: _this.renderQuarter, locale: locale, hideHeader: true, updateOn: viewMode, key: 'calendar' + index, isEndDate: isEndDate })));
        })));
    };
    CalendarMobile.prototype.renderMobileTimePicker = function () {
        var _a = this.props, cx = _a.classnames, timeFormat = _a.timeFormat, locale = _a.locale, close = _a.close, timeConstraints = _a.timeConstraints, defaultDate = _a.defaultDate, isDatePicker = _a.isDatePicker, isEndDate = _a.isEndDate;
        var __ = this.props.translate;
        var _b = this.state, startDate = _b.startDate, endDate = _b.endDate, dateTime = _b.dateTime;
        return (_J$X_("div", { className: cx('CalendarMobile-time') },
            _J$X_("div", { className: cx('CalendarMobile-time-title') }, isDatePicker
                ? __('Date.titleTime')
                : startDate && endDate
                    ? __('Calendar.endPick')
                    : __('Calendar.startPick')),
            _J$X_(Calendar["default"], { className: cx('CalendarMobile-time-calendar'), value: defaultDate, onChange: this.handleTimeChange, requiredConfirm: false, timeFormat: timeFormat, viewMode: "time", input: false, onClose: close, locale: locale, mobileUI: true, showToolbar: false, viewDate: moment__default["default"]().set({
                    hour: dateTime[0],
                    minute: dateTime[1],
                    second: dateTime[2] || 0
                }), timeConstraints: timeConstraints, isValidDate: this.checkIsValidDate, isEndDate: isEndDate })));
    };
    CalendarMobile.prototype.openDatePicker = function () {
        this.setState({ isPopupOpen: true });
    };
    CalendarMobile.prototype.closePopup = function () {
        this.setState({ isPopupOpen: false });
    };
    CalendarMobile.prototype.handleDateChange = function (currentDate) {
        this.setState({
            currentDate: currentDate
        });
        this.scollToDate(currentDate);
        this.closePopup();
    };
    CalendarMobile.prototype.render = function () {
        var _a = this.props, className = _a.className, cx = _a.classnames, embed = _a.embed, close = _a.close, confirm = _a.confirm, footerExtra = _a.footerExtra, timeFormat = _a.timeFormat, showViewMode = _a.showViewMode, isDatePicker = _a.isDatePicker, locale = _a.locale, popOverContainer = _a.popOverContainer, timeConstraints = _a.timeConstraints;
        var __ = this.props.translate;
        var _b = this.state, startDate = _b.startDate, endDate = _b.endDate, currentDate = _b.currentDate, showToast = _b.showToast, isScrollToBottom = _b.isScrollToBottom, minDate = _b.minDate, maxDate = _b.maxDate, isPopupOpen = _b.isPopupOpen;
        var header = (_J$X_("div", { className: cx('CalendarMobile-header'), ref: this.mobileHeader },
            _J$X_("div", { className: cx('CalendarMobile-subtitle') },
                _J$X_("span", { className: "subtitle-text" },
                    currentDate &&
                        currentDate.isSameOrBefore(minDate, showViewMode) ? null : (_J$X_("a", { className: "rdtPrev", onClick: this.scrollPreYear }, "\u2039")),
                    _J$X_("span", { onClick: this.openDatePicker }, moment__default["default"](currentDate).format('YYYY')),
                    (currentDate &&
                        currentDate.isSameOrAfter(maxDate, showViewMode)) ||
                        isScrollToBottom ? null : (_J$X_("a", { className: "rdtNext", onClick: this.scrollAfterYear }, "\u203A")))),
            showViewMode === 'months' ? (_J$X_("div", { className: cx('CalendarMobile-weekdays') }, this.getDaysOfWeek().map(function (day, index) { return (_J$X_("span", { key: day + index, className: "weekday" }, day)); }))) : null));
        var footer = (_J$X_("div", { className: cx('CalendarMobile-footer') },
            timeFormat && startDate && this.renderMobileTimePicker(),
            _J$X_("div", { className: cx('CalendarMobile-footer-toolbar') },
                _J$X_("div", { className: cx('CalendarMobile-footer-ranges') }, footerExtra),
                confirm && !embed && (_J$X_("a", { className: cx('Button', 'Button--primary', 'date-range-confirm', {
                        'is-disabled': !startDate || !(endDate || isDatePicker)
                    }), onClick: function () {
                        confirm(startDate, endDate);
                        close && close();
                    } }, __('confirm'))))));
        return (_J$X_("div", { className: cx('CalendarMobile', embed ? 'CalendarMobile-embed' : '', className) },
            _J$X_("div", { className: cx('CalendarMobile-wrap') },
                header,
                this.renderMobileCalendarBody(),
                footer),
            showToast ? (_J$X_("div", { className: cx('CalendarMobile-toast') }, __('Calendar.toast'))) : null,
            _J$X_(PopUp["default"], { className: cx("DatePicker-popup DatePicker-mobile"), container: popOverContainer, isShow: isPopupOpen, showClose: false, onHide: this.closePopup },
                _J$X_(Calendar["default"], { value: currentDate, onChange: this.handleDateChange, requiredConfirm: false, isValidDate: this.checkIsValidDate, viewMode: "months", timeConstraints: timeConstraints, input: false, onClose: this.closePopup, locale: locale, minDate: minDate, maxDate: maxDate, mobileUI: true }))));
    };
    CalendarMobile.defaultProps = {
        showViewMode: 'months'
    };
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "scrollPreYear", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "scrollAfterYear", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "handleCalendarClick", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "handleTimeChange", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "checkIsValidDate", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "renderMobileDay", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Number, Number]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "renderMonth", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Number, Number]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "renderQuarter", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "handleMobileChange", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "renderMobileCalendarBody", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "renderMobileTimePicker", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "openDatePicker", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "closePopup", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], CalendarMobile.prototype, "handleDateChange", null);
    return CalendarMobile;
}(React__default["default"].Component));
var CalendarMobile$1 = amisCore.themeable(amisCore.localeable(CalendarMobile));

exports.CalendarMobile = CalendarMobile;
exports["default"] = CalendarMobile$1;
