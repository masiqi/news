/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var pick = require('lodash/pick');
var RcMenu = require('rc-menu');
var amisCore = require('amis-core');
var Badge = require('../Badge.js');
var icons = require('../icons.js');
var TooltipWrapper = require('../TooltipWrapper.js');
var MenuContext = require('./MenuContext.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var pick__default = /*#__PURE__*/_interopDefaultLegacy(pick);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var DragIcon = icons.getIcon('drag-bar');
var MenuItem = /** @class */ (function (_super) {
    tslib.__extends(MenuItem, _super);
    function MenuItem() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * 内部使用的属性
         *
         * @memberof MenuItem
         */
        _this.internalProps = [
            'children',
            'eventKey',
            'warnKey',
            'disabled',
            'itemIcon',
            'attribute',
            'onMouseEnter',
            'onMouseLeave',
            'onClick',
            'className'
        ];
        return _this;
    }
    /** 检查icon参数值是否为文件路径 */
    MenuItem.prototype.isImgPath = function (raw) {
        return (typeof raw === 'string' &&
            (!!~raw.indexOf('.') || /^\/images\//.test(raw)));
    };
    MenuItem.prototype.renderMenuItem = function () {
        var _a, _b, _c, _d;
        var _e, _f;
        var _g = this.context, collapsed = _g.collapsed, draggable = _g.draggable, stacked = _g.stacked, mode = _g.mode, onDragStart = _g.onDragStart;
        var _h = this.props, cx = _h.classnames, icon = _h.icon, label = _h.label, labelExtra = _h.labelExtra, path = _h.path, depth = _h.depth, badge = _h.badge, badgeClassName = _h.badgeClassName, renderLink = _h.renderLink, extra = _h.extra, disabled = _h.disabled, testIdBuilder = _h.testIdBuilder, id = _h.id, defaultData = _h.data;
        var isCollapsedNode = collapsed && depth === 1;
        var iconNode = icon ? (typeof icon === 'string' ? (this.isImgPath(icon) ? (_J$X_("div", { className: cx("Nav-Menu-item-icon") },
            _J$X_("img", { width: "14px", src: icon }))) : (_J$X_("i", { className: cx("Nav-Menu-item-icon", icon, (_a = {},
                _a['Nav-Menu-item-icon-collapsed'] = isCollapsedNode,
                _a)) }))) : React__default["default"].isValidElement(icon) ? (React__default["default"].cloneElement(icon, {
            className: cx("Nav-Menu-item-icon", (_e = icon.props) === null || _e === void 0 ? void 0 : _e.className, (_b = {},
                _b['Nav-Menu-item-icon-svg-collapsed'] = isCollapsedNode,
                _b))
        })) : null) : null;
        var labelNode = label && (typeof label === 'string' || Array.isArray(label)) ? (_J$X_("span", { className: cx("Nav-Menu-item-label", (_c = {},
                _c['Nav-Menu-item-label-collapsed'] = isCollapsedNode,
                _c)), title: isCollapsedNode || Array.isArray(label) ? '' : label }, isCollapsedNode ? label.slice(0, 1) : label)) : React__default["default"].isValidElement(label) ? (React__default["default"].cloneElement(label, {
            className: cx('Nav-Menu-item-label', (_f = label === null || label === void 0 ? void 0 : label.props) === null || _f === void 0 ? void 0 : _f.className, (_d = {},
                _d['Nav-Menu-item-label-collapsed'] = isCollapsedNode,
                _d['Nav-Menu-item-label-subTitle'] = !isCollapsedNode,
                _d))
        })) : null;
        var dragNode = !disabled && stacked && mode === 'inline' && !collapsed && draggable ? (_J$X_("span", { className: cx('Nav-Menu-item-dragBar'), draggable: true },
            _J$X_(DragIcon, null))) : null;
        var link = renderLink && typeof renderLink === 'function'
            ? renderLink(this.props)
            : path || '';
        return (_J$X_("div", { className: cx('Nav-Menu-item-wrap') },
            _J$X_(Badge.Badge, { classnames: cx, badge: badge && !isCollapsedNode // 收起模式下 不展示角标
                    ? tslib.__assign(tslib.__assign({}, badge), { className: badgeClassName }) : null, data: amisCore.createObject(defaultData, link) },
                _J$X_("a", tslib.__assign({ className: cx('Nav-Menu-item-link'), title: typeof (link === null || link === void 0 ? void 0 : link.label) === 'string' ? link === null || link === void 0 ? void 0 : link.label : undefined, "data-id": (link === null || link === void 0 ? void 0 : link.__id) || id, "data-depth": depth, onDragStart: onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(link) }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getTestId()), isCollapsedNode ? (_J$X_(React__default["default"].Fragment, null, iconNode || labelNode)) : (_J$X_(React__default["default"].Fragment, null,
                    dragNode,
                    iconNode,
                    labelNode,
                    labelExtra)))),
            extra ? (_J$X_("div", { className: cx('Nav-Menu-item-extra') }, extra)) : null));
    };
    MenuItem.prototype.render = function () {
        var _a;
        var _b = this.props, tooltipClassName = _b.tooltipClassName, cx = _b.classnames, label = _b.label, disabled = _b.disabled, disabledTip = _b.disabledTip, tooltipContainer = _b.tooltipContainer, tooltipTrigger = _b.tooltipTrigger, depth = _b.depth, hidden = _b.hidden, order = _b.order, overflowedIndicator = _b.overflowedIndicator, overflowMaxCount = _b.overflowMaxCount;
        var _c = this.context, collapsed = _c.collapsed, mode = _c.mode, stacked = _c.stacked, themeColor = _c.themeColor, direction = _c.direction;
        var showToolTip = stacked && mode === 'inline' && collapsed && depth === 1;
        var isMaxOverflow = overflowedIndicator && overflowMaxCount;
        // 多套一层ul 是因为disabled情况下 RcItem触发不了tooltipwrapper的事件
        // 横向模式使用rc-overflow rc-overflow中会给li设置一个order属性
        // 这里的ul可能和rc-overflow里的li并列 就导致展示顺序不正确 因此给url也设置一个order属性
        // 当启用响应式收纳且设置了maxVisibleCount rc-overflow不会设置order属性 因此这种情况下ul也不需要设置
        return hidden ? null : (_J$X_(TooltipWrapper["default"], { tooltipClassName: cx('Nav-Menu-item-tooltip', tooltipClassName, (_a = {},
                _a['Nav-Menu-item-tooltip-dark'] = themeColor === 'dark',
                _a)), placement: direction === 'rtl' ? 'left' : 'right', tooltip: disabled ? disabledTip : showToolTip ? label : '', container: tooltipContainer, trigger: tooltipTrigger, rootClose: true },
            _J$X_("ul", { className: cx('Nav-Menu-item-tooltip-wrap'), style: isMaxOverflow ? {} : { order: order } },
                _J$X_(RcMenu.Item, tslib.__assign({}, pick__default["default"](this.props, this.internalProps)), this.renderMenuItem()))));
    };
    MenuItem.defaultProps = {
        disabled: false,
        tooltipTrigger: ['hover', 'focus']
    };
    MenuItem.contextType = MenuContext.MenuContext;
    return MenuItem;
}(React__default["default"].Component));
var MenuItem$1 = amisCore.themeable(MenuItem);

exports.MenuItem = MenuItem;
exports["default"] = MenuItem$1;
