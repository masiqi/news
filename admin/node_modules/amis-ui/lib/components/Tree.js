/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var amisCore = require('amis-core');
var Select = require('./Select.js');
var icons = require('./icons.js');
var Checkbox = require('./Checkbox.js');
var Spinner = require('./Spinner.js');
var index = require('./virtual-list/index.js');
var TooltipWrapper = require('./TooltipWrapper.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var TreeSelector = /** @class */ (function (_super) {
    tslib.__extends(TreeSelector, _super);
    function TreeSelector(props) {
        var _this = _super.call(this, props) || this;
        // 展开的节点
        _this.unfolded = new WeakMap();
        // key: child option, value: parent option;
        _this.relations = new WeakMap();
        _this.levels = new WeakMap();
        _this.startPoint = {
            x: 0,
            y: 0
        };
        _this.root = React__default["default"].createRef();
        _this.virtualListRef = null;
        var value = Select.value2array(props.value, {
            multiple: props.multiple,
            delimiter: props.delimiter,
            valueField: props.valueField,
            labelField: props.labelField,
            options: props.options,
            pathSeparator: props.pathSeparator
        }, props.enableNodePath);
        _this.state = {
            value: value,
            valueSet: new Set(value),
            flattenedOptions: [],
            inputValue: '',
            addingParent: null,
            isAdding: false,
            isEditing: false,
            editingItem: null,
            dropIndicator: undefined,
            virtualHeight: 0,
            itemHeight: 0
        };
        _this.syncUnFolded(props, undefined, true);
        _this.flattenOptions(props, true);
        return _this;
    }
    TreeSelector.prototype.componentDidMount = function () {
        var _a, _b, _c;
        var enableNodePath = this.props.enableNodePath;
        // onRef只有渲染器的情况才会使用
        (_b = (_a = this.props).onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        enableNodePath && this.expandLazyLoadNodes();
        var treeElement = this.root.current;
        treeElement =
            ((_c = treeElement === null || treeElement === void 0 ? void 0 : treeElement.parentElement) === null || _c === void 0 ? void 0 : _c.matches('.cxd-TreeControl')) &&
                treeElement.parentElement.childElementCount === 1
                ? treeElement.parentElement
                : treeElement;
        this.unSensor = amisCore.resizeSensor(treeElement, this.handleVirtualHeight, false, 'height');
    };
    TreeSelector.prototype.componentDidUpdate = function (prevProps, prevState) {
        var props = this.props;
        this.state;
        if (prevProps.options !== props.options) {
            this.syncUnFolded(props);
            this.flattenOptions(props);
        }
        if (prevProps.value !== props.value ||
            prevProps.options !== props.options) {
            var newValue = Select.value2array(props.value, {
                multiple: props.multiple,
                delimiter: props.delimiter,
                valueField: props.valueField,
                pathSeparator: props.pathSeparator,
                options: props.options,
                labelField: props.labelField
            }, props.enableNodePath);
            this.setState({
                value: newValue,
                valueSet: new Set(newValue)
            });
        }
    };
    TreeSelector.prototype.componentWillUnmount = function () {
        // clear data
        this.relations = this.unfolded = this.levels = new WeakMap();
        if (this.unSensor) {
            this.unSensor();
            delete this.unSensor;
        }
    };
    /**
     * 展开懒加载节点的父节点
     */
    TreeSelector.prototype.expandLazyLoadNodes = function () {
        var _a = this.props, pathSeparator = _a.pathSeparator, onExpandTree = _a.onExpandTree, _b = _a.nodePath, nodePath = _b === void 0 ? [] : _b;
        var nodePathArr = nodePath.map(function (path) {
            return path ? path.toString().split(pathSeparator) : [];
        });
        onExpandTree === null || onExpandTree === void 0 ? void 0 : onExpandTree(nodePathArr);
    };
    TreeSelector.prototype.virtualListRefSetter = function (ref) {
        this.virtualListRef = ref;
        ref && this.handleVirtualHeight();
    };
    TreeSelector.prototype.syncUnFolded = function (props, unfoldedLevel, initial) {
        // 传入默认展开层级需要重新初始化unfolded
        var initFoldedLevel = typeof unfoldedLevel !== 'undefined';
        var expandLevel = Number(initFoldedLevel ? unfoldedLevel : props.unfoldedLevel);
        // 初始化树节点的展开状态
        var unfolded = this.unfolded;
        var _a = this.props, deferField = _a.deferField, foldedField = _a.foldedField, unfoldedField = _a.unfoldedField;
        amisCore.eachTree(props.options, function (node, index, level) {
            if (unfolded.has(node) && !initFoldedLevel) {
                return;
            }
            if (node.children && node.children.length) {
                var ret = true;
                if (node[deferField] &&
                    node.loaded &&
                    !initFoldedLevel &&
                    unfoldedField &&
                    node[unfoldedField] !== false) {
                    ret = true;
                }
                else if (unfoldedField &&
                    typeof node[unfoldedField] !== 'undefined') {
                    ret = !!node[unfoldedField];
                }
                else if (foldedField && typeof node[foldedField] !== 'undefined') {
                    ret = !node[foldedField];
                }
                else {
                    ret = !!props.initiallyOpen && !initFoldedLevel;
                    if (!ret && level <= expandLevel) {
                        ret = true;
                    }
                }
                unfolded.set(node, ret);
            }
        });
        initFoldedLevel && this.forceUpdate();
        this.flattenOptions(undefined, initial);
        return unfolded;
    };
    TreeSelector.prototype.toggleUnfolded = function (node) {
        var unfolded = this.unfolded;
        var _a = this.props, deferField = _a.deferField, onDeferLoad = _a.onDeferLoad, unfoldedField = _a.unfoldedField;
        if (node[deferField] && !node.loaded) {
            onDeferLoad === null || onDeferLoad === void 0 ? void 0 : onDeferLoad(node);
            return;
        }
        // ！ hack: 在node上直接添加属性，options 在更新的时候旧的字段会保留
        if (node[deferField] && node.loaded) {
            node[unfoldedField] = !unfolded.get(node);
        }
        unfolded.set(node, !unfolded.get(node));
        this.flattenOptions();
        this.forceUpdate();
    };
    TreeSelector.prototype.isUnfolded = function (node) {
        var unfolded = this.unfolded;
        var parent = this.relations.get(node);
        if (parent) {
            return !!unfolded.get(node) && this.isUnfolded(parent);
        }
        return !!unfolded.get(node);
    };
    TreeSelector.prototype.clearSelect = function () {
        var _this = this;
        this.setState({
            value: []
        }, function () {
            var _a = _this.props, joinValues = _a.joinValues, rootValue = _a.rootValue, onChange = _a.onChange;
            onChange(joinValues ? rootValue : []);
        });
    };
    /**
     * enableNodePath为true时，将label和value转换成node path格式
     */
    TreeSelector.prototype.transform2NodePath = function (value) {
        var _a = this.props, multiple = _a.multiple, options = _a.options, valueField = _a.valueField, labelField = _a.labelField, joinValues = _a.joinValues, extractValue = _a.extractValue, pathSeparator = _a.pathSeparator, delimiter = _a.delimiter;
        var nodesValuePath = [];
        var selectedNodes = Array.isArray(value) ? value.concat() : [value];
        var selectedNodesPath = selectedNodes.map(function (node) {
            var _a, _b;
            var _c;
            var nodePath = (_c = amisCore.getTreeAncestors(options, node, true)) === null || _c === void 0 ? void 0 : _c.reduce(function (acc, node) {
                acc[labelField].push(node[labelField]);
                acc[valueField].push(node[valueField]);
                return acc;
            }, (_a = {}, _a[labelField] = [], _a[valueField] = [], _a));
            var nodeValuePath = nodePath[valueField].join(pathSeparator);
            nodesValuePath.push(nodeValuePath);
            return tslib.__assign(tslib.__assign({}, node), (_b = {}, _b[labelField] = nodePath[labelField].join(pathSeparator), _b[valueField] = nodeValuePath, _b));
        });
        if (multiple) {
            return joinValues
                ? nodesValuePath.join(delimiter)
                : extractValue
                    ? nodesValuePath
                    : selectedNodesPath;
        }
        else {
            return joinValues || extractValue
                ? selectedNodesPath[0][valueField]
                : selectedNodesPath[0];
        }
    };
    TreeSelector.prototype.handleSelect = function (node, value) {
        var _this = this;
        var _a = this.props, joinValues = _a.joinValues, valueField = _a.valueField, deferField = _a.deferField, onChange = _a.onChange, enableNodePath = _a.enableNodePath, onlyLeaf = _a.onlyLeaf;
        if (node[valueField] === undefined) {
            if (node[deferField] && !node.loaded) {
                this.toggleUnfolded(node);
            }
            return;
        }
        if (onlyLeaf && Array.isArray(node.children) && node.children.length) {
            return;
        }
        this.setState({
            value: [node]
        }, function () {
            onChange(enableNodePath
                ? _this.transform2NodePath(node)
                : joinValues
                    ? node[valueField]
                    : node);
        });
    };
    TreeSelector.prototype.handleItemClick = function (node, checked) {
        var _a;
        var _b = this.props, onHandleNodeClick = _b.onHandleNodeClick, multiple = _b.multiple, _c = _b.nodeBehavior, nodeBehavior = _c === void 0 ? ['check'] : _c;
        onHandleNodeClick && onHandleNodeClick(node);
        if ((nodeBehavior === null || nodeBehavior === void 0 ? void 0 : nodeBehavior.includes('unfold')) && ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length)) {
            this.toggleUnfolded(node);
        }
        if (nodeBehavior === null || nodeBehavior === void 0 ? void 0 : nodeBehavior.includes('check')) {
            multiple ? this.handleCheck(node, !checked) : this.handleSelect(node);
        }
    };
    TreeSelector.prototype.handleCheck = function (item, checked) {
        var _this = this;
        // TODO: 重新梳理这里的逻辑
        var props = this.props;
        var value = this.state.valueSet;
        var onlyChildren = props.onlyChildren, withChildren = props.withChildren, cascade = props.cascade, autoCheckChildren = props.autoCheckChildren, autoCancelParent = props.autoCancelParent, valueField = props.valueField;
        if (checked) {
            if (!value.has(item)) {
                value.add(item);
            }
            // cascade 为 true 表示父节点跟子节点没有级联关系。
            if (autoCheckChildren) {
                var children = item.children ? tslib.__spreadArray([], tslib.__read(item.children), false) : [];
                var hasDisabled = amisCore.flattenTree(children).some(function (item) { return item === null || item === void 0 ? void 0 : item.disabled; });
                if (onlyChildren) {
                    // 这个 isAllChecked 主要是判断如果有disabled的item项，这时父节点还是选中的话，针对性的处理逻辑
                    var isAllChecked = amisCore.flattenTreeWithLeafNodes(children)
                        .filter(function (item) { return !(item === null || item === void 0 ? void 0 : item.disabled); })
                        .every(function (v) { return value.has(v); });
                    // 父级选中的时候，子节点也都选中，但是自己不选中
                    if (value.has(item) && children.length) {
                        value.delete(item);
                    }
                    while (children.length) {
                        var child = children.shift();
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                            continue;
                        }
                        if (hasDisabled && isAllChecked) {
                            if (value.has(child) &&
                                child.value !== 'undefined' &&
                                !(child === null || child === void 0 ? void 0 : child.disabled)) {
                                value.delete(child);
                            }
                            continue;
                        }
                        if (!value.has(child) &&
                            child.value !== 'undefined' &&
                            !(child === null || child === void 0 ? void 0 : child.disabled)) {
                            value.add(child);
                        }
                    }
                }
                else {
                    // 这个 isAllChecked 主要是判断如果有disabled的item项，这时父节点还是选中的话，针对性的处理逻辑
                    var isAllChecked = amisCore.flattenTree(children)
                        .filter(function (item) { return !(item === null || item === void 0 ? void 0 : item.disabled); })
                        .every(function (v) { return value.has(v); });
                    // 只要父节点选择了,子节点就不需要了,全部去掉勾选.  withChildren时相反
                    while (children.length) {
                        var child = children.shift();
                        if (child === null || child === void 0 ? void 0 : child.disabled) {
                            continue;
                        }
                        // 判断下下面是否有禁用项
                        if (!hasDisabled) {
                            if (value.has(child)) {
                                value.delete(child);
                            }
                            if (withChildren || cascade) {
                                value.add(child);
                            }
                        }
                        else {
                            isAllChecked ? value.delete(child) : value.add(child);
                        }
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                        }
                    }
                    var toCheck = item;
                    while (true) {
                        var parent_1 = amisCore.getTreeParent(props.options, toCheck);
                        // 判断 parent 节点是否已经勾选，避免重复值
                        if ((parent_1 === null || parent_1 === void 0 ? void 0 : parent_1[valueField || 'value']) && !value.has(parent_1)) {
                            // 如果所有孩子节点都勾选了，应该自动勾选父级。
                            if (parent_1.children.every(function (child) { return value.has(child); })) {
                                if (!cascade && !withChildren) {
                                    parent_1.children.forEach(function (child) {
                                        if (value.has(child)) {
                                            value.delete(child);
                                        }
                                    });
                                }
                                value.add(parent_1);
                                toCheck = parent_1;
                                continue;
                            }
                        }
                        break;
                    }
                }
            }
        }
        else {
            value.has(item) && value.delete(item);
            if (autoCheckChildren) {
                if (cascade || withChildren || onlyChildren) {
                    var children = item.children ? tslib.__spreadArray([], tslib.__read(item.children), false) : [];
                    while (children.length) {
                        var child = children.shift();
                        if (value.has(child) && !(child === null || child === void 0 ? void 0 : child.disabled)) {
                            value.delete(child);
                        }
                        if (child.children && child.children.length) {
                            children.push.apply(children, child.children);
                        }
                    }
                }
            }
            if (autoCancelParent && cascade) {
                var toCheck = item;
                while (true) {
                    var parent_2 = amisCore.getTreeParent(props.options, toCheck);
                    //判断 parent 节点是否已经勾选
                    if (value.has(parent_2)) {
                        //当有一个子节点取消时要去掉父节点，也要去掉父节点的父节点，直至最外层
                        value.delete(parent_2);
                        toCheck = parent_2;
                        continue;
                    }
                    break;
                }
            }
        }
        this.setState({
            value: tslib.__spreadArray([], tslib.__read(value), false)
        }, function () { return _this.fireChange(tslib.__spreadArray([], tslib.__read(value), false)); });
    };
    TreeSelector.prototype.fireChange = function (value) {
        var _a = this.props, joinValues = _a.joinValues, extractValue = _a.extractValue, valueField = _a.valueField, delimiter = _a.delimiter, onChange = _a.onChange, enableNodePath = _a.enableNodePath;
        onChange(enableNodePath
            ? this.transform2NodePath(value)
            : joinValues
                ? value.map(function (item) { return item[valueField]; }).join(delimiter)
                : extractValue
                    ? value.map(function (item) { return item[valueField]; })
                    : value);
    };
    TreeSelector.prototype.handleAdd = function (parent) {
        var _this = this;
        if (parent === void 0) { parent = null; }
        var _a = this.props, bultinCUD = _a.bultinCUD, onAdd = _a.onAdd, options = _a.options;
        if (!bultinCUD) {
            var idxes = amisCore.findTreeIndex(options, function (item) { return item === parent; }) || [];
            return onAdd && onAdd(idxes.concat(0));
        }
        else {
            this.setState({
                isEditing: false,
                isAdding: true,
                addingParent: parent
            }, function () {
                var e_1, _a;
                if (!parent) {
                    return;
                }
                var result = [];
                try {
                    for (var _b = tslib.__values(_this.state.flattenedOptions), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var option = _c.value;
                        result.push(option);
                        if (option === parent) {
                            var insert = { isAdding: true };
                            _this.levels.set(insert, (_this.levels.get(option) || 0) + 1);
                            result.push(insert);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                _this.setState({ flattenedOptions: result });
            });
        }
    };
    TreeSelector.prototype.handleEdit = function (item) {
        var _a = this.props, bultinCUD = _a.bultinCUD, onEdit = _a.onEdit, labelField = _a.labelField; _a.options;
        if (!bultinCUD) {
            onEdit === null || onEdit === void 0 ? void 0 : onEdit(item);
        }
        else {
            this.setState({
                isEditing: true,
                isAdding: false,
                editingItem: item,
                inputValue: item[labelField]
            });
        }
    };
    TreeSelector.prototype.handleRemove = function (item) {
        var onDelete = this.props.onDelete;
        onDelete && onDelete(item);
    };
    TreeSelector.prototype.handleInputChange = function (e) {
        this.setState({
            inputValue: e.currentTarget.value
        });
    };
    TreeSelector.prototype.handleConfirm = function () {
        var _a = this.state, value = _a.inputValue, isAdding = _a.isAdding, addingParent = _a.addingParent, editingItem = _a.editingItem, isEditing = _a.isEditing;
        if (!value) {
            return;
        }
        var _b = this.props, labelField = _b.labelField, onAdd = _b.onAdd, options = _b.options, onEdit = _b.onEdit;
        this.setState({
            inputValue: '',
            isAdding: false,
            isEditing: false
        }, function () {
            var _a, _b;
            if (isAdding && onAdd) {
                var idxes = (addingParent &&
                    amisCore.findTreeIndex(options, function (item) { return item === addingParent; })) ||
                    [];
                onAdd(idxes.concat(0), (_a = {}, _a[labelField] = value, _a), true);
            }
            else if (isEditing && onEdit) {
                onEdit(tslib.__assign(tslib.__assign({}, editingItem), (_b = {}, _b[labelField] = value, _b)), editingItem, true);
            }
        });
    };
    TreeSelector.prototype.handleCancel = function () {
        var flattenedOptions = this.state.flattenedOptions;
        var flattenedOptionsWithoutAdding = flattenedOptions.filter(function (item) { return !item.isAdding; });
        this.setState({
            inputValue: '',
            isAdding: false,
            isEditing: false,
            flattenedOptions: flattenedOptionsWithoutAdding
        });
    };
    TreeSelector.prototype.renderInput = function (prfix, testIdBuilder) {
        if (prfix === void 0) { prfix = null; }
        var _a = this.props, cx = _a.classnames, mobileUI = _a.mobileUI, __ = _a.translate;
        var inputValue = this.state.inputValue;
        return (_J$X_("div", { className: cx('Tree-itemLabel', {
                'is-mobile': mobileUI
            }) },
            _J$X_("div", { className: cx('Tree-itemInput', {
                    'is-mobile': mobileUI
                }) },
                prfix,
                _J$X_("input", tslib.__assign({ onChange: this.handleInputChange, value: inputValue, placeholder: __('placeholder.enter') }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('input').getTestId())),
                _J$X_("a", tslib.__assign({ "data-tooltip": __('cancel'), onClick: this.handleCancel }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('cancel').getTestId()),
                    _J$X_(icons.Icon, { icon: "close", className: "icon" })),
                _J$X_("a", tslib.__assign({ "data-tooltip": __('confirm'), onClick: this.handleConfirm }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('confirm').getTestId()),
                    _J$X_(icons.Icon, { icon: "check", className: "icon" })))));
    };
    TreeSelector.prototype.getOffsetPosition = function (element) {
        var left = 0;
        var top = 0;
        while (element.offsetParent) {
            left += element.offsetLeft;
            top += element.offsetTop;
            element = element.offsetParent;
        }
        return { left: left, top: top };
    };
    TreeSelector.prototype.getDropInfo = function (e, node) {
        var _a;
        var rect = e.currentTarget.getBoundingClientRect();
        var dragNode = this.dragNode;
        var deltaX = Math.min(50, rect.width * 0.3);
        var gap = ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) ? 0 : 16;
        // 计算相对位置
        var offset = this.getOffsetPosition(this.root.current);
        var targetOffset = this.getOffsetPosition(e.currentTarget);
        var left = targetOffset.left - offset.left;
        var top = targetOffset.top - offset.top;
        var clientX = e.clientX, clientY = e.clientY;
        var position = clientY >= rect.top + rect.height / 2 ? 'bottom' : 'top';
        var indicator;
        if (position === 'bottom' && clientX >= this.startPoint.x + deltaX) {
            position = 'self';
            indicator = {
                top: top,
                left: left,
                width: rect.width,
                height: rect.height
            };
        }
        else {
            indicator = {
                top: position === 'bottom' ? top + rect.height : top,
                left: left + gap,
                width: rect.width - gap
            };
        }
        return {
            node: node,
            dragNode: dragNode,
            position: position,
            indicator: indicator
        };
    };
    TreeSelector.prototype.updateDropIndicator = function (e, node) {
        // const gap = node?.children?.length ? 0 : 16;
        this.dropInfo = this.getDropInfo(e, node);
        var _a = this.dropInfo, dragNode = _a.dragNode, indicator = _a.indicator;
        if (node === dragNode) {
            this.setState({ dropIndicator: undefined });
            return;
        }
        this.setState({
            dropIndicator: indicator
        });
    };
    TreeSelector.prototype.onDragStart = function (node) {
        var _this = this;
        var draggable = this.props.draggable;
        return function (e) {
            var _a;
            if (draggable) {
                e.dataTransfer.effectAllowed = 'copyMove';
                _this.dragNode = node;
                _this.dropInfo = null;
                _this.startPoint = {
                    x: e.clientX,
                    y: e.clientY
                };
                if ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) {
                    _this.unfolded.set(node, false);
                    _this.flattenOptions();
                    _this.forceUpdate();
                }
            }
            else {
                _this.dragNode = null;
                _this.dropInfo = null;
            }
            e.stopPropagation();
        };
    };
    TreeSelector.prototype.onDragOver = function (node) {
        var _this = this;
        return function (e) {
            if (!_this.dragNode) {
                return;
            }
            _this.updateDropIndicator(e, node);
            e.preventDefault();
        };
    };
    TreeSelector.prototype.onDragEnd = function (dragNode) {
        var _this = this;
        return function (e) {
            var _a, _b, _c;
            _this.setState({
                dropIndicator: undefined
            });
            var node = (_a = _this.dropInfo) === null || _a === void 0 ? void 0 : _a.node;
            if (!_this.dropInfo || !node || dragNode === node) {
                return;
            }
            (_c = (_b = _this.props).onMove) === null || _c === void 0 ? void 0 : _c.call(_b, _this.dropInfo);
            _this.dragNode = null;
            _this.dropInfo = null;
            e.preventDefault();
        };
    };
    /**
     * 将树形接口转换为平铺结构，以支持虚拟列表
     * TODO: this.unfolded => reaction 更加合理
     */
    TreeSelector.prototype.flattenOptions = function (props, initial) {
        var _this = this;
        var flattenedOptions = [];
        amisCore.eachTree((props === null || props === void 0 ? void 0 : props.options) || this.props.options, function (item, index, level, paths) {
            var parent = paths[paths.length - 1];
            if (!amisCore.isVisible(item)) {
                return;
            }
            _this.levels.set(item, level);
            parent && _this.relations.set(item, parent);
            if (paths.length === 0) {
                // 父节点
                flattenedOptions.push(item);
            }
            else if (_this.isUnfolded(parent)) {
                // 父节点是展开的状态
                flattenedOptions.push(item);
            }
        });
        if (initial) {
            // 初始化
            this.state = tslib.__assign(tslib.__assign({}, this.state), { flattenedOptions: flattenedOptions });
        }
        else {
            this.setState({
                flattenedOptions: flattenedOptions
            });
        }
    };
    /**
     * 判断父元素是否勾选
     * TODO: 递归可能需要优化
     */
    TreeSelector.prototype.isParentChecked = function (item) {
        if (!item || !this.relations.get(item)) {
            return false;
        }
        var valueSet = this.state.valueSet;
        var currentItem = item;
        while (currentItem) {
            var itemParent = this.relations.get(currentItem);
            if (!itemParent) {
                return false;
            }
            if (valueSet.has(itemParent)) {
                return true;
            }
            currentItem = itemParent;
        }
        return false;
    };
    /**
     * 判断 子元素 是否全部选中
     */
    TreeSelector.prototype.isItemChildrenChecked = function (item) {
        var _this = this;
        if (!item || !item.children) {
            return true;
        }
        return !item.children.some(function (child) { return !_this.isItemChecked(child); });
    };
    /**
     * 判断子元素 部分勾选
     */
    TreeSelector.prototype.isItemChildrenPartialChecked = function (item, checked) {
        var e_2, _a;
        if (!item || !item.children || checked) {
            return false;
        }
        var checkedLength = 0;
        var partialChildrenLength = 0;
        try {
            for (var _b = tslib.__values(item.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (this.isItemChecked(child)) {
                    checkedLength++;
                }
                else if (this.isItemChildrenPartialChecked(child, false)) {
                    partialChildrenLength++;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return checkedLength !== 0 || partialChildrenLength !== 0;
    };
    /**
     * 判断元素是否选中：checked
     */
    TreeSelector.prototype.isItemChecked = function (item) {
        var _a;
        if (!item) {
            return false;
        }
        var _b = this.props, autoCheckChildren = _b.autoCheckChildren, onlyChildren = _b.onlyChildren, multiple = _b.multiple, withChildren = _b.withChildren, cascade = _b.cascade;
        var valueSet = this.state.valueSet;
        var checked = valueSet.has(item);
        if (checked) {
            return true;
        }
        if ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length) {
            if (onlyChildren && autoCheckChildren) {
                if (this.isItemChildrenChecked(item)) {
                    // 当前元素没有在 value 中，但是子组件全部勾选了
                    return true;
                }
            }
        }
        var itemParent = this.relations.get(item);
        if (itemParent && multiple && autoCheckChildren) {
            // 当前节点为子节点
            if (withChildren || cascade) {
                return false;
            }
            return this.isParentChecked(item);
        }
        // 判断父组件是否勾选
        return false;
    };
    /**
     * item 是否 disabled 状态
     * props.disabled === true return;
     *
     */
    TreeSelector.prototype.isItemDisabled = function (item, checked) {
        var _a = this.props, disabledField = _a.disabledField, disabled = _a.disabled, autoCheckChildren = _a.autoCheckChildren, valueField = _a.valueField, multiple = _a.multiple, maxLength = _a.maxLength, minLength = _a.minLength, cascade = _a.cascade, onlyChildren = _a.onlyChildren;
        var value = this.state.value;
        var selfDisabled = item[disabledField];
        var nodeDisabled = !!disabled ||
            selfDisabled ||
            (multiple && !autoCheckChildren && !item[valueField]);
        if (nodeDisabled) {
            return true;
        }
        if ((maxLength && !checked && value.length >= maxLength) ||
            (minLength && checked && value.length <= minLength)) {
            return true;
        }
        var itemParent = this.relations.get(item);
        if (autoCheckChildren && multiple && checked && itemParent) {
            if (!this.isItemChecked(itemParent)) {
                return false;
            }
            // 子节点
            if (onlyChildren) {
                return false;
            }
            return !cascade;
        }
        return false;
    };
    TreeSelector.prototype.renderItem = function (_a) {
        var _this = this;
        var index = _a.index, style = _a.style, rest = tslib.__rest(_a, ["index", "style"]);
        var _b = this.props, itemClassName = _b.itemClassName, showIcon = _b.showIcon, showRadio = _b.showRadio, multiple = _b.multiple, labelField = _b.labelField, iconField = _b.iconField, deferField = _b.deferField, cascade = _b.cascade, cx = _b.classnames, highlightTxt = _b.highlightTxt, creatable = _b.creatable, editable = _b.editable, removable = _b.removable, createTip = _b.createTip, editTip = _b.editTip, removeTip = _b.removeTip, __ = _b.translate, itemRender = _b.itemRender, draggable = _b.draggable, loadingConfig = _b.loadingConfig, enableDefaultIcon = _b.enableDefaultIcon, valueField = _b.valueField, mobileUI = _b.mobileUI, testIdBuilder = _b.testIdBuilder, itemActionsRender = _b.itemActionsRender, actionClassName = _b.actionClassName;
        var item = this.state.flattenedOptions[index];
        if (!item) {
            return null;
        }
        var _c = this.state, isAdding = _c.isAdding, editingItem = _c.editingItem, isEditing = _c.isEditing;
        var checked = this.isItemChecked(item);
        var disabled = this.isItemDisabled(item, checked);
        var partial = this.isItemChildrenPartialChecked(item, checked);
        var checkedInValue = !!~this.state.value.indexOf(item);
        var itemTestBuilder = testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild("item-".concat(item[valueField] || item[labelField] || index));
        var checkbox = multiple ? (_J$X_(Checkbox["default"], { size: "sm", disabled: disabled, checked: checked || partial, partial: partial, onChange: this.handleCheck.bind(this, item, !checked), testIdBuilder: itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('chekbx') })) : showRadio ? (_J$X_(Checkbox["default"], { size: "sm", disabled: disabled, checked: checked, onChange: this.handleSelect.bind(this, item), testIdBuilder: itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('chekbx') })) : null;
        var isLeaf = (!item.children || !item.children.length) && !item.placeholder;
        var iconValue = item[iconField] ||
            (enableDefaultIcon !== false
                ? (Array.isArray(item.children) && item.children.length) ||
                    item[deferField]
                    ? 'folder'
                    : 'file'
                : false);
        var level = this.levels.has(item) ? this.levels.get(item) - 1 : 0;
        var body = null;
        if (isEditing && editingItem === item) {
            body = this.renderInput(checkbox, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('edit'));
        }
        else if (item.isAdding) {
            body = this.renderInput(_J$X_("span", { className: cx('Tree-itemArrowPlaceholder') }), itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('add'));
        }
        else {
            var isFolded = !this.isUnfolded(item);
            body = (_J$X_("div", { className: cx('Tree-itemLabel', {
                    'is-children-checked': multiple &&
                        !cascade &&
                        this.isItemChildrenChecked(item) &&
                        !disabled,
                    'is-checked': checkedInValue,
                    'is-disabled': disabled
                }), draggable: draggable, onDragStart: this.onDragStart(item), onDragOver: this.onDragOver(item), onDragEnd: this.onDragEnd(item) },
                draggable && (_J$X_("a", tslib.__assign({ className: cx('Tree-itemDrager drag-bar') }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('drag-bar').getTestId()),
                    _J$X_(icons.Icon, { icon: "drag-bar", className: "icon" }))),
                item.loading ? (_J$X_(Spinner["default"], { size: "sm", show: true, icon: "reload", spinnerClassName: cx('Tree-spinner'), loadingConfig: loadingConfig })) : !isLeaf || (item[deferField] && !item.loaded) ? (_J$X_("div", tslib.__assign({ onClick: function () { return _this.toggleUnfolded(item); }, className: cx('Tree-itemArrow', {
                        'is-folded': isFolded
                    }) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild(isFolded ? 'open' : 'fold').getTestId()),
                    _J$X_(icons.Icon, { icon: "down-arrow-bold", className: "icon" }))) : (_J$X_("span", { className: cx('Tree-itemArrowPlaceholder') })),
                checkbox,
                _J$X_("div", tslib.__assign({ className: cx('Tree-itemLabel-item', { 'is-mobile': mobileUI }) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('content').getTestId(), { onClick: function () { return !disabled && _this.handleItemClick(item, checked); } }),
                    showIcon ? (_J$X_("i", { className: cx("Tree-itemIcon ".concat((Array.isArray(item.children) && item.children.length) ||
                            item[deferField]
                            ? 'Tree-folderIcon'
                            : 'Tree-leafIcon')) }, iconValue ? _J$X_(icons.Icon, { icon: iconValue, className: "icon" }) : null)) : null,
                    _J$X_("span", tslib.__assign({ className: cx('Tree-itemText'), title: item[labelField] }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('text').getTestId()), itemRender
                        ? itemRender(item, {
                            index: index,
                            multiple: multiple,
                            checked: checked,
                            labelField: labelField,
                            onChange: function () { return _this.handleCheck(item, !checked); },
                            disabled: disabled || item.disabled,
                            classnames: cx
                        })
                        : highlightTxt
                            ? amisCore.highlight("".concat(item[labelField]), highlightTxt)
                            : "".concat(item[labelField])),
                    !disabled && !isAdding && !isEditing ? (_J$X_("div", { className: cx('Tree-item-icons', actionClassName), onClick: function (e) { return e.stopPropagation(); } },
                        creatable &&
                            !(item[deferField] && !item.loaded) &&
                            amisCore.hasAbility(item, 'creatable') ? (_J$X_(TooltipWrapper["default"], { placement: 'bottom', tooltip: __(createTip), trigger: 'hover', tooltipTheme: "dark" },
                            _J$X_("a", tslib.__assign({ onClick: this.handleAdd.bind(this, item) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('add').getTestId()),
                                _J$X_(icons.Icon, { icon: "plus", className: "icon" })))) : null,
                        removable && amisCore.hasAbility(item, 'removable') ? (_J$X_(TooltipWrapper["default"], { placement: 'bottom', tooltip: __(removeTip), trigger: 'hover', tooltipTheme: "dark" },
                            _J$X_("a", tslib.__assign({ onClick: this.handleRemove.bind(this, item) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('remove').getTestId()),
                                _J$X_(icons.Icon, { icon: "minus", className: "icon" })))) : null,
                        editable && amisCore.hasAbility(item, 'editable') ? (_J$X_(TooltipWrapper["default"], { placement: 'bottom', tooltip: __(editTip), trigger: 'hover', tooltipTheme: "dark" },
                            _J$X_("a", tslib.__assign({ onClick: this.handleEdit.bind(this, item) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getChild('edit').getTestId()),
                                _J$X_(icons.Icon, { icon: "new-edit", className: "icon" })))) : null,
                        itemActionsRender && (_J$X_("div", { className: cx('Tree-itemActions') }, itemActionsRender(item, tslib.__assign(tslib.__assign({}, item), { index: index, multiple: multiple, checked: checked, labelField: labelField, onChange: function () { return _this.handleCheck(item, !checked); }, disabled: disabled || item.disabled, classnames: cx })))))) : null)));
        }
        return (_J$X_("li", tslib.__assign({}, rest, { key: "".concat(item[valueField || 'value'], "-").concat(index), className: cx("Tree-item ".concat(itemClassName || ''), {
                'Tree-item--isLeaf': isLeaf,
                'is-child': this.relations.get(item)
            }), style: tslib.__assign(tslib.__assign({}, style), { '--Tree-depth': level }) }, itemTestBuilder === null || itemTestBuilder === void 0 ? void 0 : itemTestBuilder.getTestId()), body));
    };
    TreeSelector.prototype.isEmptyOrNotExist = function (obj) {
        return obj === '' || obj === undefined || obj === null;
    };
    TreeSelector.prototype.getAvailableOptions = function () {
        var _this = this;
        var _a = this.props, options = _a.options, onlyChildren = _a.onlyChildren, valueField = _a.valueField;
        var flattendOptions = amisCore.flattenTree(options, function (item) {
            var _a;
            return onlyChildren
                ? ((_a = item.children) === null || _a === void 0 ? void 0 : _a.length)
                    ? null
                    : item
                : _this.isEmptyOrNotExist(item[valueField || 'value'])
                    ? null
                    : item;
        }).filter(function (a) { return a && !a.disabled; });
        return flattendOptions;
    };
    TreeSelector.prototype.handleCheckAll = function (availableOptions, checkedAll) {
        var _this = this;
        this.setState({
            value: checkedAll ? [] : availableOptions
        }, function () { return _this.fireChange(checkedAll ? [] : availableOptions); });
    };
    TreeSelector.prototype.handleToggle = function (bool) {
        var _this = this;
        var availableOptions = this.getAvailableOptions();
        if (bool === undefined) {
            var checkedAll = availableOptions.every(function (option) {
                return _this.isItemChecked(option);
            });
            this.handleCheckAll(availableOptions, checkedAll);
            return;
        }
        this.handleCheckAll(availableOptions, bool);
    };
    TreeSelector.prototype.renderCheckAll = function () {
        var _this = this;
        var _a = this.props, multiple = _a.multiple, checkAll = _a.checkAll, checkAllLabel = _a.checkAllLabel, cx = _a.classnames, __ = _a.translate, disabled = _a.disabled, mobileUI = _a.mobileUI;
        if (!multiple || !checkAll) {
            return null;
        }
        var availableOptions = this.getAvailableOptions();
        var checkedAll = availableOptions.every(function (option) {
            return _this.isItemChecked(option);
        });
        var checkedPartial = availableOptions.some(function (option) {
            return _this.isItemChecked(option);
        });
        return (_J$X_("div", { className: cx('Tree-itemLabel'), onClick: function () { return _this.handleCheckAll(availableOptions, checkedAll); } },
            _J$X_(Checkbox["default"], { size: "sm", disabled: disabled, checked: checkedPartial, partial: checkedPartial && !checkedAll }),
            _J$X_("div", { className: cx('Tree-itemLabel-item', {
                    'is-mobile': mobileUI
                }) },
                _J$X_("span", { className: cx('Tree-itemText') }, __(checkAllLabel)))));
    };
    TreeSelector.prototype.styleGetter = function (node) {
        node && this.setState({ itemHeight: (node === null || node === void 0 ? void 0 : node.offsetHeight) || 0 });
    };
    TreeSelector.prototype.renderList = function (list) {
        var _this = this;
        var virtualThreshold = this.props.virtualThreshold;
        var _a = this.state, virtualHeight = _a.virtualHeight, itemHeight = _a.itemHeight;
        if (virtualThreshold && list.length > virtualThreshold) {
            return itemHeight ? (_J$X_("div", { ref: this.virtualListRefSetter },
                _J$X_(index["default"], { height: virtualHeight, itemCount: list.length, prefix: this.renderCheckAll(), itemSize: itemHeight, renderItem: this.renderItem }))) : (this.renderItem({ index: 0, ref: this.styleGetter }));
        }
        return (_J$X_(React__default["default"].Fragment, null,
            this.renderCheckAll(),
            list.map(function (item, index) { return _this.renderItem({ index: index }); })));
    };
    TreeSelector.prototype.handleVirtualHeight = function () {
        var _a;
        var virtualThreshold = this.props.virtualThreshold;
        var _b = this.state, flattenedOptions = _b.flattenedOptions, itemHeight = _b.itemHeight;
        if (virtualThreshold && flattenedOptions.length > virtualThreshold) {
            // tree 对应元素
            var treeElement = this.root.current;
            if (!this.virtualListRef ||
                (!treeElement.offsetHeight && !treeElement.offsetWidth)) {
                return;
            }
            treeElement =
                ((_a = treeElement === null || treeElement === void 0 ? void 0 : treeElement.parentElement) === null || _a === void 0 ? void 0 : _a.matches('.cxd-TreeControl')) &&
                    treeElement.parentElement.childElementCount === 1
                    ? treeElement.parentElement
                    : treeElement;
            var styles = getComputedStyle(treeElement);
            var offsetHeight = 0;
            if (styles.flexGrow !== '0') {
                // 当配置了成了动态高度时，根据实际高度来
                offsetHeight = treeElement.offsetHeight;
            }
            else {
                offsetHeight =
                    itemHeight * Math.min(flattenedOptions.length, virtualThreshold);
            }
            var virtualElement = this.virtualListRef;
            // 通常时外围设置了 maxHeight
            if (virtualElement.offsetHeight &&
                virtualElement.offsetHeight > treeElement.offsetHeight) {
                offsetHeight = treeElement.offsetHeight;
            }
            // 虚拟列表 对应元素
            // todo 去支持外部滚动也支持虚拟滚动的场景，目前不支持，所以只能让高度最大，其实就没启动虚拟滚动
            // 目前只有没有配置  heightAuto 的时候
            // 或者配置了 flexGrow 的时候，才会有虚拟滚动的效果
            var virtualHeight = offsetHeight - amisCore.calculateHeight(treeElement, virtualElement);
            this.setState({ virtualHeight: virtualHeight });
        }
    };
    TreeSelector.prototype.render = function () {
        var _a = this.props, className = _a.className, placeholder = _a.placeholder, hideRoot = _a.hideRoot, rootLabel = _a.rootLabel, showOutline = _a.showOutline, showIcon = _a.showIcon, cx = _a.classnames, creatable = _a.creatable, rootCreatable = _a.rootCreatable, rootCreateTip = _a.rootCreateTip, disabled = _a.disabled, draggable = _a.draggable, __ = _a.translate, testIdBuilder = _a.testIdBuilder, actionClassName = _a.actionClassName, height = _a.height;
        var _b = this.state, value = _b.value, isAdding = _b.isAdding, addingParent = _b.addingParent, isEditing = _b.isEditing, dropIndicator = _b.dropIndicator, flattenedOptions = _b.flattenedOptions;
        var addBtn = null;
        if (creatable && rootCreatable !== false && hideRoot) {
            addBtn = (_J$X_("a", tslib.__assign({ className: cx('Tree-addTopBtn', {
                    'is-disabled': isAdding || isEditing
                }), onClick: this.handleAdd.bind(this, null) }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('add').getTestId()),
                _J$X_(icons.Icon, { icon: "plus", className: "icon" }),
                _J$X_("span", null, __(rootCreateTip))));
        }
        var style = {};
        if (height && height > 0) {
            style = {
                height: "".concat(height, "px"),
                maxHeight: 'none'
            };
        }
        return (_J$X_("div", tslib.__assign({ className: cx("Tree ".concat(className || ''), {
                'Tree--outline': showOutline,
                'is-disabled': disabled,
                'is-draggable': draggable
            }), style: style, ref: this.root }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getTestId()),
            (flattenedOptions && flattenedOptions.length) ||
                addBtn ||
                hideRoot === false ? (_J$X_("ul", { className: cx('Tree-list') }, hideRoot ? (_J$X_(React__default["default"].Fragment, null,
                addBtn,
                isAdding && !addingParent ? (_J$X_("li", { className: cx('Tree-item') }, this.renderInput())) : null,
                this.renderList(flattenedOptions))) : (_J$X_("li", { className: cx('Tree-rootItem', {
                    'is-checked': !value || !value.length
                }) },
                _J$X_("div", { className: cx('Tree-itemLabel') },
                    _J$X_("span", tslib.__assign({ className: cx('Tree-itemText'), onClick: this.clearSelect }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild("root-item").getTestId()),
                        showIcon ? (_J$X_("i", { className: cx('Tree-itemIcon Tree-rootIcon') },
                            _J$X_(icons.Icon, { icon: "home", className: "icon" }))) : null,
                        rootLabel),
                    !disabled &&
                        creatable &&
                        rootCreatable !== false &&
                        !isAdding &&
                        !isEditing ? (_J$X_("div", { className: cx('Tree-item-icons', actionClassName) }, creatable ? (_J$X_("a", tslib.__assign({ onClick: this.handleAdd.bind(this, null), "data-tooltip": rootCreateTip, "data-position": "left" }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild("root-add").getTestId()),
                        _J$X_(icons.Icon, { icon: "plus", className: "icon" }))) : null)) : null),
                _J$X_("ul", { className: cx('Tree-sublist') },
                    isAdding && !addingParent ? (_J$X_("li", { className: cx('Tree-item') }, this.renderInput())) : null,
                    this.renderList(flattenedOptions)))))) : (_J$X_("div", { className: cx('Tree-placeholder') }, placeholder)),
            dropIndicator && (_J$X_("div", { className: cx('Tree-dropIndicator', {
                    'Tree-dropIndicator--hover': !!dropIndicator.height
                }), style: dropIndicator }))));
    };
    TreeSelector.defaultProps = {
        showIcon: true,
        showOutline: false,
        initiallyOpen: true,
        unfoldedLevel: 1,
        showRadio: false,
        multiple: false,
        disabled: false,
        withChildren: false,
        onlyChildren: false,
        labelField: 'label',
        valueField: 'value',
        iconField: 'icon',
        deferField: 'defer',
        unfoldedField: 'unfolded',
        foldedField: 'foled',
        disabledField: 'disabled',
        joinValues: true,
        extractValue: false,
        delimiter: ',',
        hideRoot: true,
        rootLabel: 'Tree.root',
        rootValue: 0,
        autoCheckChildren: true,
        autoCancelParent: false,
        cascade: false,
        selfDisabledAffectChildren: true,
        rootCreateTip: 'Tree.addRoot',
        createTip: 'Tree.addChild',
        editTip: 'Tree.editNode',
        removeTip: 'Tree.removeNode',
        enableNodePath: false,
        pathSeparator: '/',
        nodePath: [],
        virtualThreshold: 100,
        enableDefaultIcon: true
    };
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "virtualListRefSetter", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "toggleUnfolded", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "clearSelect", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleSelect", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleItemClick", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCheck", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleAdd", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleEdit", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleRemove", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleInputChange", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleConfirm", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCancel", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", Object)
    ], TreeSelector.prototype, "getDropInfo", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "updateDropIndicator", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragStart", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragOver", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "onDragEnd", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "renderItem", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Array, Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleCheckAll", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Boolean]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleToggle", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "styleGetter", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "renderList", null);
    tslib.__decorate([
        amisCore.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], TreeSelector.prototype, "handleVirtualHeight", null);
    return TreeSelector;
}(React__default["default"].Component));
var Tree = amisCore.themeable(amisCore.localeable(TreeSelector));

exports.TreeSelector = TreeSelector;
exports["default"] = Tree;
