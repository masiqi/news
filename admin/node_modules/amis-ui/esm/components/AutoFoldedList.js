/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

import { __read, __assign } from 'tslib';
import React__default, { useState, useRef, useEffect } from 'react';
import { themeable, resizeSensor } from 'amis-core';
import TooltipWrapper from './TooltipWrapper.js';

/**
 * AutoFoldedList Component
 *
 * A component that automatically folds list items when there are too many to display.
 * When clicked, it expands to show all items.
 *
 * @component
 */
var AutoFoldedList = function (props) {
    var items = props.items, renderItem = props.renderItem, renderMoreSummary = props.renderMoreSummary, renderTooltipContent = props.renderTooltipContent, _a = props.enabled, enabled = _a === void 0 ? true : _a, cx = props.classnames, popOverContainer = props.popOverContainer, tooltipClassName = props.tooltipClassName, tooltipOptions = props.tooltipOptions, maxVisibleCount = props.maxVisibleCount;
    // State to track number of visible items
    var _b = __read(useState(0), 2), visibleCount = _b[0], setVisibleCount = _b[1];
    // Refs for container and "more" elements
    var moreRef = useRef(null);
    var _c = __read(React__default.useMemo(function () {
        return [
            visibleCount && enabled ? items.slice(0, visibleCount) : items,
            visibleCount && enabled ? items.slice(visibleCount) : []
        ];
    }, [items, visibleCount, enabled]), 2), visibleItems = _c[0], restItems = _c[1];
    /**
     * Renders a single list item with proper key
     */
    var itemRender = React__default.useCallback(function (item, index, folded) {
        var dom = renderItem(item, index, folded);
        if (React__default.isValidElement(dom)) {
            return React__default.cloneElement(dom, {
                key: index
            });
        }
        return React__default.createElement("div", { key: index }, dom);
    }, [renderItem]);
    /**
     * Effect to calculate and update visible items count based on container width
     */
    useEffect(function () {
        if (!enabled) {
            return;
        }
        var more = moreRef.current;
        var container = more.parentElement;
        var moreWidth = Math.max(more.offsetWidth, 30);
        var gap = 10;
        var lastExtendAt = 0;
        var calculateVisibleCount = function () {
            var rect = container.getBoundingClientRect();
            if (!rect.width) {
                return;
            }
            var list = Array.from(container.children).filter(function (item) { return !item.hasAttribute('data-folder-ignore'); });
            var rightElementsWidth = 0;
            var rightElement = more.nextElementSibling;
            while (rightElement) {
                rightElementsWidth += rightElement.offsetWidth;
                rightElement = rightElement.nextElementSibling;
            }
            var last = more.previousElementSibling;
            while (last) {
                if (last.getBoundingClientRect().right +
                    moreWidth +
                    gap +
                    rightElementsWidth <
                    rect.right) {
                    break;
                }
                last = last.previousElementSibling;
            }
            if (last &&
                last === more.previousElementSibling &&
                Date.now() - lastExtendAt > 200 // Prevent flickering
            ) {
                // Expand to show more items
                var width = last.offsetWidth;
                lastExtendAt = Date.now();
                var extend = Math.max(Math.floor((rect.right -
                    last.getBoundingClientRect().right -
                    moreWidth -
                    gap) /
                    width), 0);
                setVisibleCount(Math.min(list.indexOf(last) + 1 + extend, maxVisibleCount !== null && maxVisibleCount !== void 0 ? maxVisibleCount : items.length));
            }
            else if (last) {
                // Collapse to show fewer items
                setVisibleCount(list.indexOf(last) + 1);
            }
        };
        calculateVisibleCount();
        return resizeSensor(container, calculateVisibleCount, false, 'both', true);
    }, [items, maxVisibleCount, enabled]);
    React__default.useLayoutEffect(function () {
        var _a;
        if (!enabled) {
            return;
        }
        (_a = moreRef.current.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add(cx('AutoFoldedList'));
        return function () {
            var _a;
            (_a = moreRef.current.parentElement) === null || _a === void 0 ? void 0 : _a.classList.remove(cx('AutoFoldedList'));
        };
    }, [enabled]);
    return (React__default.createElement(React__default.Fragment, null,
        visibleItems.map(function (item, index) { return itemRender(item, index, false); }),
        React__default.createElement("div", { className: cx('AutoFoldedList-more'), ref: moreRef }, restItems.length > 0 ? (React__default.createElement(TooltipWrapper, { container: popOverContainer, tooltip: __assign(__assign({ placement: 'auto', trigger: 'hover', showArrow: false }, tooltipOptions), { children: function () { return (React__default.createElement("div", { className: cx('AutoFoldedList-more-tooltip', tooltipClassName) }, renderTooltipContent
                    ? renderTooltipContent(restItems)
                    : restItems.map(function (item, index) {
                        return itemRender(item, index + visibleCount, true);
                    }))); } }) }, renderMoreSummary ? (renderMoreSummary(restItems)) : (React__default.createElement("span", null,
            "+ ",
            restItems.length,
            " ...")))) : null)));
};
var AutoFoldedList$1 = themeable(AutoFoldedList);

export { AutoFoldedList, AutoFoldedList$1 as default };
