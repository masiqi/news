/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

import { __extends, __spreadArray, __read, __awaiter, __generator, __assign, __decorate, __metadata } from 'tslib';
import React__default from 'react';
import { findDOMNode } from 'react-dom';
import find from 'lodash/find';
import isEqual from 'lodash/isEqual';
import debounce from 'lodash/debounce';
import intersection from 'lodash/intersection';
import Sortable from 'sortablejs';
import { resizeSensor, offset, getScrollParent, position, getStyleNumber, isObject, filterTree, autobind, themeable, localeable } from 'amis-core';
import Spinner from '../Spinner.js';
import ItemActionsWrapper from './ItemActionsWrapper.js';
import BodyCell from './Cell.js';
import ColGroup from './ColGroup.js';
import LazyRow from './Row.js';
import Head from './Head.js';
import SummaryRows from './SummaryRow.js';
import { getRowsByKeys, levelsSplit, getDataChildrenKeys, checkChildrenRow, getSortData, getBuildColumns } from './util.js';

/**
 * @file Table
 * @author fex
 */
var DefaultCellWidth = 40;
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table(props) {
        var _this = _super.call(this, props) || this;
        _this.tableDom = React__default.createRef();
        _this.tbodyDom = React__default.createRef();
        _this.contentDom = React__default.createRef();
        _this.headerDom = React__default.createRef();
        _this.footDom = React__default.createRef();
        _this.containerDom = React__default.createRef();
        _this.toDispose = [];
        _this.updateTableInfoLazy = debounce(_this.updateTableInfo.bind(_this), 250, {
            trailing: true,
            leading: false
        });
        _this.updateAutoFillHeightLazy = debounce(_this.updateAutoFillHeight.bind(_this), 250, {
            trailing: true,
            leading: false
        });
        _this.state = {
            selectedRowKeys: props.rowSelection
                ? props.rowSelection.selectedRowKeys.map(function (key) { return key; }) || []
                : [],
            expandedRowKeys: __spreadArray(__spreadArray([], __read((props.expandable ? props.expandable.expandedRowKeys || [] : [])), false), __read((props.expandable
                ? props.expandable.defaultExpandedRowKeys || []
                : [])), false),
            colWidths: {},
            hoverRow: null
        };
        return _this;
    }
    Table.prototype.getPopOverContainer = function () {
        return findDOMNode(this);
    };
    Table.prototype.componentDidMount = function () {
        var _this = this;
        var _a, _b, _c, _d, _e;
        (_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.onRef) === null || _b === void 0 ? void 0 : _b.call(_a, this);
        if (this.props.loading) {
            return;
        }
        if ((_c = this.headerDom) === null || _c === void 0 ? void 0 : _c.current) {
            // overflow设置为hidden的情况
            var hiddenDomRefs = [this.headerDom, this.footDom];
            hiddenDomRefs.forEach(function (ref) {
                return ref &&
                    ref.current &&
                    ref.current.addEventListener('wheel', _this.onWheel.bind(_this));
            });
        }
        var current = (_d = this.contentDom) === null || _d === void 0 ? void 0 : _d.current;
        current && this.updateTableDom(current);
        if (this.props.draggable && ((_e = this.tbodyDom) === null || _e === void 0 ? void 0 : _e.current)) {
            this.initDragging();
        }
        this.updateStickyHeader();
        var currentNode = findDOMNode(this);
        if (this.props.autoFillHeight) {
            this.toDispose.push(resizeSensor(currentNode.parentElement, this.updateAutoFillHeightLazy, false, 'height'));
            this.updateAutoFillHeight();
        }
        this.toDispose.push(resizeSensor(currentNode, this.updateTableInfoLazy, false, 'width'));
    };
    Table.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _a, _b, _c, _d;
        if (prevProps.autoFillHeight !== this.props.autoFillHeight ||
            (prevProps.loading !== this.props.loading && this.props.autoFillHeight)) {
            this.updateAutoFillHeight();
        }
        // 选择项发生了变化触发
        if (!isEqual(prevState.selectedRowKeys, this.state.selectedRowKeys)) {
            var rowSelectionKeyField = this.getRowSelectionKeyField();
            var childrenColumnName = this.getChildrenColumnName();
            // 更新保存的已选择行数据
            var selectedResult = getRowsByKeys(this.props.dataSource, this.state.selectedRowKeys, rowSelectionKeyField, childrenColumnName);
            var rowSelection = this.props.rowSelection;
            rowSelection &&
                rowSelection.onChange &&
                rowSelection.onChange(this.state.selectedRowKeys, selectedResult.selectedRows);
        }
        // 外部传入的选择项发生了变化
        if (!isEqual((_a = prevProps.rowSelection) === null || _a === void 0 ? void 0 : _a.selectedRowKeys, (_b = this.props.rowSelection) === null || _b === void 0 ? void 0 : _b.selectedRowKeys)) {
            if (this.props.rowSelection) {
                this.setState({
                    selectedRowKeys: this.props.rowSelection.selectedRowKeys
                });
            }
        }
        // 外部传入的展开项发生了变化
        if (!isEqual((_c = prevProps === null || prevProps === void 0 ? void 0 : prevProps.expandable) === null || _c === void 0 ? void 0 : _c.expandedRowKeys, (_d = this.props.expandable) === null || _d === void 0 ? void 0 : _d.expandedRowKeys)) {
            if (this.props.expandable) {
                this.setState({
                    expandedRowKeys: this.props.expandable.expandedRowKeys || []
                });
            }
        }
        // 展开行变化时触发
        if (!isEqual(prevState.expandedRowKeys, this.state.expandedRowKeys)) {
            if (this.props.expandable) {
                var childrenColumnName = this.getChildrenColumnName();
                var expandableKeyField = this.getExpandableKeyField();
                var onExpandedRowsChange = this.props.expandable.onExpandedRowsChange;
                var expandedResult = getRowsByKeys(this.props.dataSource, this.state.selectedRowKeys, expandableKeyField, childrenColumnName);
                onExpandedRowsChange &&
                    onExpandedRowsChange(expandedResult.selectedRows);
            }
        }
        // sticky属性发生了变化
        if (prevProps.sticky !== this.props.sticky) {
            this.updateStickyHeader();
        }
        if (prevProps.columns !== this.props.columns) {
            this.syncTableWidth();
        }
    };
    Table.prototype.componentWillUnmount = function () {
        var _this = this;
        var hiddenDomRefs = [this.headerDom, this.footDom];
        hiddenDomRefs.forEach(function (ref) {
            return ref &&
                ref.current &&
                ref.current.removeEventListener('wheel', _this.onWheel.bind(_this));
        });
        this.destroyDragging();
        this.toDispose.forEach(function (fn) { return fn(); });
        this.toDispose = [];
        this.updateTableInfoLazy.cancel();
        this.updateAutoFillHeightLazy.cancel();
    };
    /**
     * 自动设置表格高度占满界面剩余区域
     * 用 css 实现有点麻烦，要改很多结构，所以先用 dom hack 了，避免对之前的功能有影响
     */
    Table.prototype.updateAutoFillHeight = function () {
        var tableContent = this.containerDom.current;
        if (!tableContent) {
            return;
        }
        tableContent.removeAttribute('style');
        var autoFillHeight = this.props.autoFillHeight;
        if (!autoFillHeight) {
            return;
        }
        // 计算 table-content 在 dom 中的位置
        var viewportHeight = window.innerHeight;
        var tableContentTop = offset(tableContent).top;
        var parent = getScrollParent(tableContent.parentElement);
        if (parent && parent !== document.body) {
            viewportHeight = parent.clientHeight - 1;
            tableContentTop = position(tableContent, parent).top;
        }
        var tableContentBottom = 0;
        var selfNode = tableContent;
        var parentNode = selfNode.parentElement;
        while (parentNode) {
            var paddingBottom = getStyleNumber(parentNode, 'padding-bottom');
            var borderBottom = getStyleNumber(parentNode, 'border-bottom-width');
            var nextSiblingHeight = 0;
            var nextSibling = selfNode.nextElementSibling;
            while (nextSibling) {
                var positon = getComputedStyle(nextSibling).position;
                if (positon !== 'absolute' && positon !== 'fixed') {
                    nextSiblingHeight +=
                        nextSibling.offsetHeight +
                            getStyleNumber(nextSibling, 'margin-bottom');
                }
                nextSibling = nextSibling.nextElementSibling;
            }
            var marginBottom = getStyleNumber(selfNode, 'margin-bottom');
            tableContentBottom +=
                paddingBottom + borderBottom + marginBottom + nextSiblingHeight;
            selfNode = parentNode;
            parentNode = selfNode.parentElement;
            if (parent && parent !== document.body && parent === selfNode) {
                break;
            }
        }
        var heightField = autoFillHeight && autoFillHeight.maxHeight
            ? 'maxHeight'
            : 'height';
        var heightValue = isObject(autoFillHeight)
            ? autoFillHeight[heightField]
            : 0;
        var tableContentHeight = heightValue
            ? heightValue
            : Math.round(viewportHeight - tableContentTop - tableContentBottom);
        if (tableContentHeight > 0) {
            tableContent.style[heightField] = "".concat(tableContentHeight, "px");
            tableContent.style['overflow'] = 'auto';
        }
    };
    Table.prototype.initDragging = function () {
        var _this = this;
        var _a;
        var _b = this.props, cx = _b.classnames, onDrag = _b.onDrag;
        this.sortable = new Sortable((_a = this.tbodyDom) === null || _a === void 0 ? void 0 : _a.current, {
            group: 'table',
            animation: 150,
            handle: ".".concat(cx('Table-dragCell')),
            ghostClass: 'is-dragging',
            onMove: function (e) {
                var dragged = e.dragged;
                var related = e.related;
                if (related &&
                    related.classList.contains("".concat(cx('Table-summary-row')))) {
                    return false;
                }
                var draggedLevels = dragged.getAttribute('row-levels');
                var relatedLevels = related.getAttribute('row-levels');
                // 嵌套展示 不属于同一层的 不允许拖动
                // 否则涉及到试图的更新，比如子元素都被拖完了
                if (draggedLevels !== relatedLevels) {
                    return false;
                }
                return true;
            },
            onEnd: function (e) { return __awaiter(_this, void 0, void 0, function () {
                var oldIndex, newIndex, rowLevels, i;
                return __generator(this, function (_a) {
                    // 没有移动
                    if (e.newIndex === e.oldIndex) {
                        return [2 /*return*/];
                    }
                    oldIndex = e.oldIndex;
                    newIndex = e.newIndex;
                    rowLevels = levelsSplit(e.item.getAttribute('row-levels'));
                    if (rowLevels.length) {
                        i = 0;
                        while (i < rowLevels.length) {
                            oldIndex = oldIndex - rowLevels[i] - 1;
                            newIndex = newIndex - rowLevels[i] - 1;
                            i++;
                        }
                    }
                    onDrag && onDrag(oldIndex, newIndex, rowLevels);
                    return [2 /*return*/];
                });
            }); }
        });
    };
    Table.prototype.destroyDragging = function () {
        this.sortable && this.sortable.destroy();
        this.sortable = null;
    };
    Table.prototype.updateStickyHeader = function () {
        var _this = this;
        var _a, _b;
        if (this.props.sticky) {
            // 如果设置了sticky 如果父元素设置了overflow: auto top值还需要考虑padding值
            var parent_1 = (_b = (_a = this.headerDom) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.parentElement;
            setTimeout(function () {
                while (parent_1 &&
                    window.getComputedStyle(parent_1, null).getPropertyValue('overflow') !==
                        'auto') {
                    parent_1 = parent_1.parentElement;
                }
                if (parent_1 &&
                    window.getComputedStyle(parent_1, null).getPropertyValue('overflow') ===
                        'auto') {
                    var paddingTop = window
                        .getComputedStyle(parent_1, null)
                        .getPropertyValue('padding-top');
                    if (paddingTop && _this.headerDom && _this.headerDom.current) {
                        _this.headerDom.current.style.top = '-' + paddingTop;
                    }
                }
            });
        }
    };
    Table.prototype.renderColGroup = function (showReal) {
        var _a = this.props, scroll = _a.scroll, tableLayout = _a.tableLayout, columns = _a.columns, rowSelection = _a.rowSelection, expandable = _a.expandable, draggable = _a.draggable;
        var isFixed = !!((scroll && scroll.x) || tableLayout === 'fixed');
        return (React__default.createElement(ColGroup, { columns: columns, colWidths: this.state.colWidths, isFixed: isFixed, syncTableWidth: this.syncTableWidth, initTableWidth: this.initTableWidth, selectable: !!rowSelection, expandable: !!expandable, draggable: !!draggable, rowSelectionColumnWidth: (rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.columnWidth) || DefaultCellWidth, expandableColumnWidth: (expandable === null || expandable === void 0 ? void 0 : expandable.columnWidth) || DefaultCellWidth, isRightExpandable: this.isRightExpandable(), isLeftExpandable: this.isLeftExpandable(), showReal: showReal }));
    };
    Table.prototype.onResizeMouseDown = function (event, index) {
        // 点击记录起始坐标
        this.resizeStart = event.clientX;
        this.resizeTarget = event.currentTarget;
        var column = this.tdColumns[index];
        this.resizeIndex = index;
        var colWidth = this.state.colWidths[column.name];
        this.resizeWidth = colWidth.width || colWidth.realWidth;
        this.resizeTarget.classList.add('is-resizing');
        document.addEventListener('mousemove', this.onResizeMouseMove);
        document.addEventListener('mouseup', this.onResizeMouseUp);
        event && event.stopPropagation();
    };
    Table.prototype.onResizeMouseMove = function (event) {
        // 点击了调整列宽
        if (this.resizeTarget) {
            // 计算横向移动距离
            var distance = event.clientX - this.resizeStart;
            var column = this.tdColumns[this.resizeIndex];
            var newWidth = 0;
            if (distance > 0) {
                newWidth = this.resizeWidth + distance;
            }
            else {
                // 缩短列
                newWidth = Math.max(this.resizeWidth + distance, DefaultCellWidth, column.minWidth || 0);
            }
            var colWidths = this.state.colWidths;
            colWidths[column.name].width = newWidth;
            this.setState({ colWidths: __assign({}, colWidths) });
        }
        event && event.stopPropagation();
    };
    Table.prototype.onResizeMouseUp = function (event) {
        this.resizeTarget.classList.remove('is-resizing');
        document.removeEventListener('mousemove', this.onResizeMouseMove);
        document.removeEventListener('mouseup', this.onResizeMouseUp);
        this.resizeStart = -1;
        this.resizeWidth = 0;
        delete this.resizeTarget;
    };
    Table.prototype.renderHead = function () {
        var _this = this;
        var _a;
        var _b = this.props, columns = _b.columns, cx = _b.classnames, classPrefix = _b.classPrefix, expandable = _b.expandable, rowSelection = _b.rowSelection, draggable = _b.draggable, resizable = _b.resizable, dataSource = _b.dataSource, onSort = _b.onSort, onSelectAll = _b.onSelectAll, onFilter = _b.onFilter, testIdBuilder = _b.testIdBuilder, headerClassName = _b.headerClassName, sticky = _b.sticky, autoFillHeight = _b.autoFillHeight, scroll = _b.scroll;
        var rowSelectionKeyField = this.getRowSelectionKeyField();
        var dataList = rowSelection && rowSelection.getCheckboxProps
            ? filterTree(dataSource, function (data, index, level) {
                var props = rowSelection.getCheckboxProps(data, index);
                return !props.disabled;
            })
            : dataSource;
        var hasScrollY = scroll && scroll.y;
        var selfSticky = !!(hasScrollY || (sticky && autoFillHeight));
        return (React__default.createElement(Head, { key: "thead", selfSticky: selfSticky, columns: columns, draggable: !!draggable, selectable: !!rowSelection, rowSelectionFixed: !!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.fixed), rowSelectionType: rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.type, selections: rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.selections, rowSelectionKeyField: rowSelectionKeyField, maxSelectedLength: rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.maxSelectedLength, isExpandable: this.isExpandableTable(), isRightExpandable: this.isRightExpandable(), isLeftExpandable: this.isLeftExpandable(), selectedRowKeys: this.state.selectedRowKeys, dataSource: dataList, resizable: resizable, expandable: !!expandable, expandableFixed: expandable === null || expandable === void 0 ? void 0 : expandable.fixed, childrenColumnName: this.getChildrenColumnName(), orderBy: (_a = this.state.sort) === null || _a === void 0 ? void 0 : _a.orderBy, popOverContainer: this.getPopOverContainer, classnames: cx, className: headerClassName, classPrefix: classPrefix, onSort: function (payload, column) {
                _this.setState({
                    sort: payload
                });
                onSort && onSort(payload);
            }, onSelectAll: function (value, selectedRowKeys, selectedRows, restSelectedKeys) { return __awaiter(_this, void 0, void 0, function () {
                var prevented, keys;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!onSelectAll) return [3 /*break*/, 2];
                            return [4 /*yield*/, onSelectAll(selectedRows, value ? selectedRowKeys : [], value ? [] : selectedRows)];
                        case 1:
                            prevented = _a.sent();
                            if (prevented) {
                                return [2 /*return*/];
                            }
                            _a.label = 2;
                        case 2:
                            keys = __spreadArray(__spreadArray([], __read(selectedRowKeys), false), __read(restSelectedKeys // 更新数据要把非当前页的数据也加上
                            ), false);
                            if (!isEqual(keys, this.state.selectedRowKeys)) {
                                this.setState({ selectedRowKeys: keys });
                            }
                            return [2 /*return*/];
                    }
                });
            }); }, onFilter: onFilter, onResizeMouseDown: this.onResizeMouseDown.bind(this), testIdBuilder: testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('head') }));
    };
    Table.prototype.onRowClick = function (event, record, rowIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, rowSelection, onRow, prevented, defaultKey_1, isSelected;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, rowSelection = _a.rowSelection, onRow = _a.onRow;
                        if (!(onRow && onRow.onRowClick)) return [3 /*break*/, 2];
                        return [4 /*yield*/, onRow.onRowClick(event, record, rowIndex)];
                    case 1:
                        prevented = _b.sent();
                        if (prevented) {
                            return [2 /*return*/];
                        }
                        _b.label = 2;
                    case 2:
                        if (rowSelection && rowSelection.type && rowSelection.rowClick) {
                            defaultKey_1 = this.getRowSelectionKeyField();
                            isSelected = !!find(this.state.selectedRowKeys, function (key) { return key === record[defaultKey_1]; });
                            this.selectedSingleRow(!isSelected, record);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Table.prototype.onRowDbClick = function (event, record, rowIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var onRow, prevented;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        onRow = this.props.onRow;
                        if (!(onRow && onRow.onRowDbClick)) return [3 /*break*/, 2];
                        return [4 /*yield*/, onRow.onRowDbClick(event, record, rowIndex)];
                    case 1:
                        prevented = _a.sent();
                        if (prevented === false) {
                            return [2 /*return*/];
                        }
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    Table.prototype.onRowMouseEnter = function (event, record, rowIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, onRow, itemActions, prevented, target;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, onRow = _a.onRow, itemActions = _a.itemActions;
                        if (!(onRow && onRow.onRowMouseEnter)) return [3 /*break*/, 2];
                        return [4 /*yield*/, onRow.onRowMouseEnter(event, record, rowIndex)];
                    case 1:
                        prevented = _b.sent();
                        if (prevented) {
                            return [2 /*return*/];
                        }
                        _b.label = 2;
                    case 2:
                        if (record && itemActions) {
                            target = event.target;
                            if ((target === null || target === void 0 ? void 0 : target.tagName) !== 'TR') {
                                target = target === null || target === void 0 ? void 0 : target.closest('tr');
                            }
                            this.setState({ hoverRow: { target: target, rowIndex: rowIndex, record: record } });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Table.prototype.onRowMouseLeave = function (event, record, rowIndex) {
        return __awaiter(this, void 0, void 0, function () {
            var onRow;
            return __generator(this, function (_a) {
                onRow = this.props.onRow;
                onRow &&
                    onRow.onRowMouseLeave &&
                    onRow.onRowMouseLeave(event, record, rowIndex);
                return [2 /*return*/];
            });
        });
    };
    Table.prototype.onMouseLeave = function () {
        var itemActions = this.props.itemActions;
        itemActions && this.setState({ hoverRow: null });
    };
    Table.prototype.onExpandRows = function (data) {
        var _this = this;
        var expandedRowKeys = this.state.expandedRowKeys;
        var expandable = this.props.expandable;
        var keys = data.map(function (d) { return d[_this.getExpandableKeyField()]; });
        this.setState({ expandedRowKeys: __spreadArray(__spreadArray([], __read(expandedRowKeys), false), __read(keys), false) });
        (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand) && (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand(true, data));
    };
    Table.prototype.onCollapseRows = function (data) {
        var _this = this;
        var expandedRowKeys = this.state.expandedRowKeys;
        var expandable = this.props.expandable;
        var keys = data.map(function (d) { return d[_this.getExpandableKeyField()]; });
        this.setState({
            expandedRowKeys: expandedRowKeys.filter(function (k) { return !keys.find(function (v) { return v == k; }); } // 模糊匹配 否则'3'、3匹配不上
            )
        });
        (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand) && (expandable === null || expandable === void 0 ? void 0 : expandable.onExpand(true, data));
    };
    Table.prototype.getChildrenColumnName = function () {
        var childrenColumnName = this.props.childrenColumnName;
        return childrenColumnName || 'children';
    };
    Table.prototype.getRowSelectionKeyField = function () {
        var _a = this.props, rowSelection = _a.rowSelection, keyField = _a.keyField;
        return (rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.keyField) || keyField || 'key';
    };
    Table.prototype.getExpandableKeyField = function () {
        var _a = this.props, expandable = _a.expandable, keyField = _a.keyField;
        return (expandable === null || expandable === void 0 ? void 0 : expandable.keyField) || keyField || 'key';
    };
    Table.prototype.hasCheckedChildrenRows = function (data) {
        var selectedRowKeys = this.state.selectedRowKeys;
        var childrenColumnName = this.getChildrenColumnName();
        var rowSelectionKeyField = this.getRowSelectionKeyField();
        var childrenKeys = getDataChildrenKeys(data, childrenColumnName, rowSelectionKeyField);
        var length = intersection(selectedRowKeys, childrenKeys).length;
        return length > 0;
    };
    Table.prototype.getSelectedRowKeys = function (isSelected, data) {
        var rowSelection = this.props.rowSelection;
        var rowSelectionKeyField = this.getRowSelectionKeyField();
        var childrenColumnName = this.getChildrenColumnName();
        var isRadio = rowSelection && rowSelection.type === 'radio';
        var selected = [];
        if (isSelected) {
            if (isRadio) {
                selected = [data[rowSelectionKeyField]];
            }
            else {
                selected = __spreadArray(__spreadArray(__spreadArray([], __read(this.state.selectedRowKeys), false), [
                    data[rowSelectionKeyField]
                ], false), __read(getDataChildrenKeys(data, childrenColumnName, rowSelectionKeyField)), false).filter(function (key, i, a) { return a.indexOf(key) === i; });
            }
        }
        else {
            if (!isRadio) {
                selected = this.state.selectedRowKeys.filter(function (key) {
                    return !__spreadArray([
                        data[rowSelectionKeyField]
                    ], __read(getDataChildrenKeys(data, childrenColumnName, rowSelectionKeyField)), false).includes(key);
                });
            }
        }
        return selected;
    };
    Table.prototype.selectedSingleRow = function (value, data) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, onSelect, dataSource, selectedRowKeys, rowSelectionKeyField, childrenColumnName, selectedResult, prevented;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, onSelect = _a.onSelect, dataSource = _a.dataSource;
                        selectedRowKeys = this.getSelectedRowKeys(value, data);
                        if (!onSelect) return [3 /*break*/, 2];
                        rowSelectionKeyField = this.getRowSelectionKeyField();
                        childrenColumnName = this.getChildrenColumnName();
                        selectedResult = getRowsByKeys(dataSource, selectedRowKeys, rowSelectionKeyField, childrenColumnName);
                        return [4 /*yield*/, onSelect(selectedResult.selectedRows, selectedRowKeys, selectedResult.unSelectedRows)];
                    case 1:
                        prevented = _b.sent();
                        if (prevented) {
                            return [2 /*return*/];
                        }
                        _b.label = 2;
                    case 2:
                        if (!isEqual(this.state.selectedRowKeys, selectedRowKeys)) {
                            this.setState({ selectedRowKeys: selectedRowKeys });
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // 展开和嵌套不能共存
    Table.prototype.isExpandableRow = function (data, rowIndex) {
        var expandable = this.props.expandable;
        return (expandable &&
            (!expandable.rowExpandable ||
                (expandable.rowExpandable && expandable.rowExpandable(data, rowIndex))));
    };
    Table.prototype.isExpanded = function (record) {
        var expandableKeyField = this.getExpandableKeyField();
        return !!find(this.state.expandedRowKeys, function (key) { return key == record[expandableKeyField]; }); // == 匹配 否则'3'、3匹配不上
    };
    Table.prototype.renderRow = function (data, rowIndex, levels) {
        var _this = this;
        var _a = this.props, rowSelection = _a.rowSelection, expandable = _a.expandable, indentSize = _a.indentSize, lineHeight = _a.lineHeight, draggable = _a.draggable, rowClassName = _a.rowClassName, keyField = _a.keyField, columns = _a.columns, lazyRenderAfter = _a.lazyRenderAfter, classPrefix = _a.classPrefix, cx = _a.classnames, testIdBuilder = _a.testIdBuilder;
        var rowSelectionKeyField = this.getRowSelectionKeyField();
        var isChecked = !!find(this.state.selectedRowKeys, function (key) { return key === data[rowSelectionKeyField]; });
        var rowTIDBuilder = testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild("row-".concat(rowIndex));
        var childrenColumnName = this.getChildrenColumnName();
        // 当前行是否可展开
        var isExpandableRow = this.isExpandableRow(data, rowIndex);
        var hasChildrenRow = checkChildrenRow(data, childrenColumnName);
        var hasChildrenChecked = !!rowSelection && hasChildrenRow && this.hasCheckedChildrenRows(data);
        var expandedRowClassName = expandable &&
            expandable.expandedRowClassName &&
            typeof expandable.expandedRowClassName === 'function'
            ? expandable.expandedRowClassName(data, rowIndex)
            : '';
        var isExpanded = this.isExpanded(data);
        var checkboxProps = rowSelection && rowSelection.getCheckboxProps
            ? rowSelection.getCheckboxProps(data, rowIndex)
            : {};
        var children = !expandable && childrenColumnName && hasChildrenRow && isExpanded
            ? data[childrenColumnName].map(function (item, index) {
                return _this.renderRow(item, index, __spreadArray(__spreadArray([], __read(levels), false), [rowIndex], false));
            })
            : null;
        return [
            React__default.createElement(LazyRow, __assign({ key: "row-".concat(rowIndex), data: data, rowIndex: rowIndex, levels: levels.join(','), columns: columns, selectable: !!rowSelection, rowSelectionFixed: !!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.fixed), rowSelectionType: (rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.type) || 'checkbox', rowClickIgControl: !!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.rowClickIgControl), expandable: !!expandable, expandableFixed: expandable === null || expandable === void 0 ? void 0 : expandable.fixed, expandedRowClassName: expandedRowClassName, expandedRowRender: expandable === null || expandable === void 0 ? void 0 : expandable.expandedRowRender, isExpanded: isExpanded, hasChildrenRow: hasChildrenRow, hasChildrenChecked: hasChildrenChecked, indentSize: indentSize, lineHeight: lineHeight, draggable: !!draggable, isExpandable: this.isExpandableTable(), isExpandableRow: isExpandableRow, colCount: this.getExtraColumnCount(), isRightExpandable: this.isRightExpandable(), isLeftExpandable: this.isLeftExpandable(), isChecked: isChecked, rowClassName: rowClassName, onExpand: this.onExpandRows, onCollapse: this.onCollapseRows, onMouseEnter: this.onRowMouseEnter, onMouseLeave: this.onRowMouseLeave, onClick: this.onRowClick, onDoubleClick: this.onRowDbClick, onChange: this.onRowChange, childrenColumnName: this.getChildrenColumnName(), keyField: keyField, lazyRenderAfter: lazyRenderAfter, classnames: cx, classPrefix: classPrefix, testIdBuilder: rowTIDBuilder }, checkboxProps)),
            children
        ];
    };
    Table.prototype.onRowChange = function (value, record) {
        var rowSelection = this.props.rowSelection;
        if (!(rowSelection && rowSelection.rowClick)) {
            this.selectedSingleRow(value, record);
        }
    };
    Table.prototype.renderBody = function () {
        var _this = this;
        var _a = this.props, cx = _a.classnames, headSummary = _a.headSummary, scroll = _a.scroll, placeholder = _a.placeholder, sticky = _a.sticky, loading = _a.loading, loadingConfig = _a.loadingConfig, classPrefix = _a.classPrefix;
        var tdColumns = this.tdColumns;
        var hasScrollY = scroll && scroll.y;
        var colCount = this.getExtraColumnCount();
        var childrenColumnName = this.getChildrenColumnName();
        var dataSource = getSortData(this.props.dataSource, tdColumns, childrenColumnName, this.state.sort);
        return (React__default.createElement("tbody", { ref: this.tbodyDom, className: cx('Table-tbody') },
            dataSource.map(function (data, index) { return _this.renderRow(data, index, []); }),
            !hasScrollY && !sticky && headSummary
                ? this.renderSummaryRow(headSummary)
                : null,
            !!loading ? (React__default.createElement("tr", { className: cx('Table-row', 'Table-loading-row') },
                React__default.createElement(BodyCell, { classnames: cx, classPrefix: classPrefix, colSpan: tdColumns.length + colCount },
                    React__default.createElement("div", { className: cx('Table-loading') }, typeof loading === 'boolean' ? (React__default.createElement(Spinner, { overlay: true, show: loading, loadingConfig: loadingConfig })) : React__default.isValidElement(loading) ? (loading) : null)))) : !dataSource.length ? (React__default.createElement("tr", { className: cx('Table-row', 'Table-empty-row') },
                React__default.createElement(BodyCell, { classnames: cx, classPrefix: classPrefix, colSpan: tdColumns.length + colCount },
                    React__default.createElement("div", { className: cx('Table-empty') }, typeof placeholder === 'function'
                        ? placeholder()
                        : placeholder)))) : null));
    };
    Table.prototype.isExpandableTable = function () {
        var expandable = this.props.expandable;
        // 设置了expandable 优先级更高
        // 就不支持默认嵌套了
        return !!expandable;
    };
    // 展开列放到右侧 会影响之前的一些合并的规则
    Table.prototype.isRightExpandable = function () {
        var expandable = this.props.expandable;
        return expandable && expandable.position === 'right';
    };
    // 展开列放到左侧 还有一种情况是position为none 无展开按钮
    Table.prototype.isLeftExpandable = function () {
        var expandable = this.props.expandable;
        return (expandable && (!expandable.position || expandable.position === 'left'));
    };
    // 计算自动增加的列数
    // 选择、拖拽、展开
    Table.prototype.getExtraColumnCount = function () {
        var _a = this.props, draggable = _a.draggable, rowSelection = _a.rowSelection, expandable = _a.expandable;
        var count = 0;
        if (draggable) {
            count++;
        }
        else {
            if (this.isExpandableTable() && (expandable === null || expandable === void 0 ? void 0 : expandable.position) !== 'none') {
                count++;
            }
            if (rowSelection) {
                count++;
            }
        }
        return count;
    };
    Table.prototype.renderSummaryRow = function (summary) {
        var _a = this.props, cx = _a.classnames, classPrefix = _a.classPrefix, dataSource = _a.dataSource;
        if (typeof summary === 'function') {
            return summary(dataSource);
        }
        if (React__default.isValidElement(summary)) {
            return summary;
        }
        return (React__default.createElement(SummaryRows, { summary: summary, colCount: this.getExtraColumnCount(), isRightExpandable: this.isRightExpandable(), classnames: cx, classPrefix: classPrefix, dataSource: dataSource, onMouseEnter: this.onRowMouseEnter, onMouseLeave: this.onRowMouseLeave }));
    };
    Table.prototype.renderFoot = function () {
        var _a = this.props, cx = _a.classnames, footSummary = _a.footSummary;
        return (React__default.createElement("tfoot", { className: cx('Table-summary') }, this.renderSummaryRow(footSummary)));
    };
    Table.prototype.updateTableDom = function (dom) {
        var cx = this.props.classnames;
        var scrollLeft = dom.scrollLeft, scrollWidth = dom.scrollWidth, offsetWidth = dom.offsetWidth;
        var table = this.tableDom.current;
        var leftCalss = cx('Table-ping-left');
        if (scrollLeft > 0) {
            table === null || table === void 0 ? void 0 : table.classList.add(leftCalss);
        }
        else {
            table === null || table === void 0 ? void 0 : table.classList.remove(leftCalss);
        }
        var rightClass = cx('Table-ping-right');
        if (scrollLeft + offsetWidth < scrollWidth) {
            table === null || table === void 0 ? void 0 : table.classList.add(rightClass);
        }
        else {
            table === null || table === void 0 ? void 0 : table.classList.remove(rightClass);
        }
    };
    Table.prototype.onTableContentScroll = function (event) {
        this.updateTableDom(event.target);
    };
    Table.prototype.onWheel = function (event) {
        var _a = event, currentTarget = _a.currentTarget, deltaX = _a.deltaX;
        if (deltaX) {
            this.onTableScroll({
                target: currentTarget,
                scrollLeft: currentTarget.scrollLeft + deltaX
            });
            event.preventDefault();
        }
    };
    Table.prototype.onTableScroll = function (event) {
        var scrollDomRefs = [this.headerDom, this.contentDom, this.footDom];
        var target = event.target, scrollLeft = event.scrollLeft;
        scrollDomRefs.forEach(function (ref) {
            var current = ref && ref.current;
            if (current && current !== target) {
                current.scrollLeft = scrollLeft || target.scrollLeft;
            }
        });
        this.updateTableDom(target);
    };
    Table.prototype.renderTable = function () {
        var _a = this.props, scroll = _a.scroll, footSummary = _a.footSummary, showHeader = _a.showHeader, itemActions = _a.itemActions, tableLayout = _a.tableLayout, cx = _a.classnames, bodyClassname = _a.bodyClassname;
        var hasScrollX = scroll && scroll.x;
        var hoverRow = this.state.hoverRow;
        var tableStyle = hasScrollX
            ? { width: scroll.x + 'px', tableLayout: 'fixed' }
            : {};
        return (React__default.createElement("div", { ref: this.contentDom, className: cx('Table-content'), style: hasScrollX ? { overflow: 'auto hidden' } : {}, onMouseLeave: this.onMouseLeave, onScroll: this.onTableContentScroll.bind(this) },
            itemActions && hoverRow ? (React__default.createElement(ItemActionsWrapper, { dom: hoverRow.target, classnames: cx }, typeof itemActions === 'function'
                ? itemActions(hoverRow.record, hoverRow.rowIndex)
                : null)) : null,
            React__default.createElement("table", { style: __assign(__assign({}, tableStyle), { tableLayout: tableLayout === 'fixed' ? 'fixed' : 'auto' }), className: cx('Table-table', bodyClassname) },
                this.renderColGroup(),
                showHeader ? this.renderHead() : null,
                this.renderBody(),
                footSummary ? this.renderFoot() : null)));
    };
    Table.prototype.renderScrollTableHeader = function () {
        var _a;
        var _b = this.props, scroll = _b.scroll, headSummary = _b.headSummary, sticky = _b.sticky, showHeader = _b.showHeader, cx = _b.classnames, headerClassName = _b.headerClassName;
        var style = { overflow: 'hidden' };
        if (!!sticky) {
            Object.assign(style, { top: 0 });
        }
        var tableStyle = {};
        if (scroll && (scroll.y || scroll.x)) {
            Object.assign(tableStyle, {
                width: scroll && scroll.x
                    ? typeof scroll.x === 'number'
                        ? scroll.x + 'px'
                        : scroll.x
                    : '100%'
            });
        }
        return (React__default.createElement("div", { ref: this.headerDom, className: cx('Table-header', (_a = {},
                _a[cx('Table-sticky-holder')] = !!sticky,
                _a), headerClassName), style: style },
            React__default.createElement("table", { className: cx('Table-table'), style: __assign(__assign({}, tableStyle), { tableLayout: 'fixed' }) },
                this.renderColGroup(true),
                showHeader ? this.renderHead() : null,
                headSummary ? (React__default.createElement("tbody", null, this.renderSummaryRow(headSummary))) : null)));
    };
    Table.prototype.renderScrollTableBody = function () {
        var _a = this.props, scroll = _a.scroll, itemActions = _a.itemActions, cx = _a.classnames, bodyClassname = _a.bodyClassname;
        var style = {};
        var tableStyle = {};
        if (scroll && (scroll.y || scroll.x)) {
            Object.assign(style, {
                overflow: 'auto scroll',
                maxHeight: scroll.y
            });
            Object.assign(tableStyle, {
                width: scroll && scroll.x
                    ? typeof scroll.x === 'number'
                        ? scroll.x + 'px'
                        : scroll.x
                    : '100%'
            });
        }
        var hoverRow = this.state.hoverRow;
        return (React__default.createElement("div", { ref: this.contentDom, className: cx('Table-body'), style: style, onMouseLeave: this.onMouseLeave, onScroll: this.onTableScroll },
            itemActions && hoverRow ? (React__default.createElement(ItemActionsWrapper, { dom: hoverRow.target, classnames: cx }, typeof itemActions === 'function'
                ? itemActions(hoverRow.record, hoverRow.rowIndex)
                : null)) : null,
            React__default.createElement("table", { className: cx('Table-table', bodyClassname), style: __assign(__assign({}, tableStyle), { tableLayout: 'fixed' }) },
                this.renderColGroup(),
                this.renderBody())));
    };
    Table.prototype.renderScrollTableFoot = function () {
        var _a = this.props, scroll = _a.scroll, cx = _a.classnames;
        return (React__default.createElement("div", { ref: this.footDom, className: cx('Table-summary'), style: { overflow: 'hidden' } },
            React__default.createElement("table", { className: cx('Table-table'), style: { width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) + 'px' || '100%', tableLayout: 'fixed' } }, this.renderFoot())));
    };
    Table.prototype.renderScrollTable = function () {
        // todo 这个模式有个很大的问题就是依赖 tablelayout 的 fixed 模式，这就意味这列的宽度都得配置
        var _a = this.props, footSummary = _a.footSummary, cx = _a.classnames;
        return (React__default.createElement("div", { className: cx('Table-container'), ref: this.containerDom },
            this.renderScrollTableHeader(),
            this.renderScrollTableBody(),
            footSummary ? this.renderScrollTableFoot() : null));
    };
    Table.prototype.syncTableWidth = function () {
        var _this = this;
        var tbodyDom = this.tbodyDom.current;
        if (!tbodyDom) {
            return;
        }
        var cols = [].slice.call(tbodyDom === null || tbodyDom === void 0 ? void 0 : tbodyDom.querySelectorAll(':scope>tr:last-child>td[data-col]'));
        var colWidths = {};
        cols.forEach(function (col) {
            var index = parseInt(col.getAttribute('data-col'), 10);
            var column = _this.tdColumns[index];
            var item = _this.state.colWidths[column.name];
            if (column) {
                colWidths[column.name] = {
                    width: (item === null || item === void 0 ? void 0 : item.originWidth) !== (column === null || column === void 0 ? void 0 : column.width) ? column === null || column === void 0 ? void 0 : column.width : item === null || item === void 0 ? void 0 : item.width,
                    minWidth: column === null || column === void 0 ? void 0 : column.minWidth,
                    realWidth: col.offsetWidth,
                    originWidth: column === null || column === void 0 ? void 0 : column.width
                };
            }
        });
        if (!isEqual(colWidths, this.state.colWidths)) {
            this.setState({ colWidths: colWidths });
        }
    };
    Table.prototype.initTableWidth = function () {
        var _this = this;
        var tableWrapperDom = this.contentDom.current;
        if (!tableWrapperDom) {
            return;
        }
        var _a = this.props, scroll = _a.scroll, tableLayout = _a.tableLayout;
        var table = tableWrapperDom.querySelector('table');
        var thead = tableWrapperDom.querySelector('thead');
        if (!thead) {
            if (this.headerDom.current) {
                thead = this.headerDom.current.querySelector('thead');
            }
        }
        var tableWidth = scroll && scroll.x ? scroll.x : tableWrapperDom.offsetWidth;
        var tbody = null;
        var htmls = [];
        var isFixed = tableLayout === 'fixed' || (scroll && scroll.x);
        var someSettedWidth = this.tdColumns.some(function (column) { return column.width; });
        var minWidths = {};
        // fixed 模式需要参考 auto 获得列最小宽度
        if (isFixed) {
            tbody = (table === null || table === void 0 ? void 0 : table.querySelector(':scope>tbody')) || null;
            htmls.push("<table style=\"table-layout:auto!important;width:0!important;min-width:0!important;\" class=\"".concat(table === null || table === void 0 ? void 0 : table.className, "\">").concat(thead === null || thead === void 0 ? void 0 : thead.outerHTML, "</table>"));
        }
        if (someSettedWidth || isFixed) {
            htmls.push("<table style=\"table-layout:auto!important;min-width:".concat(tableWidth, "px!important;width:").concat(tableWidth, "px!important;\" class=\"").concat(table === null || table === void 0 ? void 0 : table.className, "\">").concat(thead ? thead.outerHTML : '').concat(tbody ? "<tbody>".concat(tbody.innerHTML, "</tbody>") : '', "</table>"));
        }
        if (!htmls.length) {
            return;
        }
        var div = document.createElement('div');
        div.className = 'amis-scope'; // jssdk 里面 css 会在这一层
        div.style.cssText += "visibility: hidden!important;";
        div.innerHTML = htmls.join('');
        var ths1 = [];
        var ths2 = [];
        if (isFixed) {
            ths1 = [].slice.call(div.querySelectorAll(':scope>table:first-child>thead>tr>th[data-col]'));
        }
        if (someSettedWidth || isFixed) {
            ths2 = [].slice.call(div.querySelectorAll(':scope>table:last-child>thead>tr>th[data-col]'));
        }
        ths1.forEach(function (th) {
            th.style.cssText += 'width: 0';
        });
        ths2.forEach(function (th, index) {
            var column = _this.tdColumns[index];
            th.style.cssText += "".concat(typeof (column === null || column === void 0 ? void 0 : column.width) === 'number'
                ? "width: ".concat(column === null || column === void 0 ? void 0 : column.width, "px;")
                : (column === null || column === void 0 ? void 0 : column.width)
                    ? "width: ".concat(column === null || column === void 0 ? void 0 : column.width, ";")
                    : '');
        });
        document.body.appendChild(div);
        var colWidths = {};
        ths1.forEach(function (th) {
            var index = parseInt(th.getAttribute('data-col'), 10);
            var column = _this.tdColumns[index];
            minWidths[index] = th.clientWidth;
            if (colWidths[index]) {
                colWidths[column === null || column === void 0 ? void 0 : column.name].minWidth = th.clientWidth;
            }
            else {
                colWidths[column === null || column === void 0 ? void 0 : column.name] = { minWidth: th.clientWidth };
            }
        });
        ths2.forEach(function (col) {
            var index = parseInt(col.getAttribute('data-col'), 10);
            var column = _this.tdColumns[index];
            if (column && (column.width || isFixed)) {
                var width = Math.max(typeof column.width === 'number' ? column.width : col.clientWidth, minWidths[index] || 0);
                if (colWidths[column === null || column === void 0 ? void 0 : column.name]) {
                    colWidths[column === null || column === void 0 ? void 0 : column.name].width = width;
                }
                else {
                    colWidths[column === null || column === void 0 ? void 0 : column.name] = { width: width };
                }
                if (column.width) {
                    colWidths[column === null || column === void 0 ? void 0 : column.name].originWidth = column.width;
                }
            }
        });
        if (!isEqual(colWidths, this.state.colWidths)) {
            this.setState({ colWidths: colWidths });
        }
        document.body.removeChild(div);
    };
    Table.prototype.updateTableInfo = function () {
        if (this.resizeTarget) {
            return;
        }
        this.syncTableWidth();
        this.initTableWidth();
    };
    Table.prototype.render = function () {
        var _a, _b;
        var _c = this.props, title = _c.title, footer = _c.footer, className = _c.className, scroll = _c.scroll, size = _c.size, bordered = _c.bordered, resizable = _c.resizable, columns = _c.columns, sticky = _c.sticky, autoFillHeight = _c.autoFillHeight, cx = _c.classnames;
        var _d = getBuildColumns(columns), thColumns = _d.thColumns, tdColumns = _d.tdColumns;
        this.thColumns = thColumns;
        this.tdColumns = tdColumns;
        // 是否设置了纵向滚动
        var hasScrollY = scroll && scroll.y;
        // 是否设置了横向滚动
        var hasScrollX = scroll && scroll.x;
        var style = {};
        if (hasScrollY) {
            Object.assign(style, {
                overflow: 'auto scroll',
                maxHeight: scroll.y
            });
        }
        return (React__default.createElement("div", { ref: this.tableDom, className: cx('Table2', className, (_a = {},
                _a[cx('Table-scroll-horizontal')] = hasScrollX,
                _a[cx("Table-".concat(size))] = size,
                _a[cx('Table-bordered')] = bordered,
                _a[cx('Table-resizable')] = resizable,
                _a)) },
            title ? (React__default.createElement("div", { className: cx('Table-title') }, typeof title === 'function' ? title() : title)) : null,
            hasScrollY && !autoFillHeight ? (this.renderScrollTable()) : (React__default.createElement("div", { className: cx('Table-container', (_b = {},
                    _b[cx('Table-container-self-sticky')] = hasScrollY || (sticky && autoFillHeight),
                    _b)), style: style, ref: this.containerDom }, this.renderTable())),
            footer ? (React__default.createElement("div", { className: cx('Table-footer') }, typeof footer === 'function' ? footer() : footer)) : null));
    };
    Table.defaultProps = {
        title: '',
        className: '',
        dataSource: [],
        columns: [],
        indentSize: 15,
        placeholder: '暂无数据',
        showHeader: true,
        tableLayout: 'auto'
    };
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "getPopOverContainer", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "updateAutoFillHeight", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onResizeMouseMove", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [MouseEvent]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onResizeMouseUp", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Number]),
        __metadata("design:returntype", Promise)
    ], Table.prototype, "onRowClick", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Number]),
        __metadata("design:returntype", Promise)
    ], Table.prototype, "onRowDbClick", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Number]),
        __metadata("design:returntype", Promise)
    ], Table.prototype, "onRowMouseEnter", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Number]),
        __metadata("design:returntype", Promise)
    ], Table.prototype, "onRowMouseLeave", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onMouseLeave", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onExpandRows", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onCollapseRows", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean, Object]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onRowChange", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "onTableScroll", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "syncTableWidth", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "initTableWidth", null);
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Table.prototype, "updateTableInfo", null);
    return Table;
}(React__default.PureComponent));
var Table$1 = themeable(localeable(Table));

export { DefaultCellWidth, Table, Table$1 as default };
