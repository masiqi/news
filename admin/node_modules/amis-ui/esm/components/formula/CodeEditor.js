/**
 * amis-ui v6.13.0
 * Copyright 2018-2025 fex
 */

import { __assign, __read } from 'tslib';
import { themeable } from 'amis-core';
import React__default from 'react';
import { CodeMirrorEditor } from '../CodeMirror.js';
import { editorFactory, FormulaPlugin } from './plugin.js';

function CodeEditor(props, ref) {
    var cx = props.classnames, className = props.className, value = props.value, onChange = props.onChange, editorDidMount = props.editorDidMount, onFocus = props.onFocus, onBlur = props.onBlur, functions = props.functions, variables = props.variables, evalMode = props.evalMode, singleLine = props.singleLine, autoFocus = props.autoFocus, editorTheme = props.editorTheme, defaultTheme = props.theme, editorOptions = props.editorOptions, placeholder = props.placeholder, highlightMode = props.highlightMode;
    var pluginRef = React__default.useRef();
    var editorFactory$1 = React__default.useCallback(function (dom, cm) {
        var theme = (editorTheme !== null && editorTheme !== void 0 ? editorTheme : ((defaultTheme || '').includes('dark') ? 'dark' : 'light')) === 'dark'
            ? 'base16-dark'
            : 'idea';
        var options = __assign({ autoFocus: autoFocus, indentUnit: 2, lineNumbers: true, lineWrapping: true, // 自动换行
            theme: theme, placeholder: placeholder }, editorOptions);
        if (singleLine) {
            options = __assign({ lineNumbers: false, indentWithTabs: false, indentUnit: 4, lineWrapping: false, scrollbarStyle: null, theme: theme, placeholder: placeholder }, editorOptions);
        }
        return editorFactory(dom, cm, props, options);
    }, []);
    var _a = __read(React__default.useState(props.readOnly), 2), readOnly = _a[0], setReadOnly = _a[1];
    React__default.useEffect(function () { return setReadOnly(props.readOnly); }, [props.readOnly]);
    React__default.useEffect(function () { var _a, _b; return (_b = (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.editor) === null || _b === void 0 ? void 0 : _b.setOption('placeholder', placeholder); }, [placeholder]);
    // singleLine 模式下，禁止输入换行符
    var onEditorBeforeChange = React__default.useCallback(function (cm, event) {
        // Identify typing events that add a newline to the buffer.
        var hasTypedNewline = event.origin === '+input' &&
            typeof event.text === 'object' &&
            event.text.join('') === '';
        // Prevent newline characters from being added to the buffer.
        if (hasTypedNewline) {
            return event.cancel();
        }
        // Identify paste events.
        var hasPastedNewline = event.origin === 'paste' &&
            typeof event.text === 'object' &&
            event.text.length > 1;
        // Format pasted text to replace newlines with spaces.
        if (hasPastedNewline) {
            var newText = event.text.join(' ');
            return event.update(null, null, [newText]);
        }
        return null;
    }, []);
    var onEditorMount = React__default.useCallback(function (cm, editor) {
        var plugin = (pluginRef.current = new FormulaPlugin(editor, cm));
        plugin.setEvalMode(!!evalMode);
        plugin.setFunctions(functions || []);
        plugin.setVariables(variables || []);
        plugin.setHighlightMode(highlightMode || 'formula');
        editorDidMount === null || editorDidMount === void 0 ? void 0 : editorDidMount(cm, editor, plugin);
        plugin.autoMarkText();
        // 单行模式，不允许输入换行，同时原来的换行符也要去掉
        if (singleLine) {
            editor.on('beforeChange', onEditorBeforeChange);
            var value_1 = editor.getValue();
            if (value_1 && /[\n\r]/.test(value_1)) {
                // 初始数据有换行，不允许直接编辑
                // 只能弹窗弹出非单行模式编辑
                setReadOnly(true);
                editor.setValue(value_1.replace(/[\n\r]+/g, ''));
            }
        }
    }, [evalMode, functions, variables]);
    React__default.useEffect(function () {
        return function () {
            var _a, _b;
            (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.editor.off('beforeChange', onEditorBeforeChange);
            (_b = pluginRef.current) === null || _b === void 0 ? void 0 : _b.dispose();
        };
    }, []);
    React__default.useImperativeHandle(ref, function () {
        return {
            insertContent: function (value, type) { var _a; return (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.insertContent(value, type); },
            setValue: function (value) { var _a; return (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.setValue(value); },
            getValue: function () { var _a; return (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.getValue(); },
            setDisableAutoMark: function (value) { var _a; return (_a = pluginRef.current) === null || _a === void 0 ? void 0 : _a.setDisableAutoMark(value); }
        };
    });
    React__default.useEffect(function () {
        var plugin = pluginRef.current;
        if (!plugin) {
            return;
        }
        plugin.setEvalMode(!!evalMode);
        plugin.setFunctions(functions || []);
        plugin.setVariables(variables || []);
        plugin.autoMarkText();
    }, [evalMode, functions, variables, value]);
    return (React__default.createElement(CodeMirrorEditor, { className: cx('FormulaCodeEditor', className, singleLine ? 'FormulaCodeEditor--singleLine' : ''), value: value, onChange: onChange, editorFactory: editorFactory$1, editorDidMount: onEditorMount, onFocus: onFocus, onBlur: onBlur, readOnly: readOnly }));
}
var CodeEditor$1 = themeable(React__default.forwardRef(CodeEditor));

export { CodeEditor$1 as default };
