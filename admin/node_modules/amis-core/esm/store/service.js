/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __generator, __assign } from 'tslib';
import { types, flow, getEnv, isAlive } from 'mobx-state-tree';
import { iRendererStore } from './iRenderer.js';
import { isEmpty } from '../utils/helper.js';
import { ServerError } from '../utils/errors.js';
import { normalizeApiResponseData } from '../utils/api.js';
import { replaceText } from '../utils/replaceText.js';
import { concatData } from '../utils/concatData.js';
import { envOverwrite } from '../envOverwrite.js';
import 'amis-formula';
import 'moment';
import { isObject, extendObject } from '../utils/object.js';
import '../utils/memoryParse.js';
import '@rc-component/mini-decimal';
import 'lodash/isPlainObject';
import '../utils/filter.js';
import 'file-saver';
import '../utils/browser.js';
import '../utils/ColorScale.js';
import 'react';
import 'lodash/chunk';
import '../utils/DataSchema.js';
import '../utils/DataScope.js';
import '../utils/debug.js';
import 'react-dom';
import { filter } from '../utils/tpl.js';
import 'lodash/isObject';
import 'lodash/isString';
import 'lodash/isBoolean';
import '../utils/image.js';
import 'lodash/isEqual';
import '../actions/Action.js';
import 'lodash/debounce';
import '../utils/resize-sensor.js';
import 'react-overlays/useRootClose';
import '../utils/SimpleMap.js';
import 'lodash/mapValues';
import 'lodash/camelCase';
import 'lodash/cloneDeep';
import 'lodash/map';
import 'lodash/isEmpty';
import 'lodash/kebabCase';
import 'uncontrollable';
import 'hoist-non-react-statics';
import '../utils/validations.js';
import '../utils/resolveCondition.js';
import 'mobx';
import '../utils/Animation.js';

var ServiceStore = iRendererStore
    .named('ServiceStore')
    .props({
    msg: '',
    error: false,
    fetching: false,
    saving: false,
    busying: false,
    checking: false,
    initializing: false,
    schema: types.optional(types.frozen(), null),
    schemaKey: ''
})
    .views(function (self) { return ({
    get loading() {
        return self.fetching || self.saving || self.busying || self.initializing;
    }
}); })
    .actions(function (self) {
    var fetchCancel;
    var fetchSchemaCancel;
    function markFetching(fetching) {
        if (fetching === void 0) { fetching = true; }
        self.fetching = fetching;
    }
    function markSaving(saving) {
        if (saving === void 0) { saving = true; }
        self.saving = saving;
    }
    function markBusying(busying) {
        if (busying === void 0) { busying = true; }
        self.busying = busying;
    }
    function reInitData(data, replace, concatFields) {
        if (replace === void 0) { replace = false; }
        if (concatFields) {
            data = concatData(data, self.data, concatFields);
        }
        var newData = extendObject(self.data, data, !replace);
        self.data = self.pristine = newData;
    }
    function updateMessage(msg, error) {
        if (error === void 0) { error = false; }
        self.msg = (msg && filter(msg, self.data)) || '';
        self.error = error;
    }
    function clearMessage() {
        updateMessage('');
    }
    var fetchInitData = flow(function getInitData(api, data, options) {
        var json, replace, data_1, ret, e_1, env, message;
        var _a, _b, _c, _d, _e, _f, _g;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _h.trys.push([0, 6, , 7]);
                    if (fetchCancel) {
                        fetchCancel();
                        fetchCancel = null;
                        self.fetching = false;
                    }
                    if (self.fetching) {
                        return [2 /*return*/];
                    }
                    (options && options.silent) || markFetching(true);
                    return [4 /*yield*/, getEnv(self).fetcher(api, data, __assign(__assign({}, options), { cancelExecutor: function (executor) { return (fetchCancel = executor); } }))];
                case 1:
                    json = _h.sent();
                    fetchCancel = null;
                    if (!!json.ok) return [3 /*break*/, 2];
                    updateMessage((_c = (_b = (_a = api === null || api === void 0 ? void 0 : api.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage), true);
                    !api.silent &&
                        getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    return [3 /*break*/, 5];
                case 2:
                    self.updatedAt = Date.now();
                    replace = !!api.replaceData;
                    data_1 = __assign(__assign({}, (replace ? {} : self.data)), normalizeApiResponseData(json.data));
                    reInitData(data_1, replace, api.concatDataFields);
                    self.hasRemoteData = true;
                    if (!(options && options.onSuccess)) return [3 /*break*/, 4];
                    ret = options.onSuccess(json, data_1);
                    if (!(ret && ret.then)) return [3 /*break*/, 4];
                    return [4 /*yield*/, ret];
                case 3:
                    _h.sent();
                    _h.label = 4;
                case 4:
                    updateMessage((_g = (_f = (_e = (_d = api === null || api === void 0 ? void 0 : api.messages) === null || _d === void 0 ? void 0 : _d.success) !== null && _e !== void 0 ? _e : json.msg) !== null && _f !== void 0 ? _f : (options && options.successMessage)) !== null && _g !== void 0 ? _g : json.defaultMsg);
                    // 配置了获取成功提示后提示，默认是空不会提示。
                    options &&
                        options.successMessage &&
                        getEnv(self).notify('success', self.msg);
                    _h.label = 5;
                case 5:
                    markFetching(false);
                    return [2 /*return*/, json];
                case 6:
                    e_1 = _h.sent();
                    env = getEnv(self);
                    if (!isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_1)) {
                        return [2 /*return*/];
                    }
                    markFetching(false);
                    console.error(e_1);
                    message = e_1.message || e_1;
                    if (e_1 && e_1.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !api.silent && env.notify('error', message);
                    return [2 /*return*/];
                case 7: return [2 /*return*/];
            }
        });
    });
    var setHasRemoteData = function () {
        self.hasRemoteData = true;
    };
    var fetchData = flow(function getInitData(api, data, options) {
        var json, ret, e_2, env, message;
        var _a, _b, _c, _d, _e, _f;
        return __generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    _g.trys.push([0, 6, , 7]);
                    if (fetchCancel) {
                        fetchCancel();
                        fetchCancel = null;
                        self.fetching = false;
                    }
                    if (self.fetching) {
                        return [2 /*return*/];
                    }
                    (options && options.silent) || markFetching(true);
                    return [4 /*yield*/, getEnv(self).fetcher(api, data, __assign(__assign({}, options), { cancelExecutor: function (executor) { return (fetchCancel = executor); } }))];
                case 1:
                    json = _g.sent();
                    fetchCancel = null;
                    if (!isEmpty(json.data) || json.ok) {
                        self.updatedAt = Date.now();
                        json.data &&
                            self.updateData(normalizeApiResponseData(json.data), undefined, !!api.replaceData, api.concatDataFields, {
                                type: 'api'
                            });
                        self.hasRemoteData = true;
                    }
                    if (!!json.ok) return [3 /*break*/, 2];
                    updateMessage((_c = (_b = (_a = api === null || api === void 0 ? void 0 : api.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage), true);
                    !api.silent &&
                        getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    return [3 /*break*/, 5];
                case 2:
                    if (!(options && options.onSuccess)) return [3 /*break*/, 4];
                    ret = options.onSuccess(json, json.data);
                    if (!(ret && ret.then)) return [3 /*break*/, 4];
                    return [4 /*yield*/, ret];
                case 3:
                    _g.sent();
                    _g.label = 4;
                case 4:
                    updateMessage((_f = (_e = (_d = api === null || api === void 0 ? void 0 : api.messages) === null || _d === void 0 ? void 0 : _d.success) !== null && _e !== void 0 ? _e : json.msg) !== null && _f !== void 0 ? _f : (options && options.successMessage));
                    // 配置了获取成功提示后提示，默认是空不会提示。
                    options &&
                        options.successMessage &&
                        getEnv(self).notify('success', self.msg);
                    _g.label = 5;
                case 5:
                    markFetching(false);
                    return [2 /*return*/, json];
                case 6:
                    e_2 = _g.sent();
                    env = getEnv(self);
                    if (!isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_2)) {
                        return [2 /*return*/];
                    }
                    markFetching(false);
                    console.error(e_2);
                    message = e_2.message || e_2;
                    if (e_2 && e_2.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !api.silent && env.notify('error', message);
                    return [2 /*return*/];
                case 7: return [2 /*return*/];
            }
        });
    });
    var saveRemote = flow(function saveRemote(api, data, options) {
        var json, ret, ret, e_3, result;
        var _a, _b, _c, _d, _e, _f, _g;
        if (options === void 0) { options = {}; }
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _h.trys.push([0, 8, , 9]);
                    options = __assign({ method: 'post' }, options);
                    if (self.saving) {
                        return [2 /*return*/];
                    }
                    markSaving(true);
                    return [4 /*yield*/, getEnv(self).fetcher(api, data, options)];
                case 1:
                    json = _h.sent();
                    if (!isEmpty(json.data) || json.ok) {
                        self.updatedAt = Date.now();
                        json.data &&
                            self.updateData(normalizeApiResponseData(json.data), undefined, !!api.replaceData, api.concatDataFields, {
                                type: 'api'
                            });
                    }
                    if (!!json.ok) return [3 /*break*/, 4];
                    if (!(options && options.onFailed)) return [3 /*break*/, 3];
                    ret = options.onFailed(json);
                    if (!(ret && ret.then)) return [3 /*break*/, 3];
                    return [4 /*yield*/, ret];
                case 2:
                    _h.sent();
                    _h.label = 3;
                case 3:
                    updateMessage((_d = (_c = (_b = (_a = api === null || api === void 0 ? void 0 : api.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage)) !== null && _d !== void 0 ? _d : self.__('saveFailed'), true);
                    throw new ServerError(self.msg, json);
                case 4:
                    if (!(options && options.onSuccess)) return [3 /*break*/, 6];
                    ret = options.onSuccess(json, json.data);
                    if (!(ret && ret.then)) return [3 /*break*/, 6];
                    return [4 /*yield*/, ret];
                case 5:
                    _h.sent();
                    _h.label = 6;
                case 6:
                    updateMessage((_g = (_f = (_e = api === null || api === void 0 ? void 0 : api.messages) === null || _e === void 0 ? void 0 : _e.success) !== null && _f !== void 0 ? _f : json.msg) !== null && _g !== void 0 ? _g : (options && options.successMessage));
                    self.msg &&
                        getEnv(self).notify('success', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    _h.label = 7;
                case 7:
                    markSaving(false);
                    return [2 /*return*/, json.data];
                case 8:
                    e_3 = _h.sent();
                    self.saving = false;
                    if (!isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    console.error(e_3);
                    if (!api.silent) {
                        if (e_3.type === 'ServerError') {
                            result = e_3.response;
                            getEnv(self).notify('error', e_3.message, result.msgTimeout !== undefined
                                ? {
                                    closeButton: true,
                                    timeout: result.msgTimeout
                                }
                                : undefined);
                        }
                        else {
                            getEnv(self).notify('error', e_3.message);
                        }
                    }
                    throw e_3;
                case 9: return [2 /*return*/];
            }
        });
    });
    var fetchSchema = flow(function fetchSchema(api, data, options) {
        var json, env, e_4, env, message;
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (options === void 0) { options = {}; }
        return __generator(this, function (_j) {
            switch (_j.label) {
                case 0:
                    _j.trys.push([0, 2, , 3]);
                    options = __assign(__assign({ method: 'post' }, options), { cancelExecutor: function (executor) { return (fetchSchemaCancel = executor); } });
                    if (fetchSchemaCancel) {
                        fetchSchemaCancel();
                        fetchSchemaCancel = null;
                        self.initializing = false;
                    }
                    if (self.initializing) {
                        return [2 /*return*/];
                    }
                    self.initializing = true;
                    if (typeof api === 'string') {
                        api += (~api.indexOf('?') ? '&' : '?') + '_replace=1';
                    }
                    else {
                        api = __assign(__assign({}, api), { url: api.url +
                                (~api.url.indexOf('?') ? '&' : '?') +
                                '_replace=1' });
                    }
                    return [4 /*yield*/, getEnv(self).fetcher(api, data, options)];
                case 1:
                    json = _j.sent();
                    fetchSchemaCancel = null;
                    if (!json.ok) {
                        updateMessage((_d = (_c = (_b = (_a = api === null || api === void 0 ? void 0 : api.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage)) !== null && _d !== void 0 ? _d : self.__('fetchFailed'), true);
                        !(api === null || api === void 0 ? void 0 : api.silent) &&
                            getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                                ? {
                                    closeButton: true,
                                    timeout: json.msgTimeout
                                }
                                : undefined);
                    }
                    else {
                        if (json.data) {
                            env = getEnv(self);
                            json.data = envOverwrite(json.data, env.locale);
                            json.data = replaceText(json.data, env.replaceText, env.replaceTextIgnoreKeys);
                            self.schema = Array.isArray(json.data)
                                ? json.data
                                : Object.assign(((_e = json.data) === null || _e === void 0 ? void 0 : _e.type)
                                    ? {}
                                    : {
                                        type: 'wrapper',
                                        wrap: false
                                    }, normalizeApiResponseData(json.data));
                            self.schemaKey = '' + Date.now();
                            isObject(json.data.data) &&
                                self.updateData(json.data.data, undefined, !!api.replaceData, api.concatDataFields, {
                                    type: 'api'
                                });
                        }
                        updateMessage((_h = (_g = (_f = api === null || api === void 0 ? void 0 : api.messages) === null || _f === void 0 ? void 0 : _f.success) !== null && _g !== void 0 ? _g : json.msg) !== null && _h !== void 0 ? _h : (options && options.successMessage));
                        // 配置了获取成功提示后提示，默认是空不会提示。
                        options &&
                            options.successMessage &&
                            getEnv(self).notify('success', self.msg);
                    }
                    self.initializing = false;
                    return [2 /*return*/, json.data];
                case 2:
                    e_4 = _j.sent();
                    env = getEnv(self);
                    self.initializing = false;
                    if (!isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_4)) {
                        return [2 /*return*/];
                    }
                    console.error(e_4);
                    message = e_4.message || e_4;
                    if (e_4 && e_4.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !(api === null || api === void 0 ? void 0 : api.silent) && env.notify('error', message);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
    var checkRemote = flow(function checkRemote(api, data, options) {
        var json;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (self.checking) {
                        return [2 /*return*/];
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    self.checking = true;
                    return [4 /*yield*/, getEnv(self).fetcher(api, data, options)];
                case 2:
                    json = _a.sent();
                    json.ok &&
                        self.updateData(json.data, undefined, !!api.replaceData, api.concatDataFields);
                    if (!json.ok) {
                        throw new Error(json.msg);
                    }
                    return [2 /*return*/, json.data];
                case 3:
                    self.checking = false;
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    });
    return {
        markFetching: markFetching,
        markSaving: markSaving,
        markBusying: markBusying,
        fetchInitData: fetchInitData,
        fetchData: fetchData,
        reInitData: reInitData,
        updateMessage: updateMessage,
        clearMessage: clearMessage,
        setHasRemoteData: setHasRemoteData,
        saveRemote: saveRemote,
        fetchSchema: fetchSchema,
        checkRemote: checkRemote
    };
});

export { ServiceStore };
