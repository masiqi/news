/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __assign, __rest } from 'tslib';
import { types, getParent } from 'mobx-state-tree';
import { iRendererStore } from './iRenderer.js';
import isEqual from 'lodash/isEqual';
import { immutableExtends, guid } from '../utils/helper.js';
import { evalExpression } from '../utils/tpl.js';
import { createObject, extendObject, isObject } from '../utils/object.js';

var Item = types
    .model('Item', {
    storeType: 'Item',
    id: types.identifier,
    pristine: types.frozen(),
    data: types.frozen(),
    index: types.number,
    newIndex: types.number
})
    .views(function (self) { return ({
    get checked() {
        return getParent(self, 2).isSelected(self);
    },
    get modified() {
        if (!self.data) {
            return false;
        }
        return Object.keys(self.data).some(function (key) { return !isEqual(self.data[key], self.pristine[key]); });
    },
    get moved() {
        return self.index !== self.newIndex;
    },
    get locals() {
        var listStore = getParent(self, 2);
        return createObject(extendObject(listStore.data, __assign({ index: self.index }, listStore.eventContext)), self.data);
    },
    get checkable() {
        var table = getParent(self, 2);
        return table && table.itemCheckableOn
            ? evalExpression(table.itemCheckableOn, self.locals)
            : true;
    },
    get draggable() {
        var list = getParent(self, 2);
        return list && list.itemDraggableOn
            ? evalExpression(list.itemDraggableOn, self.locals)
            : list.draggable;
    }
}); })
    .actions(function (self) { return ({
    toggle: function () {
        getParent(self, 2).toggle(self);
    },
    change: function (values, savePristine) {
        self.data = immutableExtends(self.data, values);
        savePristine && (self.pristine = self.data);
    },
    reset: function () {
        self.newIndex = self.index;
        self.data = self.pristine;
    },
    updateData: function (_a) {
        _a.children; var rest = __rest(_a, ["children"]);
        self.data = __assign(__assign({}, self.data), rest);
        // if (Array.isArray(children)) {
        // }
    }
}); });
var ListStore = iRendererStore
    .named('ListStore')
    .props({
    items: types.array(Item),
    // 记录原始列表和原始选中的列表
    // 因为如果是前端分页，上层 crud 或者 input-table 下发到这层的
    // 是某个页区间的数据，这个时候 items 和 selectedItems 会少很多条
    fullItems: types.optional(types.array(types.frozen()), []),
    fullSelectedItems: types.optional(types.array(types.frozen()), []),
    selectedItems: types.array(types.reference(Item)),
    primaryField: 'id',
    orderBy: '',
    orderDir: types.optional(types.union(types.literal('asc'), types.literal('desc')), 'asc'),
    draggable: false,
    dragging: false,
    multiple: true,
    strictMode: false,
    selectable: false,
    itemCheckableOn: '',
    itemDraggableOn: '',
    hideCheckToggler: false
})
    .views(function (self) {
    function isSelected(item) {
        return !!~self.selectedItems.indexOf(item);
    }
    function getModifiedItems() {
        return self.items.filter(function (item) { return item.modified; });
    }
    function getModified() {
        return getModifiedItems().length;
    }
    function getMovedItems() {
        return self.items.filter(function (item) { return item.moved; });
    }
    function getMovied() {
        return getMovedItems().length;
    }
    return {
        get allChecked() {
            return !!(self.selectedItems.length ===
                self.checkableItems.length &&
                self.checkableItems.length);
        },
        get checkableItems() {
            return self.items.filter(function (item) { return item.checkable; });
        },
        get unSelectedItems() {
            return self.items.filter(function (item) { return !item.checked; });
        },
        isSelected: isSelected,
        get modified() {
            return getModified();
        },
        get modifiedItems() {
            return getModifiedItems();
        },
        get moved() {
            return getMovied();
        },
        get movedItems() {
            return getMovedItems();
        },
        /**
         * 构建事件的上下文数据
         * @param buildChain
         * @returns
         */
        get eventContext() {
            var context = {
                selectedItems: self.selectedItems.map(function (item) { return item.data; }),
                selectedIndexes: self.selectedItems.map(function (item) { return item.index; }),
                items: self.items.map(function (item) { return item.data; }),
                unSelectedItems: this.unSelectedItems.map(function (item) { return item.data; })
            };
            // 如果是前端分页情况，需要根据全量数据计算
            // 如果不是前端分页，数据都没有返回，那种就没办法支持全量数据信息了
            if (self.fullItems.length > self.items.length) {
                // todo 这里的选择顺序会一直变，这个有影响吗?
                var selectedItems_1 = self.fullSelectedItems
                    .filter(function (item) {
                    return !self.items.find(function (row) { return row.pristine === (item.__pristine || item); });
                })
                    .concat(context.selectedItems);
                context.selectedItems = selectedItems_1;
                context.items = self.fullItems.concat();
                context.unSelectedItems = self.fullItems.filter(function (item) { return !selectedItems_1.includes(item); });
                context.selectedIndexes = selectedItems_1.map(function (item) {
                    return self.fullItems.indexOf(item.__pristine || item);
                });
            }
            return context;
        }
    };
})
    .actions(function (self) {
    function update(config) {
        config.selectable === void 0 || (self.selectable = config.selectable);
        config.draggable === void 0 || (self.draggable = config.draggable);
        config.multiple === void 0 || (self.multiple = config.multiple);
        config.strictMode === void 0 || (self.strictMode = config.strictMode);
        config.hideCheckToggler === void 0 ||
            (self.hideCheckToggler = config.hideCheckToggler);
        if (typeof config.orderBy !== 'undefined') {
            setOrderByInfo(config.orderBy, config.orderDir === 'desc' ? 'desc' : 'asc');
        }
        config.itemCheckableOn === void 0 ||
            (self.itemCheckableOn = config.itemCheckableOn);
        config.itemDraggableOn === void 0 ||
            (self.itemDraggableOn = config.itemDraggableOn);
    }
    function initItems(items, fullItems, fullSelectedItems) {
        var arr = items.map(function (item, key) {
            item = isObject(item)
                ? item
                : {
                    item: item
                };
            return {
                // id: String((item as any)[self.primaryField] || key),
                id: guid(),
                index: key,
                newIndex: key,
                pristine: item.__pristine || item,
                data: item
            };
        });
        self.selectedItems.clear();
        self.items.replace(arr);
        self.dragging = false;
        Array.isArray(fullItems) && self.fullItems.replace(fullItems);
        Array.isArray(fullSelectedItems) &&
            self.fullSelectedItems.replace(fullSelectedItems);
    }
    function updateSelected(selected, valueField) {
        self.selectedItems.clear();
        selected.forEach(function (item) {
            var resolved = self.items.find(function (a) { return a.pristine === item; });
            // 先严格比较，
            if (!resolved) {
                resolved = self.items.find(function (a) {
                    var selectValue = item[valueField || 'value'];
                    var itemValue = a.pristine[valueField || 'value'];
                    return selectValue === itemValue;
                });
            }
            // 再宽松比较
            if (!resolved) {
                resolved = self.items.find(function (a) {
                    var selectValue = item[valueField || 'value'];
                    var itemValue = a.pristine[valueField || 'value'];
                    return selectValue == itemValue;
                });
            }
            resolved && self.selectedItems.push(resolved);
        });
    }
    function toggleAll() {
        if (self.allChecked) {
            self.selectedItems.clear();
        }
        else {
            self.selectedItems.replace(self.checkableItems);
        }
    }
    function clearAll() {
        self.selectedItems.clear();
    }
    function selectAll() {
        self.selectedItems.replace(self.checkableItems);
    }
    function toggle(item) {
        if (!item.checkable) {
            return;
        }
        var idx = self.selectedItems.indexOf(item);
        if (self.multiple) {
            ~idx
                ? self.selectedItems.splice(idx, 1)
                : self.selectedItems.push(item);
        }
        else {
            ~idx
                ? self.selectedItems.splice(idx, 1)
                : self.selectedItems.replace([item]);
        }
    }
    function clear() {
        self.selectedItems.clear();
    }
    function setOrderByInfo(key, direction) {
        self.orderBy = key;
        self.orderDir = direction;
    }
    function reset() {
        self.items.forEach(function (item) { return item.reset(); });
        self.dragging = false;
    }
    function toggleDragging() {
        self.dragging = !self.dragging;
    }
    function startDragging() {
        self.dragging = true;
    }
    function stopDragging() {
        self.dragging = false;
    }
    function exchange(fromIndex, toIndex) {
        var item = self.items[fromIndex];
        item.newIndex = toIndex;
        var newItems = self.items.slice();
        newItems.splice(fromIndex, 1);
        newItems.splice(toIndex, 0, item);
        self.items.replace(newItems);
    }
    function getData(superData) {
        return createObject(superData, __assign({}, self.eventContext));
    }
    return {
        getData: getData,
        update: update,
        initItems: initItems,
        updateSelected: updateSelected,
        toggleAll: toggleAll,
        clearAll: clearAll,
        selectAll: selectAll,
        toggle: toggle,
        clear: clear,
        setOrderByInfo: setOrderByInfo,
        reset: reset,
        toggleDragging: toggleDragging,
        startDragging: startDragging,
        stopDragging: stopDragging,
        exchange: exchange
    };
});

export { Item, ListStore };
