/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __assign, __awaiter, __generator } from 'tslib';
import React from 'react';
import { RendererStore } from './store/index.js';
import { destroy, getEnv } from 'mobx-state-tree';
import { wrapFetcher } from './utils/api.js';
import { normalizeLink } from './utils/normalizeLink.js';
import { qsparse, parseQuery, isMobile, findIndex, promisify } from './utils/helper.js';
import { observer } from 'mobx-react';
import { HocScoped } from './Scoped.js';
import find from 'lodash/find';
import { HocStoreFactory } from './WithStore.js';
import { Placeholder } from './renderers/Placeholder.js';
import { getPageId } from './utils/getPageId.js';
import { string2regExp } from './utils/string2regExp.js';

var _a, _b;
var renderers = [];
// type 与 RendererConfig 的映射关系
var renderersTypeMap = {};
var renderersMap = {};
var schemaFilters = [];
var anonymousIndex = 1;
function addSchemaFilter(fn) {
    schemaFilters.push(fn);
}
function filterSchema(schema, render, props) {
    return schemaFilters.reduce(function (schema, filter) { return filter(schema, render, props); }, schema);
}
function Renderer(config) {
    return function (component) {
        var renderer = registerRenderer(__assign(__assign({}, config), { component: component }));
        return renderer.component;
    };
}
// mobx-react 的 observer 会修改原型链的 render 方法
// 如果想继承覆盖组件的 render 方法，需要把原型链 render 还原回来
// 否则无法调用 super.render 方法
function fixMobxInjectRender(klass) {
    var _a;
    var target = klass.prototype;
    // mobx-react 篡改之前先记录原始 render
    if (target === null || target === void 0 ? void 0 : target.render) {
        target.__originRender = target.render;
    }
    // 将父级类上面被 mobx 篡改的 render 方法还原回来
    // 而且当前类的 render 也是会被篡改的，所以父级上的其实不需要篡改
    if ((_a = target === null || target === void 0 ? void 0 : target.__proto__) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('__originRender')) {
        var originProto = target.__proto__;
        target.__proto__ = Object.create(originProto.__proto__ || Object);
        Object.assign(target.__proto__, originProto);
        target.__proto__.render = originProto.__originRender;
    }
    return klass;
}
// 将 renderer 转成组件
function rendererToComponent(component, config) {
    if (config.storeType && config.component) {
        component = HocStoreFactory({
            storeType: config.storeType,
            extendsData: config.storeExtendsData,
            shouldSyncSuperStore: config.shouldSyncSuperStore
        })(observer(fixMobxInjectRender(component)));
    }
    if (config.isolateScope) {
        component = HocScoped(component, config.type);
    }
    return component;
}
function registerRenderer(config) {
    if (!config.test && !config.type) {
        throw new TypeError('please set config.type or config.test');
    }
    else if (!config.type && config.name !== 'static') {
        // todo static 目前还没办法不用 test 来实现
        console.warn("config.type is recommended for register renderer(".concat(config.test, ")"));
    }
    if (typeof config.type === 'string' && config.type) {
        config.type = config.type.toLowerCase();
        config.test =
            config.test ||
                new RegExp("(^|/)(?:".concat((config.alias || [])
                    .concat(config.type)
                    .map(function (type) { return string2regExp(type); })
                    .join('|'), ")$"), 'i');
    }
    var exists = renderersTypeMap[config.type || ''];
    var renderer = __assign({}, config);
    if (exists &&
        exists.component &&
        exists.component !== Placeholder &&
        config.component &&
        !exists.origin &&
        !config.override) {
        throw new Error("The renderer with type \"".concat(config.type, "\" has already exists, please try another type!"));
    }
    else if (exists) {
        // 如果已经存在，合并配置，并用合并后的配置
        renderer = Object.assign(exists, config);
        // 如果已存在的配置有占位组件，并且新的配置是异步渲染器，在把占位组件删除
        // 避免遇到设置了 visibleOn/hiddenOn 条件的 Schema 无法渲染的问题
        if (exists.component === Placeholder &&
            !config.component &&
            config.getComponent) {
            delete renderer.component;
            delete renderer.Renderer;
        }
    }
    renderer.weight = renderer.weight || 0;
    renderer.name =
        renderer.name || renderer.type || "anonymous-".concat(anonymousIndex++);
    if (config.component) {
        renderer.Renderer = config.component;
        renderer.component = rendererToComponent(config.component, renderer);
    }
    if (!exists) {
        var idx = findIndex(renderers, function (item) { return config.weight < item.weight; });
        ~idx ? renderers.splice(idx, 0, renderer) : renderers.push(renderer);
    }
    renderersMap[renderer.name] = !!(renderer.component && renderer.component !== Placeholder);
    renderer.type && (renderersTypeMap[renderer.type] = renderer);
    (renderer.alias || []).forEach(function (alias) {
        var fork = __assign(__assign({}, renderer), { type: alias, name: alias, alias: undefined, origin: renderer });
        var idx = renderers.findIndex(function (item) { return item.name === alias; });
        if (~idx) {
            Object.assign(renderers[idx], fork);
        }
        else {
            renderers.push(fork);
        }
        renderersTypeMap[alias] = fork;
        renderersMap[alias] = true;
    });
    return renderer;
}
function unRegisterRenderer(config) {
    var _a;
    var name = (typeof config === 'string' ? config : config.name);
    var idx = renderers.findIndex(function (item) { return item.name === name; });
    if (~idx) {
        var renderer_1 = renderers[idx];
        renderers.splice(idx, 1);
        delete renderersMap[name];
        delete renderersTypeMap[renderer_1.type || ''];
        (_a = renderer_1.alias) === null || _a === void 0 ? void 0 : _a.forEach(function (alias) {
            var idx = renderers.findIndex(function (item) { return item.name === alias; });
            idx > -1 && renderers.splice(idx, 1);
            delete renderersTypeMap[alias];
            delete renderersMap[alias];
        });
        // 清空渲染器定位缓存
        Object.keys(cache).forEach(function (key) {
            var value = cache[key];
            if (value === renderer_1) {
                delete cache[key];
            }
        });
    }
}
function loadRendererError(schema, path) {
    return (React.createElement("div", { className: "RuntimeError" },
        React.createElement("p", null, "Error: \u627E\u4E0D\u5230\u5BF9\u5E94\u7684\u6E32\u67D3\u5668"),
        React.createElement("p", null,
            "Path: ",
            path),
        React.createElement("pre", null,
            React.createElement("code", null, JSON.stringify(schema, null, 2)))));
}
function loadAsyncRenderer(renderer) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!isAsyncRenderer(renderer)) {
                        // already loaded
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, renderer.getComponent()];
                case 1:
                    result = _a.sent();
                    // 如果异步加载的组件没有注册渲染器
                    // 同时默认导出了一个组件，则自动注册
                    if (!renderer.component && result.default) {
                        registerRenderer(__assign(__assign({}, renderer), { component: result.default }));
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function isAsyncRenderer(item) {
    return (item &&
        (!item.component || item.component === Placeholder) &&
        item.getComponent);
}
function hasAsyncRenderers(types) {
    return (Array.isArray(types)
        ? renderers.filter(function (item) { return item.type && types.includes(item.type); })
        : renderers).some(isAsyncRenderer);
}
function loadAsyncRenderersByType(type, ignore) {
    if (ignore === void 0) { ignore = false; }
    return __awaiter(this, void 0, void 0, function () {
        var types, asyncRenderers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    types = Array.isArray(type) ? type : [type];
                    asyncRenderers = types
                        .map(function (type) {
                        var renderer = renderersTypeMap[type];
                        if (!renderer && !ignore) {
                            throw new Error("Can not find the renderer by type: ".concat(type));
                        }
                        return renderer;
                    })
                        .filter(isAsyncRenderer);
                    if (!asyncRenderers.length) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(asyncRenderers.map(function (item) { return loadAsyncRenderer(item); }))];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
function loadAllAsyncRenderers() {
    return __awaiter(this, void 0, void 0, function () {
        var asyncRenderers;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    asyncRenderers = renderers.filter(isAsyncRenderer);
                    if (!asyncRenderers.length) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(renderers.map(function (renderer) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, loadAsyncRenderer(renderer)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
var defaultOptions = {
    session: 'global',
    richTextToken: '',
    useMobileUI: true,
    enableAMISDebug: (_b = (_a = window.enableAMISDebug) !== null && _a !== void 0 ? _a : location.search.indexOf('amisDebug=1') !== -1) !== null && _b !== void 0 ? _b : false,
    loadRenderer: loadRendererError,
    fetcher: function () {
        return Promise.reject('fetcher is required');
    },
    // 使用 WebSocket 来实时获取数据
    wsFetcher: function (ws, onMessage, onError) {
        if (ws) {
            var socket_1 = new WebSocket(ws.url);
            socket_1.onopen = function (event) {
                if (ws.body) {
                    socket_1.send(JSON.stringify(ws.body));
                }
            };
            socket_1.onmessage = function (event) {
                var _a;
                if (event.data) {
                    var data = void 0;
                    try {
                        data = JSON.parse(event.data);
                    }
                    catch (error) { }
                    if (typeof data !== 'object') {
                        var key = ws.responseKey || 'data';
                        data = (_a = {},
                            _a[key] = event.data,
                            _a);
                    }
                    onMessage(data);
                }
            };
            socket_1.onerror = onError;
            return {
                close: socket_1.close
            };
        }
        else {
            return {
                close: function () { }
            };
        }
    },
    isCancel: function () {
        console.error('Please implement isCancel. see https://aisuda.bce.baidu.com/amis/zh-CN/start/getting-started#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97');
        return false;
    },
    updateLocation: function () {
        console.error('Please implement updateLocation. see https://aisuda.bce.baidu.com/amis/zh-CN/start/getting-started#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97');
    },
    jumpTo: function (to, action) {
        if (to === 'goBack') {
            return window.history.back();
        }
        to = normalizeLink(to);
        if (action && action.actionType === 'url') {
            action.blank === false ? (window.location.href = to) : window.open(to);
            return;
        }
        // link动作新增了targetType属性，默认是内容区打开(page),在新窗口打开(blank);在当前页签打开(self)
        if ((action === null || action === void 0 ? void 0 : action.actionType) === 'link' &&
            ['blank', 'self'].includes(action === null || action === void 0 ? void 0 : action.targetType)) {
            if (action.targetType === 'self') {
                // 当前页签打开，需要刷新页面
                window.history.pushState(null, '', to);
                location.reload();
            }
            else {
                window.open(to);
            }
            return;
        }
        if (/^https?:\/\//.test(to)) {
            window.location.replace(to);
        }
        else {
            location.href = to;
        }
    },
    isCurrentUrl: function (to) {
        if (!to) {
            return false;
        }
        var link = normalizeLink(to);
        var location = window.location;
        var pathname = link;
        var search = '';
        var idx = link.indexOf('?');
        if (~idx) {
            pathname = link.substring(0, idx);
            search = link.substring(idx);
        }
        if (search) {
            if (pathname !== location.pathname || !location.search) {
                return false;
            }
            var query_1 = qsparse(search.substring(1));
            var currentQuery_1 = parseQuery(location);
            return Object.keys(query_1).every(function (key) { return query_1[key] === currentQuery_1[key]; });
        }
        else if (pathname === location.pathname) {
            return true;
        }
        return false;
    },
    copy: function (contents) {
        console.error('copy contents', contents);
    },
    // 用于跟踪用户在界面中的各种操作
    tracker: function (eventTrack, props) { },
    rendererResolver: resolveRenderer,
    replaceTextIgnoreKeys: [
        'type',
        'name',
        'mode',
        'target',
        'reload',
        'persistData'
    ],
    /**
     * 过滤 html 标签，可用来添加 xss 保护逻辑
     */
    filterHtml: function (input) { return input; },
    isMobile: isMobile,
    getPageId: getPageId
};
var stores = {};
// 默认 env 会被缓存，所以新传入的 env 不会替换旧的。
// 除非先删了旧的，新的才会生效。
function clearStoresCache(sessions) {
    if (sessions === void 0) { sessions = Object.keys(stores); }
    if (!Array.isArray(sessions)) {
        sessions = [sessions];
    }
    sessions.forEach(function (key) {
        var store = stores[key];
        // @ts-ignore
        delete stores[key];
        store && destroy(store);
    });
}
// 当然也可以直接这样更新。
// 主要是有时候第一次创建的时候并没有准备多少接口，
// 可以后续补充点，比如 amis 自己实现的，prompt 里面的表单。
function updateEnv(options, session) {
    if (session === void 0) { session = 'global'; }
    options = __assign({}, options);
    if (options.fetcher) {
        options.fetcher = wrapFetcher(options.fetcher, options.tracker);
    }
    if (options.confirm) {
        options.confirm = promisify(options.confirm);
    }
    var store = stores[options.session || session];
    if (!store) {
        store = RendererStore.create({}, __assign(__assign({}, defaultOptions), options));
        stores[options.session || session] = store;
    }
    else {
        var env = getEnv(store);
        Object.assign(env, options);
    }
}
// 扩充默认的 env ，这样使用方不需要指定都会有。
function extendDefaultEnv(env) {
    Object.assign(defaultOptions, env);
}
var cache = {};
function resolveRenderer(path, schema) {
    var type = typeof (schema === null || schema === void 0 ? void 0 : schema.type) == 'string' ? schema.type.toLowerCase() : '';
    // 直接匹配类型，后续注册渲染都应该用这个方式而不是之前的判断路径。
    if (type && renderersTypeMap[type]) {
        return renderersTypeMap[type];
    }
    else if (cache[path]) {
        return cache[path];
    }
    else if (path && path.length > 3072) {
        throw new Error('Path太长是不是死循环了？');
    }
    var renderer = null;
    renderers.some(function (item) {
        var matched = false;
        if (typeof item.test === 'function') {
            // 不应该搞得这么复杂的，让每个渲染器唯一 id，自己不晕别人用起来也不晕。
            matched = item.test(path, schema, resolveRenderer);
        }
        else if (item.test instanceof RegExp) {
            matched = item.test.test(path);
        }
        if (matched) {
            renderer = item;
        }
        return matched;
    });
    // 只能缓存纯正则表达式的后者方法中没有用到第二个参数的，
    // 因为自定义 test 函数的有可能依赖 schema 的结果
    if (renderer !== null &&
        renderer.component !== Placeholder &&
        (renderer.type ||
            renderer.test instanceof RegExp ||
            (typeof renderer.test === 'function' &&
                renderer.test.length < 2))) {
        cache[path] = renderer;
    }
    return renderer;
}
function getRenderers() {
    return renderers.concat();
}
function getRendererByName(name) {
    return find(renderers, function (item) { return item.name === name; });
}
var GlobalOptions = {
    pdfjsWorkerSrc: ''
};
function setGlobalOptions(options) {
    Object.assign(GlobalOptions, options);
}
function getGlobalOptions() {
    return GlobalOptions;
}

export { Renderer, addSchemaFilter, clearStoresCache, defaultOptions, extendDefaultEnv, filterSchema, getGlobalOptions, getRendererByName, getRenderers, hasAsyncRenderers, isAsyncRenderer, loadAllAsyncRenderers, loadAsyncRenderer, loadAsyncRenderersByType, loadRendererError, registerRenderer, renderersMap, resolveRenderer, setGlobalOptions, stores, unRegisterRenderer, updateEnv };
