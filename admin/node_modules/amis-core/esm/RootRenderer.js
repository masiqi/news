/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __extends, __assign, __rest, __awaiter, __generator, __spreadArray, __read, __decorate, __metadata } from 'tslib';
import { observer } from 'mobx-react';
import React from 'react';
import { filterTarget, ScopedContext } from './Scoped.js';
import { RootStore } from './store/root.js';
import { guid, bulkBindFunctions, JSONTraverse, isVisible } from './utils/helper.js';
import { filter } from './utils/tpl.js';
import qs from 'qs';
import pick from 'lodash/pick';
import mapValues from 'lodash/mapValues';
import { saveAs } from 'file-saver';
import { normalizeApi } from './utils/api.js';
import { findDOMNode } from 'react-dom';
import themedLazyComponent from './components/LazyComponent.js';
import { hasAsyncRenderers, loadAsyncRenderersByType } from './factory.js';
import { dispatchEvent } from './utils/renderer-event.js';

var RootRenderer = /** @class */ (function (_super) {
    __extends(RootRenderer, _super);
    function RootRenderer(props) {
        var _this = this;
        var _a;
        _this = _super.call(this, props) || this;
        _this.store = props.rootStore.addStore({
            id: guid(),
            path: _this.props.$path,
            storeType: RootStore.name,
            parentId: ''
        });
        _this.store.updateContext(props.context, true);
        _this.store.initData(props.data);
        _this.store.updateLocation(props.location, (_a = _this.props.env) === null || _a === void 0 ? void 0 : _a.parseLocation);
        // 将数据里面的函数批量的绑定到 this 上
        bulkBindFunctions(_this, [
            'handleAction',
            'dispatchEvent',
            'handleDialogConfirm',
            'handleDialogClose',
            'handleDrawerConfirm',
            'handleDrawerClose',
            'handlePageVisibilityChange'
        ]);
        _this.store.init(function () {
            if (!hasAsyncRenderers()) {
                return;
            }
            var schema = props.schema;
            var types = [
                'tpl',
                'dialog',
                'drawer',
                'cell',
                'spinner',
                'group',
                'container',
                'dropdown-button',
                'plain'
            ];
            JSONTraverse(schema, function (value, key) {
                if (key === 'type') {
                    types.push(value);
                    // form 依赖 panel
                    if (value === 'form') {
                        types.push('panel');
                    }
                }
            });
            return hasAsyncRenderers(types)
                ? loadAsyncRenderersByType(types, true)
                : undefined;
        });
        return _this;
    }
    RootRenderer.prototype.componentDidMount = function () {
        // 不要设置太早，否则组件内部的监控可能会监控不到，因为初始值可能在监控之前就设置了。
        // 以至于监控不到变化。
        this.store.setGlobalVars(this.props.globalVars);
        document.addEventListener('visibilitychange', this.handlePageVisibilityChange);
        // 兼容 affixOffsetTop 和 affixOffsetBottom
        if (typeof this.props.env.affixOffsetTop !== 'undefined' ||
            typeof this.props.env.affixOffsetBottom !== 'undefined') {
            // top: var(--affix-offset-top);
            var dom = findDOMNode(this);
            if (dom === null || dom === void 0 ? void 0 : dom.parentElement) {
                dom.parentElement.style.cssText += "--affix-offset-top: ".concat(this.props.env.affixOffsetTop || 0, "px; --affix-offset-bottom: ").concat(this.props.env.affixOffsetBottom || 0, "px;");
            }
        }
    };
    RootRenderer.prototype.componentDidUpdate = function (prevProps) {
        var _a;
        var props = this.props;
        // 更新全局变量
        if (props.globalVars !== prevProps.globalVars) {
            this.store.setGlobalVars(props.globalVars);
        }
        if (props.location !== prevProps.location) {
            this.store.updateLocation(props.location, (_a = this.props.env) === null || _a === void 0 ? void 0 : _a.parseLocation);
        }
        var contextChanged = false;
        if (props.context !== prevProps.context) {
            contextChanged = true;
            this.store.updateContext(props.context);
        }
        // 一定要最后处理，否则 downStream 里面的上层数据 context 还是老的。
        if (props.data !== prevProps.data || contextChanged) {
            // context 依赖 data 变化才能触发变动，所以不管 data 变没变都更新一下
            this.store.initData(props.data);
        }
    };
    RootRenderer.prototype.componentDidCatch = function (error, errorInfo) {
        var _a, _b;
        (_b = (_a = this.props.env) === null || _a === void 0 ? void 0 : _a.errorCatcher) === null || _b === void 0 ? void 0 : _b.call(_a, error, errorInfo);
        this.store.setRuntimeError(error, errorInfo);
    };
    RootRenderer.prototype.componentWillUnmount = function () {
        this.props.rootStore.removeStore(this.store);
        document.removeEventListener('visibilitychange', this.handlePageVisibilityChange);
    };
    RootRenderer.prototype.handlePageVisibilityChange = function () {
        var env = this.props.env;
        if (document.visibilityState === 'hidden') {
            env === null || env === void 0 ? void 0 : env.tracker({
                eventType: 'pageHidden'
            });
        }
        else if (document.visibilityState === 'visible') {
            env === null || env === void 0 ? void 0 : env.tracker({
                eventType: 'pageVisible'
            });
        }
    };
    RootRenderer.prototype.handleAction = function (e, action, ctx, throwErrors, delegate) {
        var _this = this;
        var _a, _b;
        if (throwErrors === void 0) { throwErrors = false; }
        var _c = this.props, env = _c.env, messages = _c.messages, onAction = _c.onAction, mobileUI = _c.mobileUI, render = _c.render;
        var store = this.store;
        if ((onAction === null || onAction === void 0 ? void 0 : onAction(e, action, ctx, throwErrors, delegate || this.context)) ===
            false) {
            return;
        }
        var scoped = delegate || this.context;
        if (action.actionType === 'reload') {
            action.target && scoped.reload(action.target, ctx);
        }
        else if (action.target) {
            action.target.split(',').forEach(function (name) {
                var target = scoped.getComponentByName(name);
                target &&
                    target.doAction &&
                    target.doAction(__assign(__assign({}, action), { target: undefined }), ctx);
            });
        }
        else if (action.actionType === 'url' ||
            action.actionType === 'link' ||
            action.actionType === 'jump') {
            if (!env || !env.jumpTo) {
                throw new Error('env.jumpTo is required!');
            }
            env.jumpTo(filter((action.to || action.url || action.link), ctx, '| raw'), action, ctx);
        }
        else if (action.actionType === 'email') {
            var mailTo = filter(action.to, ctx);
            var mailInfo = mapValues(pick(action, 'to', 'cc', 'bcc', 'subject', 'body'), function (val) { return filter(val, ctx); });
            var mailStr = qs.stringify(mailInfo);
            var mailto = "mailto:".concat(mailTo, "?").concat(mailStr);
            window.open(mailto);
        }
        else if (action.actionType === 'dialog') {
            store.setCurrentAction(action, this.props.resolveDefinitions);
            return new Promise(function (resolve) {
                store.openDialog(ctx, undefined, function (confirmed, value) {
                    var _a;
                    (_a = action.callback) === null || _a === void 0 ? void 0 : _a.call(action, confirmed, value);
                    resolve({
                        confirmed: confirmed,
                        value: value
                    });
                }, delegate || _this.context);
            });
        }
        else if (action.actionType === 'drawer') {
            store.setCurrentAction(action, this.props.resolveDefinitions);
            return new Promise(function (resolve) {
                store.openDrawer(ctx, undefined, function (confirmed, value) {
                    var _a;
                    (_a = action.callback) === null || _a === void 0 ? void 0 : _a.call(action, confirmed, value);
                    resolve({
                        confirmed: confirmed,
                        value: value
                    });
                }, delegate);
            });
        }
        else if (action.actionType === 'toast') {
            (_b = (_a = action.toast) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.forEach(function (_a) {
                var level = _a.level, body = _a.body, title = _a.title, item = __rest(_a, ["level", "body", "title"]);
                env.notify(level || 'info', body
                    ? render('body', body, __assign(__assign({}, _this.props), { data: ctx, context: store.context }))
                    : '', __assign(__assign(__assign({}, action.toast), item), { title: title
                        ? render('title', title, __assign(__assign({}, _this.props), { data: ctx, context: store.context }))
                        : null, mobileUI: mobileUI }));
            });
        }
        else if (action.actionType === 'ajax') {
            store.setCurrentAction(action, this.props.resolveDefinitions);
            store
                .saveRemote(action.api, ctx, {
                successMessage: (action.messages && action.messages.success) ||
                    (messages && messages.saveSuccess),
                errorMessage: (action.messages && action.messages.failed) ||
                    (messages && messages.saveSuccess)
            })
                .then(function () { return __awaiter(_this, void 0, void 0, function () {
                var redirect;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(action.feedback && isVisible(action.feedback, store.data))) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.openFeedback(action.feedback, store.data)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            redirect = action.redirect && filter(action.redirect, store.data);
                            redirect && env.jumpTo(redirect, action, store.data);
                            action.reload &&
                                this.reloadTarget(delegate || this.context, filterTarget(action.reload, ctx), store.data);
                            return [2 /*return*/];
                    }
                });
            }); })
                .catch(function (e) {
                if (throwErrors || action.countDown) {
                    throw e;
                }
            });
        }
        else if (action.actionType === 'copy' &&
            (action.content || action.copy)) {
            env.copy &&
                env.copy(filter(action.content || action.copy, ctx, '| raw'), {
                    format: action.copyFormat
                });
        }
        else if (action.actionType === 'saveAs') {
            // 使用 saveAs 实现下载
            // 不支持 env，除非以后将 saveAs 代码拷过来改
            var api = normalizeApi(action.api);
            if (typeof api.url === 'string') {
                var fileName = action.fileName || 'data.txt';
                if (!action.fileName && api.url.indexOf('.') !== -1) {
                    fileName = api.url.split('/').pop();
                }
                saveAs(api.url, fileName);
            }
        }
    };
    RootRenderer.prototype.dispatchEvent = function (e, data, renderer, scoped) {
        return dispatchEvent(e, renderer, scoped, data);
    };
    RootRenderer.prototype.handleDialogConfirm = function (values, action) {
        var _a;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var store = this.store;
        if (action.mergeData && values.length === 1 && values[0]) {
            store.updateData(values[0]);
        }
        var dialog = store.action.dialog;
        if (dialog &&
            dialog.onConfirm &&
            dialog.onConfirm.apply(dialog, __spreadArray([values, action], __read(args), false)) === false) {
            return;
        }
        var dialogAction = store.action;
        var reload = (_a = action.reload) !== null && _a !== void 0 ? _a : dialogAction.reload;
        var scoped = store.getDialogScoped() || this.context;
        store.closeDialog(true, values);
        if (reload) {
            scoped.reload(reload, store.data);
        }
    };
    RootRenderer.prototype.handleDialogClose = function (confirmed) {
        if (confirmed === void 0) { confirmed = false; }
        var store = this.store;
        store.closeDialog(confirmed);
    };
    RootRenderer.prototype.handleDrawerConfirm = function (values, action) {
        var _a;
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var store = this.store;
        if (action.mergeData && values.length === 1 && values[0]) {
            store.updateData(values[0]);
        }
        var drawer = store.action.drawer;
        if (drawer &&
            drawer.onConfirm &&
            drawer.onConfirm.apply(drawer, __spreadArray([values, action], __read(args), false)) === false) {
            return;
        }
        var drawerAction = store.action;
        var reload = (_a = action.reload) !== null && _a !== void 0 ? _a : drawerAction.reload;
        var scoped = store.getDrawerScoped() || this.context;
        store.closeDrawer(true, values);
        // 稍等会，等动画结束。
        setTimeout(function () {
            if (reload) {
                scoped.reload(reload, store.data);
            }
        }, 300);
    };
    RootRenderer.prototype.handleDrawerClose = function () {
        var store = this.store;
        store.closeDrawer(false);
    };
    RootRenderer.prototype.openFeedback = function (dialog, ctx) {
        var _this = this;
        return new Promise(function (resolve) {
            var store = _this.store;
            store.setCurrentAction({
                type: 'button',
                actionType: 'dialog',
                dialog: dialog
            }, _this.props.resolveDefinitions);
            store.openDialog(ctx, undefined, function (confirmed) {
                resolve(confirmed);
            }, _this.context);
        });
    };
    RootRenderer.prototype.reloadTarget = function (scoped, target, data) {
        scoped.reload(target, data);
    };
    RootRenderer.prototype.renderRuntimeError = function () {
        var _a;
        var _b = this.props, render = _b.render, rest = __rest(_b, ["render"]);
        var store = this.store;
        return render('error', {
            type: 'alert',
            level: 'danger'
        }, __assign(__assign({}, rest), { topStore: store, body: (React.createElement(React.Fragment, null,
                React.createElement("h3", null, (_a = store.runtimeError) === null || _a === void 0 ? void 0 : _a.toString()),
                React.createElement("pre", null,
                    React.createElement("code", null, store.runtimeErrorStack.componentStack)))) }));
    };
    RootRenderer.prototype.renderSpinner = function () {
        var _a = this.props, render = _a.render, rest = __rest(_a, ["render"]);
        var store = this.store;
        return render('spinner', {
            type: 'spinner'
        }, __assign(__assign({}, rest), { topStore: store, show: store.loading }));
    };
    RootRenderer.prototype.renderError = function () {
        var _a = this.props, render = _a.render, rest = __rest(_a, ["render"]);
        var store = this.store;
        return store.error
            ? render('error', {
                type: 'alert'
            }, __assign(__assign({}, rest), { topStore: this.store, body: store.msg, showCloseButton: true, onClose: store.clearMessage }))
            : null;
    };
    RootRenderer.prototype.renderDialog = function () {
        var _a = this.props, render = _a.render, rest = __rest(_a, ["render"]);
        var store = this.store;
        return render('dialog', __assign(__assign({}, store.dialogSchema), { type: 'dialog' }), __assign(__assign({}, rest), { key: 'dialog', topStore: this.store, data: store.dialogData, context: store.context, onConfirm: this.handleDialogConfirm, onClose: this.handleDialogClose, show: store.dialogOpen, onAction: this.handleAction, dispatchEvent: this.dispatchEvent }));
    };
    RootRenderer.prototype.renderDrawer = function () {
        var _a = this.props, render = _a.render, rest = __rest(_a, ["render"]);
        var store = this.store;
        return render('drawer', __assign(__assign({}, store.drawerSchema), { type: 'drawer' }), __assign(__assign({}, rest), { key: 'drawer', topStore: this.store, data: store.drawerData, context: store.context, onConfirm: this.handleDrawerConfirm, onClose: this.handleDrawerClose, show: store.drawerOpen, onAction: this.handleAction, dispatchEvent: this.dispatchEvent }));
    };
    RootRenderer.prototype.render = function () {
        var _a = this.props, pathPrefix = _a.pathPrefix, schema = _a.schema, render = _a.render; _a.globalVars; var rest = __rest(_a, ["pathPrefix", "schema", "render", "globalVars"]);
        var store = this.store;
        if (store.runtimeError) {
            return this.renderRuntimeError();
        }
        else if (!store.ready) {
            return React.createElement(themedLazyComponent, { className: "RootLoader" });
        }
        return (React.createElement(React.Fragment, null,
            render(pathPrefix, schema, __assign(__assign({}, rest), { topStore: this.store, data: this.store.downStream, context: store.context, onAction: this.handleAction, dispatchEvent: this.dispatchEvent })),
            this.renderSpinner(),
            this.renderError(),
            this.renderDialog(),
            this.renderDrawer()));
    };
    RootRenderer.contextType = ScopedContext;
    RootRenderer = __decorate([
        observer,
        __metadata("design:paramtypes", [Object])
    ], RootRenderer);
    return RootRenderer;
}(React.Component));

export { RootRenderer };
