/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __extends, __assign, __rest, __awaiter, __generator, __values, __decorate, __metadata } from 'tslib';
import difference from 'lodash/difference';
import findLastIndex from 'lodash/findLastIndex';
import omit from 'lodash/omit';
import React from 'react';
import { isValidElementType } from 'react-is';
import themedLazyComponent from './components/LazyComponent.js';
import { resolveRenderer, loadRendererError, loadAsyncRenderer, filterSchema } from './factory.js';
import { asFormItem } from './renderers/Item.js';
import { ScopedContext } from './Scoped.js';
import { DebugWrapper } from './utils/debug.js';
import { getExprProperties } from './utils/filter-schema.js';
import { anyChanged, chainEvents, TestIdBuilder, autobind } from './utils/helper.js';
import { SimpleMap } from './utils/SimpleMap.js';
import { bindEvent, bindGlobalEventForRenderer } from './utils/renderer-event.js';
import { isAlive } from 'mobx-state-tree';
import { reaction } from 'mobx';
import 'amis-formula';
import 'moment';
import { extractObjectChain, createObjectFromChain } from './utils/object.js';
import { resolveVariableAndFilter } from './utils/resolveVariableAndFilter.js';
import './utils/memoryParse.js';
import '@rc-component/mini-decimal';
import 'lodash/isPlainObject';
import './utils/filter.js';
import { mergeStyle, buildStyle } from './utils/style.js';
import { isExpression } from './utils/formula.js';
import { filter, evalExpression } from './utils/tpl.js';
import Animations from './components/Animations.js';
import { observeGlobalVars } from './globalVar.js';
import './utils/api.js';
import 'file-saver';
import './utils/browser.js';
import './utils/ColorScale.js';
import 'lodash/chunk';
import './utils/DataSchema.js';
import './utils/DataScope.js';
import 'react-dom';
import './utils/errors.js';
import 'lodash/isObject';
import './utils/image.js';
import 'lodash/isEqual';
import './utils/resize-sensor.js';
import 'react-overlays/useRootClose';
import 'uncontrollable';
import 'hoist-non-react-statics';
import './utils/validations.js';
import 'lodash/cloneDeep';
import 'lodash/map';
import 'lodash/isEmpty';
import 'lodash/kebabCase';
import './utils/resolveCondition.js';
import './utils/Animation.js';

var RENDERER_TRANSMISSION_OMIT_PROPS = [
    'type',
    'name',
    '$ref',
    'className',
    'style',
    'data',
    'originData',
    'children',
    'ref',
    'visible',
    'loading',
    'visibleOn',
    'hidden',
    'hiddenOn',
    'disabled',
    'disabledOn',
    'static',
    'staticOn',
    'component',
    'detectField',
    'defaultValue',
    'defaultData',
    'required',
    'requiredOn',
    'syncSuperStore',
    'mode',
    'body',
    'id',
    'inputOnly',
    'label',
    'renderLabel',
    'trackExpression',
    'editorSetting',
    'updatePristineAfterStoreDataReInit',
    'source'
];
var componentCache = new SimpleMap();
var SchemaRenderer = /** @class */ (function (_super) {
    __extends(SchemaRenderer, _super);
    function SchemaRenderer(props) {
        var _this = _super.call(this, props) || this;
        _this.rendererKey = '';
        _this.toDispose = [];
        _this.unbindEvent = undefined;
        _this.unbindGlobalEvent = undefined;
        _this.isStatic = undefined;
        _this.refFn = _this.refFn.bind(_this);
        _this.renderChild = _this.renderChild.bind(_this);
        _this.reRender = _this.reRender.bind(_this);
        _this.resolveRenderer(_this.props);
        _this.dispatchEvent = _this.dispatchEvent.bind(_this);
        _this.storeRef = _this.storeRef.bind(_this);
        _this.handleGlobalVarChange = _this.handleGlobalVarChange.bind(_this);
        var schema = props.schema;
        // 监听statusStore更新
        _this.toDispose.push(reaction(function () {
            var _a, _b, _c;
            var id = filter(schema.id, props.data);
            var name = filter(schema.name, props.data);
            return "".concat((_a = props.statusStore.visibleState[id]) !== null && _a !== void 0 ? _a : props.statusStore.visibleState[name]).concat((_b = props.statusStore.disableState[id]) !== null && _b !== void 0 ? _b : props.statusStore.disableState[name]).concat((_c = props.statusStore.staticState[id]) !== null && _c !== void 0 ? _c : props.statusStore.staticState[name]);
        }, function () { return _this.forceUpdate(); }));
        _this.toDispose.push(observeGlobalVars(schema, props.topStore, _this.handleGlobalVarChange));
        return _this;
    }
    SchemaRenderer.prototype.componentWillUnmount = function () {
        var _a, _b;
        this.toDispose.forEach(function (fn) { return fn(); });
        this.toDispose = [];
        (_a = this.unbindEvent) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this.unbindGlobalEvent) === null || _b === void 0 ? void 0 : _b.call(this);
    };
    // 限制：只有 schema 除外的 props 变化，或者 schema 里面的某个成员值发生变化才更新。
    SchemaRenderer.prototype.shouldComponentUpdate = function (nextProps) {
        var props = this.props;
        var list = difference(Object.keys(nextProps), [
            'schema',
            'scope'
        ]);
        if (difference(Object.keys(props), ['schema', 'scope']).length !==
            list.length ||
            anyChanged(list, this.props, nextProps)) {
            return true;
        }
        else {
            var list_1 = Object.keys(nextProps.schema);
            if (Object.keys(props.schema).length !== list_1.length ||
                anyChanged(list_1, props.schema, nextProps.schema)) {
                return true;
            }
        }
        return false;
    };
    SchemaRenderer.prototype.storeRef = function (store) {
        this.subStore = store;
    };
    SchemaRenderer.prototype.handleGlobalVarChange = function () {
        var _this = this;
        var _a, _b;
        var handler = (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.onGlobalVarChanged;
        var topStore = this.props.topStore;
        var chain = extractObjectChain(this.props.data).filter(function (item) { return !item.hasOwnProperty('__isTempGlobalLayer'); });
        var globalLayerIdx = findLastIndex(chain, function (item) {
            return item.hasOwnProperty('global') || item.hasOwnProperty('globalState');
        });
        var globalData = {
            global: topStore.nextGlobalData.global,
            globalState: topStore.nextGlobalData.globalState,
            // 兼容旧的全局变量
            __page: topStore.nextGlobalData.__page,
            appVariables: topStore.nextGlobalData.appVariables,
            __isTempGlobalLayer: true
        };
        if (globalLayerIdx !== -1) {
            chain.splice(globalLayerIdx + 1, 0, globalData);
        }
        var newData = createObjectFromChain(chain);
        // 如果渲染器自己做了实现，且返回 false，则不再继续往下执行
        if ((handler === null || handler === void 0 ? void 0 : handler(this.cRef, this.props.schema, newData)) === false) {
            return;
        }
        // 强制刷新并通过一个临时对象让下发给组件的全局变量更新
        // 等 react 完成一轮渲染后，将临时渲染切成正式渲染
        // 也就是说删掉临时对象，后续渲染读取真正变更后的全局变量
        //
        // 为什么这么做？因为很多组件内部都会 diff  this.props.data 和 prevProps.data
        // 如果对应的数据没有发生变化，则会跳过组件状态的更新
        this.tmpData = newData;
        (_b = this.subStore) === null || _b === void 0 ? void 0 : _b.temporaryUpdateGlobalVars(globalData);
        topStore.addSyncGlobalVarStatePendingTask(function (callback) { return _this.forceUpdate(callback); }, function () {
            var _a;
            delete _this.tmpData;
            (_a = _this.subStore) === null || _a === void 0 ? void 0 : _a.unDoTemporaryUpdateGlobalVars();
        });
    };
    SchemaRenderer.prototype.resolveRenderer = function (props, force) {
        if (force === void 0) { force = false; }
        var schema = props.schema;
        var path = props.$path;
        if (schema && schema.$ref) {
            schema = __assign(__assign({}, props.resolveDefinitions(schema.$ref)), schema);
            path = path.replace(/(?!.*\/).*/, schema.type);
        }
        if ((schema === null || schema === void 0 ? void 0 : schema.type) &&
            (force ||
                !this.renderer ||
                this.rendererKey !== "".concat(schema.type, "-").concat(schema.$$id))) {
            var rendererResolver = props.env.rendererResolver || resolveRenderer;
            this.renderer = rendererResolver(path, schema, props);
            this.rendererKey = "".concat(schema.type, "-").concat(schema.$$id);
        }
        else {
            // 自定义组件如果在节点设置了 label name 什么的，就用 formItem 包一层
            // 至少自动支持了 valdiations, label, description 等逻辑。
            if (schema.children && !schema.component && schema.asFormItem) {
                schema.component = PlaceholderComponent;
                schema.renderChildren = schema.children;
                delete schema.children;
            }
            if (schema.component &&
                !schema.component.wrapedAsFormItem &&
                schema.asFormItem) {
                var cache = componentCache.get(schema.component);
                if (cache) {
                    schema.component = cache;
                }
                else {
                    var cache_1 = asFormItem(__assign({ strictMode: false }, schema.asFormItem))(schema.component);
                    componentCache.set(schema.component, cache_1);
                    cache_1.wrapedAsFormItem = true;
                    schema.component = cache_1;
                }
            }
        }
        return { path: path, schema: schema };
    };
    SchemaRenderer.prototype.getWrappedInstance = function () {
        return this.cRef;
    };
    SchemaRenderer.prototype.refFn = function (ref) {
        this.ref = ref;
    };
    SchemaRenderer.prototype.childRef = function (ref) {
        var _this = this;
        var _a, _b, _c;
        // todo 这里有个问题，就是注意以下的这段注释
        // > // 原来表单项的 visible: false 和 hidden: true 表单项的值和验证是有效的
        // > 而 visibleOn 和 hiddenOn 是无效的，
        // > 这个本来就是个bug，但是已经被广泛使用了
        // > 我只能继续实现这个bug了
        // 这样会让子组件去根据是 hidden 的情况去渲染个 null，这样会导致这里 ref 有值，但是 ref.getWrappedInstance() 为 null
        // 这样会和直接渲染的组件时有些区别，至少 cRef 的指向是不一样的
        while ((_a = ref === null || ref === void 0 ? void 0 : ref.getWrappedInstance) === null || _a === void 0 ? void 0 : _a.call(ref)) {
            ref = ref.getWrappedInstance();
        }
        if (ref && !ref.props) {
            Object.defineProperty(ref, 'props', {
                get: function () { return _this.props; }
            });
        }
        if (ref) {
            // 这里无法区分监听的是不是广播，所以又bind一下，主要是为了绑广播
            (_b = this.unbindEvent) === null || _b === void 0 ? void 0 : _b.call(this);
            (_c = this.unbindGlobalEvent) === null || _c === void 0 ? void 0 : _c.call(this);
            this.unbindEvent = bindEvent(ref);
            this.unbindGlobalEvent = bindGlobalEventForRenderer(ref);
        }
        this.cRef = ref;
    };
    SchemaRenderer.prototype.dispatchEvent = function (e, data, renderer, // for didmount
    scoped) {
        return this.props.dispatchEvent(e, data, renderer || this.cRef, scoped || this.context);
    };
    SchemaRenderer.prototype.renderChild = function (region, node, subProps) {
        var _a, _b, _c, _d;
        if (subProps === void 0) { subProps = {}; }
        var _e = this.props, _ = _e.schema; _e.$path; var env = _e.env, render = _e.render, rest = __rest(_e, ["schema", "$path", "env", "render"]);
        var $path = this.resolveRenderer(this.props).path;
        var omitList = RENDERER_TRANSMISSION_OMIT_PROPS.concat();
        if (this.renderer) {
            var Component = this.renderer.component;
            (Component === null || Component === void 0 ? void 0 : Component.propsList) &&
                omitList.push.apply(omitList, Component.propsList);
        }
        return render("".concat($path).concat(region ? "/".concat(region) : ''), node || '', __assign(__assign(__assign(__assign({}, omit(rest, omitList)), { defaultStatic: (_c = (_b = (((_a = this.renderer) === null || _a === void 0 ? void 0 : _a.type) &&
                ['drawer', 'dialog'].includes(this.renderer.type)
                ? false
                : undefined)) !== null && _b !== void 0 ? _b : this.isStatic) !== null && _c !== void 0 ? _c : (_.staticOn
                ? evalExpression(_.staticOn, rest.data)
                : (_d = _.static) !== null && _d !== void 0 ? _d : rest.defaultStatic) }), subProps), { data: this.tmpData && subProps.data === this.props.data
                ? this.tmpData
                : subProps.data || rest.data, env: env }));
    };
    SchemaRenderer.prototype.reRender = function () {
        this.resolveRenderer(this.props, true);
        this.forceUpdate();
    };
    SchemaRenderer.prototype.render = function () {
        var e_1, _a;
        var _this = this;
        var _b, _c, _d, _e, _f, _g, _h;
        var _j = this.props; _j.$path; var __ = _j.schema, rootStore = _j.rootStore, statusStore = _j.statusStore, render = _j.render, rest = __rest(_j, ["$path", "schema", "rootStore", "statusStore", "render"]);
        if (__ == null) {
            return null;
        }
        var _k = this.resolveRenderer(this.props), $path = _k.path, schema = _k.schema;
        var theme = this.props.env.theme;
        if (Array.isArray(schema)) {
            return render($path, schema, rest);
        }
        // 用于全局变量刷新
        rest.data = this.tmpData || rest.data;
        var detectData = schema &&
            (schema.detectField === '&' ? rest : rest[schema.detectField || 'data']);
        var exprProps = detectData
            ? getExprProperties(schema, detectData, undefined, rest)
            : {};
        // 控制显隐
        var id = filter(schema.id, rest.data);
        var name = filter(schema.name, rest.data);
        var visible = isAlive(statusStore)
            ? (_b = statusStore.visibleState[id]) !== null && _b !== void 0 ? _b : statusStore.visibleState[name]
            : undefined;
        var disable = isAlive(statusStore)
            ? (_c = statusStore.disableState[id]) !== null && _c !== void 0 ? _c : statusStore.disableState[name]
            : undefined;
        var isStatic = isAlive(statusStore)
            ? (_d = statusStore.staticState[id]) !== null && _d !== void 0 ? _d : statusStore.staticState[name]
            : undefined;
        this.isStatic = isStatic;
        if (visible === false ||
            (visible !== true &&
                exprProps &&
                (exprProps.hidden ||
                    exprProps.visible === false ||
                    schema.hidden ||
                    schema.visible === false ||
                    rest.hidden ||
                    rest.visible === false))) {
            rest.invisible = true;
        }
        if (schema.children) {
            return rest.invisible
                ? null
                : React.isValidElement(schema.children)
                    ? schema.children
                    : typeof schema.children !== 'function'
                        ? null
                        : schema.children(__assign(__assign(__assign({}, rest), exprProps), { $path: $path, $schema: schema, render: this.renderChild, forwardedRef: this.refFn, rootStore: rootStore, statusStore: statusStore, dispatchEvent: this.dispatchEvent }));
        }
        else if (schema.component && isValidElementType(schema.component)) {
            var isSFC = !(schema.component.prototype instanceof React.Component);
            var defaultData_1 = schema.data, defaultValue_1 = schema.value, // render时的value改放defaultValue中
            defaultActiveKey_1 = schema.activeKey, propKey_1 = schema.key, restSchema_1 = __rest(schema, ["data", "value", "activeKey", "key"]);
            return rest.invisible
                ? null
                : React.createElement(schema.component, __assign(__assign(__assign(__assign({}, rest), restSchema_1), exprProps), { 
                    // value: defaultValue, // 备注: 此处并没有将value传递给渲染器
                    defaultData: defaultData_1, defaultValue: defaultValue_1, defaultActiveKey: defaultActiveKey_1, propKey: propKey_1, $path: $path, $schema: schema, ref: isSFC ? undefined : this.refFn, forwardedRef: isSFC ? this.refFn : undefined, render: this.renderChild, rootStore: rootStore, statusStore: statusStore, dispatchEvent: this.dispatchEvent }));
        }
        else if (Object.keys(schema).length === 0) {
            return null;
        }
        else if (!this.renderer) {
            return rest.invisible ? null : (React.createElement(themedLazyComponent, { defaultVisible: true, getComponent: function () { return __awaiter(_this, void 0, void 0, function () {
                    var result;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, rest.env.loadRenderer(schema, $path, this.reRender)];
                            case 1:
                                result = _a.sent();
                                if (result && typeof result === 'function') {
                                    return [2 /*return*/, result];
                                }
                                else if (result && React.isValidElement(result)) {
                                    return [2 /*return*/, function () { return result; }];
                                }
                                this.reRender();
                                return [2 /*return*/, function () { return loadRendererError(schema, $path); }];
                        }
                    });
                }); } }));
        }
        else if (this.renderer.getComponent && !this.renderer.component) {
            // 处理异步渲染器
            return rest.invisible ? null : (React.createElement(themedLazyComponent, { defaultVisible: true, getComponent: function () { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, loadAsyncRenderer(this.renderer)];
                            case 1:
                                _a.sent();
                                this.reRender();
                                return [2 /*return*/, function () { return null; }];
                        }
                    });
                }); } }));
        }
        var renderer = this.renderer;
        schema = filterSchema(schema, renderer, rest);
        var defaultData = schema.data, defaultValue = schema.value, defaultActiveKey = schema.activeKey, propKey = schema.key, restSchema = __rest(schema, ["data", "value", "activeKey", "key"]);
        var Component = renderer.component;
        var animationShow = true;
        // 原来表单项的 visible: false 和 hidden: true 表单项的值和验证是有效的
        // 而 visibleOn 和 hiddenOn 是无效的，
        // 这个本来就是个bug，但是已经被广泛使用了
        // 我只能继续实现这个bug了
        if (rest.invisible &&
            (exprProps.hidden ||
                exprProps.visible === false ||
                !renderer.isFormItem ||
                (schema.visible !== false && !schema.hidden))) {
            if (schema.animations) {
                animationShow = false;
            }
            else {
                return null;
            }
        }
        // withStore 里面会处理，而且会实时处理
        // 这里处理反而导致了问题
        if (renderer.storeType) {
            exprProps = {};
        }
        var supportRef = ((_e = Component.prototype) === null || _e === void 0 ? void 0 : _e.isReactComponent) ||
            Component.$$typeof === Symbol.for('react.forward_ref');
        var props = __assign(__assign(__assign(__assign(__assign(__assign({}, (_f = renderer.defaultProps) === null || _f === void 0 ? void 0 : _f.call(renderer, schema.type, schema)), theme.getRendererConfig(renderer.name)), restSchema), chainEvents(rest, restSchema)), exprProps), { 
            // value: defaultValue, // 备注: 此处并没有将value传递给渲染器
            defaultData: (_g = restSchema.defaultData) !== null && _g !== void 0 ? _g : defaultData, defaultValue: (_h = restSchema.defaultValue) !== null && _h !== void 0 ? _h : defaultValue, defaultActiveKey: defaultActiveKey, propKey: propKey, $path: $path, $schema: schema, render: this.renderChild, rootStore: rootStore, statusStore: statusStore, dispatchEvent: this.dispatchEvent, mobileUI: schema.useMobileUI === false ? false : rest.mobileUI });
        // style 支持公式
        if (schema.style) {
            props.style = mergeStyle(props.style, buildStyle(schema.style, detectData));
        }
        if (disable !== undefined) {
            props.disabled = disable;
        }
        if (isStatic !== undefined) {
            props.static = isStatic;
        }
        // 优先使用组件自己的testid或者id，这个解决不了table行内的一些子元素
        // 每一行都会出现这个testid的元素，只在测试工具中直接使用nth拿序号
        if (rest.env.enableTestid) {
            if (props.testid || props.id || props.testIdBuilder == null) {
                if (!(props.testIdBuilder instanceof TestIdBuilder)) {
                    props.testIdBuilder = new TestIdBuilder(props.testid || props.id);
                }
            }
        }
        // 自动解析变量模式，主要是方便直接引入第三方组件库，无需为了支持变量封装一层
        if (renderer.autoVar) {
            try {
                for (var _l = __values(Object.keys(schema)), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var key = _m.value;
                    if (typeof props[key] === 'string' && isExpression(props[key])) {
                        props[key] = resolveVariableAndFilter(props[key], props.data, '| raw');
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var component = supportRef ? (React.createElement(Component, __assign({}, props, { ref: this.childRef, storeRef: this.storeRef }))) : (React.createElement(Component, __assign({}, props, { forwardedRef: this.childRef, storeRef: this.storeRef })));
        if (schema.animations) {
            component = (React.createElement(Animations, { schema: schema, component: component, show: animationShow }));
        }
        return this.props.env.enableAMISDebug ? (React.createElement(DebugWrapper, { renderer: renderer }, component)) : (component);
    };
    SchemaRenderer.displayName = 'Renderer';
    SchemaRenderer.contextType = ScopedContext;
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], SchemaRenderer.prototype, "childRef", null);
    return SchemaRenderer;
}(React.Component));
var PlaceholderComponent = /** @class */ (function (_super) {
    __extends(PlaceholderComponent, _super);
    function PlaceholderComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.childRef = React.createRef();
        return _this;
    }
    PlaceholderComponent.prototype.getWrappedInstance = function () {
        return this.childRef.current;
    };
    PlaceholderComponent.prototype.render = function () {
        var _a = this.props, renderChildren = _a.renderChildren, rest = __rest(_a, ["renderChildren"]);
        if (typeof renderChildren === 'function') {
            return renderChildren(__assign(__assign({}, rest), { ref: this.childRef }));
        }
        return null;
    };
    return PlaceholderComponent;
}(React.Component));

export { RENDERER_TRANSMISSION_OMIT_PROPS, SchemaRenderer };
