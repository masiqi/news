/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __read } from 'tslib';
import ReactDOM from 'react-dom';
import React from 'react';
import { offset } from './offset.js';
import { position } from './position.js';
import { getScrollParent } from './helper.js';

function getContainer(container, defaultContainer) {
    container = typeof container === 'function' ? container() : container;
    return ReactDOM.findDOMNode(container) || defaultContainer;
}
function ownerDocument(componentOrElement) {
    var _a;
    return (((_a = ReactDOM.findDOMNode(componentOrElement)) === null || _a === void 0 ? void 0 : _a.ownerDocument) ||
        document);
}
function getContainerDimensions(containerNode) {
    var _a;
    var width, height, scroll;
    if (containerNode.tagName === 'BODY') {
        width = window.innerWidth;
        height = window.innerHeight;
        scroll =
            ownerDocument(containerNode).documentElement.scrollTop ||
                (containerNode === null || containerNode === void 0 ? void 0 : containerNode.scrollTop);
    }
    else {
        (_a = offset(containerNode), width = _a.width, height = _a.height);
        scroll = containerNode.scrollTop;
    }
    return { width: width, height: height, scroll: scroll };
}
function getTopDelta(top, overlayHeight, container, padding) {
    var containerDimensions = getContainerDimensions(container);
    var containerScroll = containerDimensions.scroll;
    var containerHeight = containerDimensions.height;
    var topEdgeOffset = top - padding - containerScroll;
    var bottomEdgeOffset = top + padding - containerScroll + overlayHeight;
    if (topEdgeOffset < 0) {
        return -topEdgeOffset;
    }
    else if (bottomEdgeOffset > containerHeight) {
        return containerHeight - bottomEdgeOffset;
    }
    else {
        return 0;
    }
}
function getLeftDelta(left, overlayWidth, container, padding) {
    var containerDimensions = getContainerDimensions(container);
    var containerWidth = containerDimensions.width;
    var leftEdgeOffset = left - padding;
    var rightEdgeOffset = left + padding + overlayWidth;
    if (leftEdgeOffset < 0) {
        return -leftEdgeOffset;
    }
    else if (rightEdgeOffset > containerWidth) {
        return containerWidth - rightEdgeOffset;
    }
    return 0;
}
function calculatePosition(placement, overlayNode, target, container, padding, customOffset) {
    var _a;
    if (padding === void 0) { padding = 0; }
    if (customOffset === void 0) { customOffset = [0, 0]; }
    var scrollParent = getScrollParent(container);
    var childOffset = container.tagName === 'BODY'
        ? offset(target)
        : position(target, container);
    var _b = offset(overlayNode), overlayHeight = _b.height, overlayWidth = _b.width;
    var clip = container.getBoundingClientRect();
    var clip2 = overlayNode.getBoundingClientRect();
    var clip3 = scrollParent.getBoundingClientRect();
    var scaleX = overlayNode.offsetWidth
        ? clip2.width / overlayNode.offsetWidth
        : 1;
    var scaleY = overlayNode.offsetHeight
        ? clip2.height / overlayNode.offsetHeight
        : 1;
    // auto 尝试四个方向对齐。
    var isAuto = placement === 'auto';
    // 兜底方向
    var autoDefaultPlacement = 'left-bottom-left-top';
    placement = isAuto
        ? "left-bottom-left-top right-bottom-right-top left-top-left-bottom right-top-right-bottom ".concat(autoDefaultPlacement)
        : placement;
    var positionLeft = 0, positionTop = 0, arrowOffsetLeft = '', arrowOffsetTop = '', activePlacement = placement;
    // 如果是作为菜单浮层，不再基于四个方向对齐，而是模拟原生右键菜单定位：
    // 1.计算放右边，还是左边
    // 2.计算能否放在下面，如果不能则贴底
    // 3.由于是基于一个点此时不考虑 arrow
    if (placement === 'asContextMenu') {
        if (childOffset.left + 1 + overlayWidth <= clip.width) {
            // 放右边
            positionLeft = childOffset.left + 1;
        }
        else if (childOffset.left - overlayWidth >= 0) {
            // 放左边
            positionLeft = childOffset.left - overlayWidth;
        }
        else {
            // 兜底贴右边
            positionLeft = Math.max(clip.width - overlayWidth, 10);
        }
        if (childOffset.top + 1 + overlayHeight <= clip.height) {
            // 放下面
            positionTop = childOffset.top + 1;
        }
        else {
            // 贴底边，预留5px避免完全贴底
            positionTop = Math.max(clip.height - overlayHeight - 5, 10);
        }
        var _c = __read(customOffset, 2), _d = _c[0], offSetX_1 = _d === void 0 ? 0 : _d, _e = _c[1], offSetY_1 = _e === void 0 ? 0 : _e;
        return {
            positionLeft: (positionLeft + offSetX_1) / scaleX,
            positionTop: (positionTop + offSetY_1) / scaleY,
            arrowOffsetLeft: arrowOffsetLeft,
            arrowOffsetTop: arrowOffsetTop,
            activePlacement: activePlacement
        };
    }
    if (~placement.indexOf('-')) {
        var tests = placement.split(/\s+/);
        // 收集可见方向
        var visiblePlacement = {};
        while (tests.length) {
            var current = (activePlacement = tests.shift());
            // 自动对齐模式下，当四个方向都无法完全可见时
            // 根据之前的计算结果，使用收集的可见方向作为兜底，避免完全不可见
            if (isAuto && tests.length === 0) {
                var _f = __read(autoDefaultPlacement.split('-'), 4), _atX = _f[0], _atY = _f[1], _myX = _f[2], _myY = _f[3];
                var _g = visiblePlacement.atX, atX_1 = _g === void 0 ? _atX : _g, _h = visiblePlacement.atY, atY_1 = _h === void 0 ? _atY : _h, _j = visiblePlacement.myX, myX_1 = _j === void 0 ? _myX : _j, _k = visiblePlacement.myY, myY_1 = _k === void 0 ? _myY : _k;
                current = activePlacement = [atX_1, atY_1, myX_1, myY_1].join('-');
            }
            var _l = __read(current.split('-'), 4), atX = _l[0], atY = _l[1], myX = _l[2], myY = _l[3];
            myX = myX || atX;
            myY = myY || atY;
            positionLeft =
                atX === 'left'
                    ? childOffset.left
                    : atX === 'right'
                        ? childOffset.left + childOffset.width
                        : childOffset.left + childOffset.width / 2;
            positionTop =
                atY === 'top'
                    ? childOffset.top
                    : atY === 'bottom'
                        ? childOffset.top + childOffset.height
                        : childOffset.top + childOffset.height / 2;
            positionLeft -=
                myX === 'left' ? 0 : myX === 'right' ? overlayWidth : overlayWidth / 2;
            positionTop -=
                myY === 'top'
                    ? 0
                    : myY === 'bottom'
                        ? overlayHeight
                        : overlayHeight / 2;
            // 需考虑 iframe 之外的高度，并不属于可视区域
            var scrollParentOffset = positionTop < 0 && window.self !== window.top ? clip3.y : 0;
            // 如果还有其他可选项，则做位置判断，是否在可视区域，不完全在则继续看其他定位情况。
            if (tests.length || isAuto) {
                var transformed = {
                    x: clip.x + positionLeft / scaleX,
                    y: clip.y - scrollParentOffset + positionTop / scaleY,
                    width: overlayWidth,
                    height: overlayHeight
                };
                var visibleX = false;
                var visibleY = false;
                if (transformed.x >= 0 &&
                    transformed.x + transformed.width <
                        window.innerWidth + scrollParent.scrollLeft) {
                    visibleX = true;
                    !visiblePlacement.atX && (visiblePlacement.atX = atX);
                    !visiblePlacement.myX && (visiblePlacement.myX = myX);
                }
                if (transformed.y >= 0 &&
                    transformed.y + transformed.height <
                        window.innerHeight + scrollParent.scrollTop) {
                    visibleY = true;
                    !visiblePlacement.atY && (visiblePlacement.atY = atY);
                    !visiblePlacement.myY && (visiblePlacement.myY = myY);
                }
                if (visibleX && visibleY) {
                    break;
                }
                else if (isAuto && tests.length === 0) {
                    // 获取相对定位的父元素位置
                    var offsetParent = overlayNode.offsetParent;
                    while (offsetParent &&
                        window.getComputedStyle(offsetParent).position === 'static') {
                        offsetParent = offsetParent.offsetParent;
                    }
                    var parentRect = (_a = offsetParent === null || offsetParent === void 0 ? void 0 : offsetParent.getBoundingClientRect) === null || _a === void 0 ? void 0 : _a.call(offsetParent);
                    var parentTransformed = {
                        x: (parentRect === null || parentRect === void 0 ? void 0 : parentRect.x) || 0,
                        y: (parentRect === null || parentRect === void 0 ? void 0 : parentRect.y) || 0
                    };
                    // 如果是 auto 模式，且最后一个方向都不可见，则直接平移到可见区域，考虑相对定位的父元素位置，保留10px的边距
                    visibleY ||
                        (positionTop =
                            Math.max(10, window.innerHeight - transformed.height) +
                                scrollParent.scrollTop -
                                parentTransformed.y -
                                10);
                    visibleX ||
                        (positionLeft =
                            Math.max(10, window.innerWidth - transformed.width) +
                                scrollParent.scrollLeft -
                                parentTransformed.x);
                }
            }
        }
        // todo arrow 位置支持
    }
    else if (placement === 'left' || placement === 'right') {
        // atX = placement;
        // atY = myY = 'center';
        // myX = placement === 'left' ? 'right' : 'left';
        if (placement === 'left') {
            positionLeft = childOffset.left - overlayWidth;
        }
        else {
            positionLeft = childOffset.left + childOffset.width;
        }
        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;
        var topDelta = getTopDelta(positionTop, overlayHeight, container, padding);
        positionTop += topDelta;
        arrowOffsetTop = 50 * (1 - (2 * topDelta) / overlayHeight) + '%';
    }
    else if (placement === 'top' || placement === 'bottom') {
        // atY = placement;
        // atX = myX = 'center';
        // myY = placement === 'top' ? 'bottom': 'top';
        if (placement === 'top') {
            positionTop = childOffset.top - overlayHeight;
        }
        else {
            positionTop = childOffset.top + childOffset.height;
        }
        positionLeft = childOffset.left + (childOffset.width - overlayWidth) / 2;
        var leftDelta = getLeftDelta(positionLeft, overlayWidth, container, padding);
        positionLeft += leftDelta;
        arrowOffsetLeft = 50 * (1 - (2 * leftDelta) / overlayHeight) + '%';
    }
    else if (placement === 'center') {
        // atX = atY = myX = myY = 'center';
        positionLeft = childOffset.left + (childOffset.width - overlayWidth) / 2;
        positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;
        arrowOffsetLeft = arrowOffsetTop = void 0;
    }
    else {
        throw new Error("calcOverlayPosition(): No such placement of \"".concat(placement, "\" found."));
    }
    var _m = __read(customOffset, 2), _o = _m[0], offSetX = _o === void 0 ? 0 : _o, _p = _m[1], offSetY = _p === void 0 ? 0 : _p;
    return {
        positionLeft: (positionLeft + offSetX) / scaleX,
        positionTop: (positionTop + offSetY) / scaleY,
        arrowOffsetLeft: (arrowOffsetLeft + offSetX) / scaleX,
        arrowOffsetTop: (arrowOffsetTop + offSetY) / scaleY,
        activePlacement: activePlacement
    };
}
/**
 * 专门用来获取样式的像素值，默认返回 0
 */
function getStyleNumber(element, styleName) {
    if (!element) {
        return 0;
    }
    return parseFloat(getComputedStyle(element).getPropertyValue(styleName)) || 0;
}
/** 根据关键字高亮显示文本内容 */
function renderTextByKeyword(rendererText, curKeyword) {
    if (!rendererText || typeof rendererText !== 'string') {
        return rendererText;
    }
    if (curKeyword && ~rendererText.indexOf(curKeyword)) {
        var keywordStartIndex = rendererText.indexOf(curKeyword);
        var keywordEndIndex = keywordStartIndex + curKeyword.length;
        return (React.createElement("span", null,
            rendererText.substring(0, keywordStartIndex),
            React.createElement("span", { className: "is-keyword" }, curKeyword),
            rendererText.substring(keywordEndIndex)));
    }
    else {
        return rendererText;
    }
}
// 计算除去某个元素后，父元素剩余部分的高度总和（padding、margin、border、height）
function calculateHeight(element, excludeElement) {
    var parentRect = element.getBoundingClientRect();
    var childRect = excludeElement.getBoundingClientRect();
    var topDifference = Math.abs(childRect.top - parentRect.top);
    var bottomDifference = 0;
    var selfNode = excludeElement;
    var parentNode = selfNode.parentElement;
    while (parentNode) {
        var paddingBottom = getStyleNumber(parentNode, 'padding-bottom');
        var borderBottom = getStyleNumber(parentNode, 'border-bottom-width');
        var nextSiblingHeight = 0;
        var nextSibling = selfNode.nextElementSibling;
        while (nextSibling) {
            var positon = getComputedStyle(nextSibling).position;
            var className = nextSibling.className;
            if (positon !== 'absolute' &&
                positon !== 'fixed' &&
                !className.includes('Spinner') // 过滤掉Loading
            ) {
                var rect1 = selfNode.getBoundingClientRect();
                var rect2 = nextSibling.getBoundingClientRect();
                if (rect1.bottom <= rect2.top) {
                    nextSiblingHeight +=
                        nextSibling.offsetHeight +
                            getStyleNumber(nextSibling, 'margin-bottom');
                }
            }
            nextSibling = nextSibling.nextElementSibling;
        }
        var marginBottom = getStyleNumber(selfNode, 'margin-bottom');
        bottomDifference +=
            paddingBottom + borderBottom + marginBottom + nextSiblingHeight;
        selfNode = parentNode;
        parentNode = selfNode.parentElement;
        if (element === selfNode) {
            break;
        }
    }
    return topDifference + bottomDifference;
}

export { calculateHeight, calculatePosition, getContainer, getStyleNumber, ownerDocument, renderTextByKeyword };
