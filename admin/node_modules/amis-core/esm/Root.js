/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

import { __extends, __rest, __assign, __decorate, __metadata } from 'tslib';
import React from 'react';
import isPlainObject from 'lodash/isPlainObject';
import { LocaleContext } from './locale.js';
import { RootRenderer } from './RootRenderer.js';
import { SchemaRenderer } from './SchemaRenderer.js';
import { HocScoped } from './Scoped.js';
import { ThemeContext } from './theme.js';
import { isEmpty, autobind } from './utils/helper.js';
import { RootStoreContext } from './WithRootStore.js';
import { StatusScopedWrapper, StatusScoped } from './StatusScoped.js';

var rootWrappers = [];
function addRootWrapper(fn) {
    rootWrappers.push(fn);
}
var Root = /** @class */ (function (_super) {
    __extends(Root, _super);
    function Root() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Root.prototype.resolveDefinitions = function (name) {
        var definitions = this.props.schema.definitions;
        if (!name || isEmpty(definitions)) {
            return {};
        }
        return definitions && definitions[name];
    };
    Root.prototype.render = function () {
        var _a = this.props, schema = _a.schema, rootStore = _a.rootStore, env = _a.env, pathPrefix = _a.pathPrefix, location = _a.location, data = _a.data, context = _a.context, locale = _a.locale, translate = _a.translate, rest = __rest(_a, ["schema", "rootStore", "env", "pathPrefix", "location", "data", "context", "locale", "translate"]);
        var theme = env.theme;
        var themeName = this.props.theme || 'cxd';
        if (themeName === 'default') {
            themeName = 'cxd';
        }
        return (React.createElement(RootStoreContext.Provider, { value: rootStore },
            React.createElement(ThemeContext.Provider, { value: themeName },
                React.createElement(LocaleContext.Provider, { value: this.props.locale }, rootWrappers.reduce(function (props, wrapper) {
                    return __assign(__assign({}, props), { children: wrapper(props) });
                }, __assign(__assign({ pathPrefix: pathPrefix || '', schema: isPlainObject(schema)
                        ? __assign({ type: 'page' }, schema) : schema }, rest), { render: renderChild, rootStore: rootStore, resolveDefinitions: this.resolveDefinitions, location: location, data: data, env: env, classnames: theme.classnames, classPrefix: theme.classPrefix, locale: locale, translate: translate, children: (React.createElement(RootRenderer, __assign({ pathPrefix: pathPrefix || '', schema: isPlainObject(schema)
                            ? __assign({ type: 'page' }, schema) : schema }, rest, { render: renderChild, rootStore: rootStore, resolveDefinitions: this.resolveDefinitions, location: location, data: data, context: context, env: env, classnames: theme.classnames, classPrefix: theme.classPrefix, locale: locale, translate: translate }))) })).children))));
    };
    __decorate([
        autobind,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], Root.prototype, "resolveDefinitions", null);
    return Root;
}(React.Component));
function renderChildren(prefix, node, props) {
    if (Array.isArray(node)) {
        var elemKey = props.key || props.propKey || props.id || '';
        return node.map(function (node, index) {
            return renderChild("".concat(prefix, "/").concat(index), node, __assign(__assign({}, props), { key: "".concat(elemKey ? "".concat(elemKey, "-") : '').concat(index) }));
        });
    }
    return renderChild(prefix, node, props);
}
function renderChild(prefix, node, props) {
    var _a;
    if (Array.isArray(node)) {
        return renderChildren(prefix, node, props);
    }
    var typeofnode = typeof node;
    if (typeofnode === 'undefined' || node === null) {
        return null;
    }
    else if (React.isValidElement(node)) {
        return node;
    }
    var schema = typeofnode === 'string' || typeofnode === 'number'
        ? { type: 'tpl', tpl: String(node) }
        : node;
    var transform = props.propsTransform;
    if (transform) {
        props = __assign({}, props);
        delete props.propsTransform;
        props = transform(props);
    }
    var Comp = props.env.SchemaRenderer || SchemaRenderer;
    if (['dialog', 'drawer'].includes(schema === null || schema === void 0 ? void 0 : schema.type) &&
        !(schema === null || schema === void 0 ? void 0 : schema.component) &&
        !(schema === null || schema === void 0 ? void 0 : schema.children)) {
        // 因为状态判断实在 SchemaRenderer 里面判断的
        // 找渲染器也是在那，所以没办法在之前根据渲染器信息来包裹个组件下发 statusStore
        // 所以这里先根据 type 来处理一下
        // 等后续把状态处理再抽一层，可以把此处放到 SchemaRenderer 里面去
        return (React.createElement(StatusScopedWrapper, null, function (_a) {
            var _b;
            var statusStore = _a.statusStore;
            return (React.createElement(Comp, __assign({ render: renderChild }, props, { key: (_b = props.key) !== null && _b !== void 0 ? _b : schema.key, schema: schema, propKey: schema.key, "$path": "".concat(prefix ? "".concat(prefix, "/") : '').concat((schema && schema.type) || ''), statusStore: statusStore })));
        }));
    }
    return (React.createElement(Comp, __assign({ render: renderChild }, props, { key: (_a = props.key) !== null && _a !== void 0 ? _a : schema.key, schema: schema, propKey: schema.key, "$path": "".concat(prefix ? "".concat(prefix, "/") : '').concat((schema && schema.type) || '') })));
}
var ScopedRootRenderer = StatusScoped(HocScoped(Root));

export { Root, addRootWrapper, ScopedRootRenderer as default, renderChild, renderChildren };
