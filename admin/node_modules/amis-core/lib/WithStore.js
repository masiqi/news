/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var hoistNonReactStatic = require('hoist-non-react-statics');
var mobx = require('mobx');
var mobxReact = require('mobx-react');
var mobxStateTree = require('mobx-state-tree');
var React = require('react');
var filterSchema = require('./utils/filter-schema.js');
var helper = require('./utils/helper.js');
require('amis-formula');
require('moment');
var object = require('./utils/object.js');
var tokenize = require('./utils/tokenize.js');
require('./utils/memoryParse.js');
require('@rc-component/mini-decimal');
var dataMapping = require('./utils/dataMapping.js');
require('./utils/filter.js');
var WithRootStore = require('./WithRootStore.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var hoistNonReactStatic__default = /*#__PURE__*/_interopDefaultLegacy(hoistNonReactStatic);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
/**
 * 忽略静态数据中的 schema 属性
 *
 * 比如 https://github.com/baidu/amis/issues/8972 中的用法
 */
function ignoreSchemaProps(key, value) {
    if (['clickAction'].includes(key) && typeof value !== 'string') {
        return true;
    }
    return false;
}
function HocStoreFactory(renderer) {
    return function (Component) {
        var StoreFactory = /** @class */ (function (_super) {
            tslib.__extends(StoreFactory, _super);
            function StoreFactory(props, context) {
                var _this = this;
                var _a;
                _this = _super.call(this, props) || this;
                var rootStore = context;
                _this.renderChild = _this.renderChild.bind(_this);
                _this.refFn = _this.refFn.bind(_this);
                var store = rootStore.addStore({
                    id: helper.guid(),
                    path: _this.props.$path,
                    storeType: renderer.storeType,
                    parentId: _this.props.store ? _this.props.store.id : ''
                });
                store.setTopStore(props.topStore);
                (_a = props.storeRef) === null || _a === void 0 ? void 0 : _a.call(props, store);
                _this.store = store;
                var extendsData = typeof renderer.extendsData === 'function'
                    ? renderer.extendsData(props)
                    : renderer.extendsData;
                if (extendsData === false) {
                    store.initData(object.createObject(_this.props.data
                        ? _this.props.data.__super
                        : null, tslib.__assign(tslib.__assign({}, _this.formatData(dataMapping.dataMapping(_this.props.defaultData, _this.props.data, ignoreSchemaProps))), _this.formatData(_this.props.data))));
                }
                else if (_this.props.scope ||
                    (_this.props.data && _this.props.data.__super)) {
                    if (_this.props.store && _this.props.data === _this.props.scope) {
                        store.initData(object.createObject(_this.props.store.data, tslib.__assign({}, _this.formatData(dataMapping.dataMapping(_this.props.defaultData, _this.props.data, ignoreSchemaProps)))));
                    }
                    else {
                        store.initData(object.createObject(_this.props.data.__super || _this.props.scope, tslib.__assign(tslib.__assign({}, _this.formatData(dataMapping.dataMapping(_this.props.defaultData, _this.props.data, ignoreSchemaProps))), _this.formatData(_this.props.data))));
                    }
                }
                else {
                    store.initData(tslib.__assign(tslib.__assign({}, _this.formatData(dataMapping.dataMapping(_this.props.defaultData, _this.props.data, ignoreSchemaProps))), _this.formatData(_this.props.data)));
                }
                _this.state = {};
                var detectField = props.detectField, rest = tslib.__rest(props, ["detectField"]);
                var exprProps = {};
                if (!detectField || detectField === 'data') {
                    exprProps = filterSchema.getExprProperties(rest, store.data);
                    _this.state = tslib.__assign({}, exprProps);
                    _this.unReaction = mobx.reaction(function () { return JSON.stringify(filterSchema.getExprProperties(_this.props, store.data)); }, function () {
                        return _this.setState(tslib.__assign({}, filterSchema.getExprProperties(_this.props, store.data)));
                    });
                }
                return _this;
            }
            StoreFactory.prototype.getWrappedInstance = function () {
                return this.ref;
            };
            StoreFactory.prototype.refFn = function (ref) {
                this.ref = ref;
            };
            StoreFactory.prototype.formatData = function (data) {
                if (Array.isArray(data)) {
                    return {
                        items: data
                    };
                }
                return data;
            };
            StoreFactory.prototype.componentDidUpdate = function (prevProps) {
                var _this = this;
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                var props = this.props;
                var store = this.store;
                // dialog 场景下 schema 是显示的时候更新的，
                // 所以 schema 里面有表达式属性其实是监听不到变化的
                // 所以这里需要根据新属性重新 reaction 一下
                if ((!props.detectField || props.detectField === 'data') &&
                    filterSchema.hasExprPropertiesChanged(this.props, prevProps)) {
                    var state = filterSchema.getExprProperties(this.props, store.data);
                    helper.isObjectShallowModified(state, this.state) && this.setState(state);
                    // 需要重新监听
                    (_a = this.unReaction) === null || _a === void 0 ? void 0 : _a.call(this);
                    this.unReaction = mobx.reaction(function () { return filterSchema.getExprProperties(_this.props, store.data); }, function (exprProps) { return _this.setState(exprProps); });
                }
                var shouldSync = (_b = renderer.shouldSyncSuperStore) === null || _b === void 0 ? void 0 : _b.call(renderer, store, props, prevProps);
                if (shouldSync === false) {
                    return;
                }
                var extendsData = typeof renderer.extendsData === 'function'
                    ? renderer.extendsData(props)
                    : renderer.extendsData;
                if (extendsData === false) {
                    if (shouldSync === true ||
                        prevProps.defaultData !== props.defaultData ||
                        (props.trackExpression
                            ? tokenize.tokenize(props.trackExpression, props.data) !==
                                tokenize.tokenize(props.trackExpression, prevProps.data)
                            : helper.isObjectShallowModified(prevProps.data, props.data) ||
                                //
                                // 特殊处理 CRUD。
                                // CRUD 中 toolbar 里面的 data 是空对象，但是 __super 会不一样
                                (props.data &&
                                    prevProps.data &&
                                    props.data.__super !== prevProps.data.__super))) {
                        store.initData(object.extendObject(props.data, tslib.__assign(tslib.__assign(tslib.__assign({}, this.formatData(dataMapping.dataMapping(this.props.defaultData, this.props.data, ignoreSchemaProps))), (store.hasRemoteData ? store.data : null)), this.formatData(props.data))), ((_c = props.updatePristineAfterStoreDataReInit) !== null && _c !== void 0 ? _c : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false, (_d = props.data) === null || _d === void 0 ? void 0 : _d.__changeReason);
                    }
                }
                else if (shouldSync === true ||
                    (props.trackExpression
                        ? tokenize.tokenize(props.trackExpression, props.data) !==
                            tokenize.tokenize(props.trackExpression, prevProps.data)
                        : helper.isObjectShallowModified(prevProps.data, props.data) ||
                            (props.syncSuperStore !== false &&
                                helper.isSuperDataModified(props.data, prevProps.data, store)))) {
                    if (props.store && props.scope === props.data) {
                        store.initData(object.createObject(props.store.data, tslib.__assign(tslib.__assign({}, this.formatData(dataMapping.dataMapping(this.props.defaultData, this.props.data, ignoreSchemaProps))), (props.syncSuperStore === false
                            ? tslib.__assign({}, store.data) : helper.syncDataFromSuper(store.data, props.store.data, prevProps.scope, store, props.syncSuperStore === true)))), ((_e = props.updatePristineAfterStoreDataReInit) !== null && _e !== void 0 ? _e : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false, (_f = props.data) === null || _f === void 0 ? void 0 : _f.__changeReason);
                    }
                    else if (props.data && props.data.__super) {
                        store.initData(object.extendObject(props.data, tslib.__assign(tslib.__assign({}, this.formatData(dataMapping.dataMapping(this.props.defaultData, this.props.data, ignoreSchemaProps))), // 有远程数据
                        // 或者顶级 store
                        (store.hasRemoteData || !store.path.includes('/')
                            ? tslib.__assign(tslib.__assign({}, store.data), props.data) : // combo 不需要同步，如果要同步，在 Combo.tsx 里面已经实现了相关逻辑
                            // 目前主要的问题是，如果 combo 中表单项名字和 combo 本身的名字一样，会导致里面的值会被覆盖成数组
                            ((_g = props.store) === null || _g === void 0 ? void 0 : _g.storeType) === 'ComboStore'
                                ? undefined
                                : helper.syncDataFromSuper(tslib.__assign(tslib.__assign({}, store.pristineDiff), props.data), props.data.__super, prevProps.data.__super, store, false)))), ((_h = props.updatePristineAfterStoreDataReInit) !== null && _h !== void 0 ? _h : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false, (_j = props.data) === null || _j === void 0 ? void 0 : _j.__changeReason);
                    }
                    else {
                        store.initData(object.createObject(props.scope, props.data), ((_k = props.updatePristineAfterStoreDataReInit) !== null && _k !== void 0 ? _k : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false, (_l = props.data) === null || _l === void 0 ? void 0 : _l.__changeReason);
                    }
                }
                else if (!props.trackExpression &&
                    (!props.store || props.data !== props.scope) &&
                    props.data &&
                    props.data.__super) {
                    // 这个用法很少，当 data.__super 值发生变化时，更新 store.data
                    if (!prevProps.data ||
                        helper.isObjectShallowModified(props.data.__super, prevProps.data.__super, false)) {
                        store.initData(object.createObject(props.data.__super, tslib.__assign(tslib.__assign({}, props.data), store.data)), ((_m = props.updatePristineAfterStoreDataReInit) !== null && _m !== void 0 ? _m : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false ||
                            (store.storeType === 'FormStore' &&
                                ((_o = prevProps.store) === null || _o === void 0 ? void 0 : _o.storeType) === 'CRUDStore'), (_p = props.data) === null || _p === void 0 ? void 0 : _p.__changeReason);
                    }
                    // nextProps.data.__super !== props.data.__super) &&
                }
                else if (!props.trackExpression &&
                    props.scope &&
                    props.data === props.store.data &&
                    prevProps.data !== props.data) {
                    // 只有父级数据变动的时候才应该进来，
                    // 目前看来这个 case 很少有情况下能进来
                    store.initData(object.createObject(props.scope, tslib.__assign({}, store.data)), ((_q = props.updatePristineAfterStoreDataReInit) !== null && _q !== void 0 ? _q : props.dataUpdatedAt !== prevProps.dataUpdatedAt) === false, (_r = props.data) === null || _r === void 0 ? void 0 : _r.__changeReason);
                }
            };
            StoreFactory.prototype.componentWillUnmount = function () {
                var _a, _b, _c;
                var rootStore = this.context;
                var store = this.store;
                (_a = this.unReaction) === null || _a === void 0 ? void 0 : _a.call(this);
                if (mobxStateTree.isAlive(store)) {
                    store.setTopStore(null);
                    rootStore.removeStore(store);
                }
                // @ts-ignore
                delete this.store;
                (_c = (_b = this.props).storeRef) === null || _c === void 0 ? void 0 : _c.call(_b, null);
            };
            StoreFactory.prototype.renderChild = function (region, node, subProps) {
                if (subProps === void 0) { subProps = {}; }
                var render = this.props.render;
                return render(region, node, tslib.__assign(tslib.__assign({ data: this.store.data, dataUpdatedAt: this.store.updatedAt }, subProps), { scope: this.store.data, store: this.store }));
            };
            StoreFactory.prototype.render = function () {
                var _a;
                var _b = this.props; _b.detectField; _b.storeRef; var rest = tslib.__rest(_b, ["detectField", "storeRef"]);
                if (this.state.hidden || this.state.visible === false) {
                    return null;
                }
                var refConfig = ((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a.isReactComponent) ||
                    Component.$$typeof === Symbol.for('react.forward_ref')
                    ? { ref: this.refFn }
                    : { forwardedRef: this.refFn };
                return (_J$X_(Component, tslib.__assign({}, rest /* todo */, this.state, refConfig, { data: this.store.data, dataUpdatedAt: this.store.updatedAt, store: this.store, scope: this.store.data, render: this.renderChild })));
            };
            StoreFactory.displayName = "WithStore(".concat(Component.displayName || Component.name, ")");
            StoreFactory.ComposedComponent = Component;
            StoreFactory.contextType = WithRootStore.RootStoreContext;
            StoreFactory = tslib.__decorate([
                mobxReact.observer,
                tslib.__metadata("design:paramtypes", [Object, void 0])
            ], StoreFactory);
            return StoreFactory;
        }(React__default["default"].Component));
        hoistNonReactStatic__default["default"](StoreFactory, Component);
        return StoreFactory;
    };
}

exports.HocStoreFactory = HocStoreFactory;
