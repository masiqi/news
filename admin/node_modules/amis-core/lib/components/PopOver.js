/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var ReactDOM = require('react-dom');
var theme = require('../theme.js');
require('amis-formula');
require('moment');
require('lodash/isPlainObject');
require('../utils/memoryParse.js');
require('@rc-component/mini-decimal');
require('../utils/filter.js');
require('../utils/api.js');
require('file-saver');
require('../utils/browser.js');
require('../utils/ColorScale.js');
require('../utils/columnsSplit.js');
require('../utils/DataSchema.js');
require('../utils/DataScope.js');
require('../utils/debug.js');
require('../utils/dom.js');
require('../utils/errors.js');
require('../utils/tpl.js');
var helper = require('../utils/helper.js');
require('lodash/isObject');
require('lodash/isString');
require('lodash/isBoolean');
require('../utils/highlight.js');
require('../utils/icon.js');
require('../utils/image.js');
require('lodash/isEqual');
require('../actions/Action.js');
require('lodash/debounce');
require('../utils/resize-sensor.js');
require('react-overlays/useRootClose');
require('../utils/SimpleMap.js');
require('lodash/mapValues');
require('lodash/camelCase');
require('lodash/cloneDeep');
require('lodash/map');
require('lodash/isEmpty');
require('lodash/kebabCase');
require('uncontrollable');
require('hoist-non-react-statics');
require('../utils/validations.js');
require('../utils/resolveCondition.js');
require('mobx');
require('../utils/Animation.js');
var Overlay = require('./Overlay.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var PopOver = /** @class */ (function (_super) {
    tslib.__extends(PopOver, _super);
    function PopOver() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            xOffset: 0,
            yOffset: 0
        };
        _this.wrapperRef = React__default["default"].createRef();
        _this.isRootClosed = false;
        return _this;
    }
    PopOver.prototype.componentDidMount = function () {
        this.mayUpdateOffset();
        var dom = ReactDOM.findDOMNode(this);
        this.parent = dom.parentNode;
        this.parent.classList.add('has-popover');
        if (this.wrapperRef && this.wrapperRef.current) {
            // https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#使用_passive_改善的滚屏性能
            this.wrapperRef.current.addEventListener('touchmove', helper.preventDefault, {
                passive: false,
                capture: false
            });
        }
        // 从弹窗中处理复制过来的，如果要修改，请同步修改
        // 因为 overlay 功能其实是用 postion: fixed 来实现的
        // 目的是加一个蒙层监听蒙层点击然后关闭弹窗。意图就是 closeOnOutside
        // 但是如果上层有个 translateZ 之类的样式就会影响 fixed 的定位，导致功能失效
        // 所以这里兜底加了个 closeOnOutside 的功能
        document.body.addEventListener('mousedown', this.handleRootMouseDownCapture, true);
        document.body.addEventListener('mouseup', this.handleRootMouseUpCapture, true);
        document.body.addEventListener('mouseup', this.handleRootMouseUp);
    };
    PopOver.prototype.componentDidUpdate = function () {
        this.mayUpdateOffset();
    };
    PopOver.prototype.componentWillUnmount = function () {
        this.parent && this.parent.classList.remove('has-popover');
        if (this.wrapperRef && this.wrapperRef.current) {
            this.wrapperRef.current.removeEventListener('touchmove', helper.preventDefault);
        }
        document.body.removeEventListener('mouseup', this.handleRootMouseUp);
        document.body.removeEventListener('mousedown', this.handleRootMouseDownCapture, true);
        document.body.removeEventListener('mouseup', this.handleRootMouseUpCapture, true);
    };
    PopOver.prototype.handleRootMouseDownCapture = function (e) {
        var target = e.target;
        var _a = this.props, closeOnOutside = _a.overlay, ns = _a.classPrefix;
        var isLeftButton = (e.button === 1 && window.event !== null) || e.button === 0;
        this.isRootClosed = !!(isLeftButton &&
            closeOnOutside &&
            target &&
            this.wrapperRef.current &&
            // 要可见，不可见就不处理了，通常是打开了新页签
            this.wrapperRef.current.offsetHeight &&
            !this.wrapperRef.current
                .getAttributeNames()
                .find(function (n) { return n.startsWith(Overlay.SubPopoverDisplayedID); }) &&
            ((!this.wrapperRef.current.contains(target) &&
                !target.closest('[role=dialog]')) ||
                (target.matches(".".concat(ns, "Modal")) && target === this.wrapperRef.current))); // 干脆过滤掉来自弹框里面的点击
    };
    PopOver.prototype.handleRootMouseUpCapture = function (e) {
        // mousedown 的时候不在弹窗里面，则不需要判断了
        if (!this.isRootClosed) {
            return;
        }
        // 再判断 mouseup 的时候是不是在弹窗里面
        this.handleRootMouseDownCapture(e);
    };
    PopOver.prototype.handleRootMouseUp = function (e) {
        var onHide = this.props.onHide;
        if (this.isRootClosed && !e.defaultPrevented) {
            // 因为原来 overlay 是不会让别的部分还有点击事件的，所以这里要阻止默认事件
            // 参考：https://stackoverflow.com/questions/8643739/cancel-click-event-in-the-mouseup-event-handler
            var captureClick_1 = function (e) {
                e.stopPropagation();
                window.removeEventListener('click', captureClick_1, true);
            };
            window.addEventListener('click', captureClick_1, true);
            onHide === null || onHide === void 0 ? void 0 : onHide();
        }
    };
    PopOver.prototype.mayUpdateOffset = function () {
        var offset;
        var getOffset = this.props.offset;
        if (getOffset && typeof getOffset === 'function') {
            var _a = this.props, placement = _a.placement, y = _a.positionTop, x = _a.positionLeft;
            offset = getOffset(ReactDOM.findDOMNode(this).getBoundingClientRect(), {
                x: x,
                y: y,
                placement: placement
            });
        }
        else {
            offset = getOffset;
        }
        this.setState({
            xOffset: offset && offset.x ? offset.x : 0,
            yOffset: offset && offset.y ? offset.y : 0
        });
    };
    PopOver.prototype.handleOverlayClick = function (e) {
        var _a, _b;
        e.preventDefault();
        (_b = (_a = this.props).onHide) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    PopOver.prototype.render = function () {
        var _a = this.props; _a.placement; var activePlacement = _a.activePlacement, positionTop = _a.positionTop, positionLeft = _a.positionLeft; _a.arrowOffsetLeft; _a.arrowOffsetTop; var style = _a.style, children = _a.children; _a.offset; var overlay = _a.overlay; _a.onHide; var ns = _a.classPrefix, cx = _a.classnames, className = _a.className; _a.componentId; var testIdBuilder = _a.testIdBuilder, rest = tslib.__rest(_a, ["placement", "activePlacement", "positionTop", "positionLeft", "arrowOffsetLeft", "arrowOffsetTop", "style", "children", "offset", "overlay", "onHide", "classPrefix", "classnames", "className", "componentId", "testIdBuilder"]);
        var _b = this.state, xOffset = _b.xOffset, yOffset = _b.yOffset;
        var outerStyle = tslib.__assign(tslib.__assign({ display: 'block' }, style), { top: positionTop + yOffset, left: positionLeft + xOffset });
        var placements = typeof activePlacement === 'string' ? activePlacement.split('-') : [];
        return (_J$X_("div", tslib.__assign({ ref: this.wrapperRef, role: "popover", className: cx("PopOver", className, activePlacement ? "PopOver--".concat(helper.camel(activePlacement)) : '', placements[3] ? "PopOver--v-".concat(placements[3]) : ''), style: outerStyle }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getTestId(), rest),
            overlay ? (_J$X_("div", tslib.__assign({ className: "".concat(ns, "PopOver-overlay"), onClick: this.handleOverlayClick }, testIdBuilder === null || testIdBuilder === void 0 ? void 0 : testIdBuilder.getChild('overlay').getTestId()))) : null,
            children));
    };
    PopOver.defaultProps = {
        className: '',
        offset: {
            x: 0,
            y: 0
        },
        overlay: false,
        placement: 'auto'
    };
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [MouseEvent]),
        tslib.__metadata("design:returntype", void 0)
    ], PopOver.prototype, "handleRootMouseDownCapture", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [MouseEvent]),
        tslib.__metadata("design:returntype", void 0)
    ], PopOver.prototype, "handleRootMouseUpCapture", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [MouseEvent]),
        tslib.__metadata("design:returntype", void 0)
    ], PopOver.prototype, "handleRootMouseUp", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], PopOver.prototype, "handleOverlayClick", null);
    return PopOver;
}(React__default["default"].PureComponent));
var PopOver$1 = theme.themeable(PopOver);

exports.PopOver = PopOver;
exports["default"] = PopOver$1;
