/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var Portal = require('react-overlays/Portal');
var cx = require('classnames');
var ReactDOM = require('react-dom');
var React = require('react');
require('amis-formula');
require('moment');
require('lodash/isPlainObject');
require('../utils/memoryParse.js');
require('@rc-component/mini-decimal');
require('../utils/filter.js');
require('../utils/api.js');
require('file-saver');
require('../utils/browser.js');
require('../utils/ColorScale.js');
require('../utils/columnsSplit.js');
require('../utils/DataSchema.js');
require('../utils/DataScope.js');
require('../utils/debug.js');
var dom = require('../utils/dom.js');
require('../utils/errors.js');
require('../utils/tpl.js');
var helper = require('../utils/helper.js');
require('lodash/isObject');
require('lodash/isString');
require('lodash/isBoolean');
require('../utils/highlight.js');
require('../utils/icon.js');
require('../utils/image.js');
require('lodash/isEqual');
require('../actions/Action.js');
require('lodash/debounce');
var resizeSensor = require('../utils/resize-sensor.js');
var RootClose = require('../utils/RootClose.js');
require('../utils/SimpleMap.js');
require('lodash/mapValues');
require('lodash/camelCase');
require('lodash/cloneDeep');
require('lodash/map');
require('lodash/isEmpty');
require('lodash/kebabCase');
require('uncontrollable');
require('hoist-non-react-statics');
require('../utils/validations.js');
require('../utils/resolveCondition.js');
require('mobx');
require('../utils/Animation.js');
var env = require('../env.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Portal__default = /*#__PURE__*/_interopDefaultLegacy(Portal);
var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var SubPopoverDisplayedID = 'data-sub-popover-displayed';
function onScroll(elem, callback) {
    var handler = function () {
        requestAnimationFrame(callback);
    };
    elem.addEventListener('scroll', handler);
    return function () {
        elem.removeEventListener('scroll', handler);
    };
}
var Position = /** @class */ (function (_super) {
    tslib.__extends(Position, _super);
    function Position(props) {
        var _this = _super.call(this, props) || this;
        _this.getTarget = function () {
            var target = _this.props.target;
            var targetElement = typeof target === 'function' ? target() : target;
            return (targetElement && ReactDOM__default["default"].findDOMNode(targetElement)) || null;
        };
        _this.maybeUpdatePosition = function (placementChanged) {
            var target = _this.getTarget();
            if (!_this.props.shouldUpdatePosition &&
                target === _this._lastTarget &&
                !placementChanged) {
                return;
            }
            _this.updatePosition(target);
        };
        _this.state = {
            ready: false,
            positionLeft: 0,
            positionTop: 0,
            arrowOffsetLeft: null,
            arrowOffsetTop: null
        };
        _this._lastTarget = null;
        _this.componentId = helper.uuid();
        return _this;
    }
    Position.prototype.updatePosition = function (target) {
        var _this = this;
        var _a, _b;
        this._lastTarget = target;
        /** 标记宿主元素的PopOver祖先，用于后续判断PopOver 是否可以 root close */
        if (target) {
            var parentPopover = (_a = target === null || target === void 0 ? void 0 : target.closest) === null || _a === void 0 ? void 0 : _a.call(target, '[role=popover]');
            if (!this.parentPopover && parentPopover) {
                this.parentPopover = parentPopover;
                this.parentPopover.setAttribute(SubPopoverDisplayedID + '-' + this.componentId, true);
            }
        }
        if (!target || !target.offsetWidth) {
            // 靠这个 re-render 来重置 position
            return this.setState({});
        }
        var watchTargetSizeChange = this.props.watchTargetSizeChange;
        var overlay = this.overlay;
        var container = dom.getContainer(this.props.container, dom.ownerDocument(this).body);
        if (!this.watchedTarget || this.watchedTarget !== target) {
            (_b = this.resizeDispose) === null || _b === void 0 ? void 0 : _b.forEach(function (fn) { return fn(); });
            this.watchedTarget = target;
            this.resizeDispose = [
                watchTargetSizeChange !== false
                    ? resizeSensor.resizeSensor(target, function () { return _this.updatePosition(target); })
                    : helper.noop,
                resizeSensor.resizeSensor(overlay, function () { return _this.updatePosition(target); })
            ];
            var scrollParent = helper.getScrollParent(target);
            if (scrollParent && container.contains(scrollParent)) {
                this.resizeDispose.push(onScroll(scrollParent, function () {
                    _this.updatePosition(target);
                }));
            }
        }
        this.setState(tslib.__assign(tslib.__assign({}, dom.calculatePosition(this.props.placement, overlay, target, container, this.props.containerPadding, this.props.offset)), { ready: true }));
    };
    Position.prototype.componentDidMount = function () {
        this.overlay = ReactDOM.findDOMNode(this);
        this.updatePosition(this.getTarget());
    };
    Position.prototype.componentDidUpdate = function (prevProps) {
        this.maybeUpdatePosition(this.props.placement !== prevProps.placement);
    };
    Position.prototype.componentWillUnmount = function () {
        var _a;
        // 一个 PopOver 关闭时，需把挂载父 PopOver 的标记去掉
        // 这里可能会存在多个子 PopOver 的情况，所以需要加上 componentId
        if (this.parentPopover &&
            this.parentPopover.getAttribute(SubPopoverDisplayedID + '-' + this.componentId)) {
            this.parentPopover.removeAttribute(SubPopoverDisplayedID + '-' + this.componentId);
            this.parentPopover = null;
        }
        (_a = this.resizeDispose) === null || _a === void 0 ? void 0 : _a.forEach(function (fn) { return fn(); });
    };
    Position.prototype.render = function () {
        var _a = this.props, children = _a.children, className = _a.className, props = tslib.__rest(_a, ["children", "className"]);
        var _b = this.state, ready = _b.ready, positionLeft = _b.positionLeft, positionTop = _b.positionTop, arrowPosition = tslib.__rest(_b, ["ready", "positionLeft", "positionTop"]);
        // These should not be forwarded to the child.
        delete props.target;
        delete props.container;
        delete props.containerPadding;
        delete props.shouldUpdatePosition;
        var child = React__default["default"].Children.only(children);
        return React.cloneElement(child, tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, props), arrowPosition), (child.props.offset ? { offset: child.props.offset } : {})), { 
            // FIXME: Don't forward `positionLeft` and `positionTop` via both props
            // and `props.style`.
            positionLeft: positionLeft, positionTop: positionTop, className: cx__default["default"](className, child.props.className), style: tslib.__assign(tslib.__assign({}, child.props.style), { left: positionLeft, top: positionTop, visibility: ready ? undefined : 'hidden' }), componentId: this.componentId }));
    };
    Position.defaultProps = {
        containerPadding: 0,
        placement: 'right',
        shouldUpdatePosition: false
    };
    return Position;
}(React__default["default"].Component));
var Overlay = /** @class */ (function (_super) {
    tslib.__extends(Overlay, _super);
    function Overlay(props) {
        var _this = _super.call(this, props) || this;
        _this.position = null;
        _this.positionRef = function (position) {
            _this.position = position;
        };
        _this.state = {
            exited: !props.show
        };
        return _this;
    }
    Overlay.prototype.updatePosition = function () {
        var _a;
        (_a = this.position) === null || _a === void 0 ? void 0 : _a.maybeUpdatePosition(true);
    };
    Overlay.prototype.componentDidUpdate = function (prevProps, prevState) {
        var props = this.props;
        if (prevProps.show !== props.show && props.show) {
            this.setState({ exited: false });
        }
        else if (props.transition !== prevProps.transition && !props.transition) {
            // Otherwise let handleHidden take care of marking exited.
            this.setState({ exited: true });
        }
    };
    Overlay.prototype.onHiddenListener = function (node) {
        this.setState({ exited: true });
        if (this.props.onExited) {
            this.props.onExited(node);
        }
    };
    Overlay.prototype.getContainerSelector = function () {
        var containerSelector = this.props.containerSelector;
        var container = null;
        if (typeof containerSelector === 'string') {
            container = document.querySelector(containerSelector);
        }
        return container;
    };
    Overlay.prototype.render = function () {
        var _a;
        var _b = this.props, containerPadding = _b.containerPadding, target = _b.target, placement = _b.placement, shouldUpdatePosition = _b.shouldUpdatePosition, rootClose = _b.rootClose, children = _b.children; _b.watchTargetSizeChange; var Transition = _b.transition, offset = _b.offset, props = tslib.__rest(_b, ["containerPadding", "target", "placement", "shouldUpdatePosition", "rootClose", "children", "watchTargetSizeChange", "transition", "offset"]);
        var container = (this.getContainerSelector()
            ? this.getContainerSelector
            : this.props.container) || ((_a = this.context) === null || _a === void 0 ? void 0 : _a.getModalContainer);
        var mountOverlay = props.show || (Transition && !this.state.exited);
        if (!mountOverlay) {
            // Don't bother showing anything if we don't have to.
            return null;
        }
        var child = children;
        // Position is be inner-most because it adds inline styles into the child,
        // which the other wrappers don't forward correctly.
        child = (
        // @ts-ignore
        _J$X_(Position, tslib.__assign({}, {
            container: container,
            containerPadding: containerPadding,
            target: target,
            placement: placement,
            shouldUpdatePosition: shouldUpdatePosition,
            offset: offset
        }, { ref: this.positionRef }), child));
        if (Transition) {
            var onExit = props.onExit, onExiting = props.onExiting, onEnter = props.onEnter, onEntering = props.onEntering, onEntered = props.onEntered;
            // This animates the child node by injecting props, so it must precede
            // anything that adds a wrapping div.
            child = (_J$X_(Transition, { in: props.show, appear: true, onExit: onExit, onExiting: onExiting, onExited: this.onHiddenListener, onEnter: onEnter, onEntering: onEntering, onEntered: onEntered }, child));
        }
        // This goes after everything else because it adds a wrapping div.
        if (rootClose) {
            return (
            // @ts-ignore
            _J$X_(Portal__default["default"], { container: container },
                _J$X_(RootClose.RootClose, { onRootClose: props.onHide }, function (ref) {
                    if (React__default["default"].isValidElement(child)) {
                        return React__default["default"].cloneElement(child, {
                            ref: ref
                        });
                    }
                    return _J$X_("div", { ref: ref }, child);
                })));
        }
        // @ts-ignore
        return _J$X_(Portal__default["default"], { container: container }, child);
    };
    Overlay.defaultProps = {
        placement: 'auto'
    };
    Overlay.contextType = env.EnvContext;
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [HTMLElement]),
        tslib.__metadata("design:returntype", void 0)
    ], Overlay.prototype, "onHiddenListener", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], Overlay.prototype, "getContainerSelector", null);
    return Overlay;
}(React__default["default"].Component));

exports.SubPopoverDisplayedID = SubPopoverDisplayedID;
exports["default"] = Overlay;
