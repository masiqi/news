/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');

/**
 * 自动清理访问次数最少key的Map，次数相同时优先淘汰旧项
 * 每次触发清理的计数基于容量的百分比
 * @class VisitedCache
 * @template K - 缓存key的类型
 * @template V - 缓存value的类型
 */
var VisitedCache = /** @class */ (function () {
    /**
     *
     * @param capacity 容量
     * @param releasePercent 清理数量占容量百分比
     */
    function VisitedCache(capacity, releasePercent) {
        this.visitCountOrder = [];
        this.keyOrderMatrixForByCount = {};
        this.capacity = capacity;
        this.cache = new Map();
        this.releaseCount = (this.capacity * (releasePercent || 1 / 8)) >> 0 || 1;
    }
    /**
     * 更新现存项目的缓存顺序
     * @param key
     * @param entry
     */
    VisitedCache.prototype.updateCacheEntryOrder = function (key, entry, nextVisitCount) {
        var oldVisitCount = entry.visitCount;
        var oldKeyOrder = this.keyOrderMatrixForByCount[oldVisitCount];
        if (Array.isArray(oldKeyOrder)) {
            // 从key为旧访问次数的顺序数组中删除
            var oldKeyIndex = oldKeyOrder.indexOf(key);
            if (oldKeyIndex !== -1) {
                oldKeyOrder.splice(oldKeyIndex, 1);
            }
        }
        // 相同访问量，更新访问顺序
        this.keyOrderMatrixForByCount[nextVisitCount] = Array.isArray(this.keyOrderMatrixForByCount[nextVisitCount])
            ? tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(this.keyOrderMatrixForByCount[nextVisitCount]), false), [key], false) : [key];
        entry.visitCount = nextVisitCount;
        // 重新按照访问量排序
        this.visitCountOrder = tslib.__spreadArray([], tslib.__read(new Set(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(this.visitCountOrder), false), [nextVisitCount], false))), false).sort(function (a, b) { return a - b; });
    };
    /**
     *
     * @param {K} key
     * @returns {(V | undefined)}
     */
    VisitedCache.prototype.get = function (key) {
        if (this.cache.has(key)) {
            var entry = this.cache.get(key);
            if (entry !== undefined) {
                var visitCount = entry.visitCount;
                // 更新访问顺序
                this.updateCacheEntryOrder(key, entry, visitCount + 1);
                return entry.value;
            }
        }
        return undefined;
    };
    /**
     *
     * @param {K} key
     * @param {V} value
     */
    VisitedCache.prototype.set = function (key, value) {
        // 更新现存项的值和访问次数及新鲜度
        if (this.cache.has(key)) {
            var entry = this.cache.get(key);
            if (entry !== undefined) {
                var visitCount = entry.visitCount;
                this.updateCacheEntryOrder(key, entry, visitCount + 1);
                entry.value = value;
            }
        }
        else {
            // 先进行清理
            if (this.cache.size === this.capacity) {
                // TODO 依据最大容量的1/10进行释放,试试效果
                var dynamicReleaseCount = this.releaseCount;
                // const dynamicReleaseCount =
                // 	(this.keyOrderMatrixForByCount[this.visitCountOrder[this.visitCountOrder.length - 1]].length / (this.capacity)) >>
                // 		0 || 1
                var findIndex = 0;
                var released = 0;
                while (released < dynamicReleaseCount &&
                    findIndex <= this.visitCountOrder.length - 1) {
                    // 最少访问的次数
                    var targetCount = this.visitCountOrder[findIndex];
                    // 查看其中有没有项
                    var targetKeyOrder = this.keyOrderMatrixForByCount[targetCount];
                    if (!targetKeyOrder.length) {
                        findIndex++;
                    }
                    else {
                        while (targetKeyOrder.length > 0 &&
                            released < dynamicReleaseCount) {
                            this.cache.delete(targetKeyOrder.shift());
                            released++;
                        }
                    }
                }
            }
            var newEntry = {
                visitCount: 1,
                value: value
            };
            this.cache.set(key, newEntry);
            this.updateCacheEntryOrder(key, newEntry, 1);
        }
    };
    VisitedCache.prototype.has = function (key) {
        return this.cache.has(key);
    };
    return VisitedCache;
}());

exports["default"] = VisitedCache;
