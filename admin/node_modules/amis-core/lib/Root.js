/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var isPlainObject = require('lodash/isPlainObject');
var locale = require('./locale.js');
var RootRenderer = require('./RootRenderer.js');
var SchemaRenderer = require('./SchemaRenderer.js');
var Scoped = require('./Scoped.js');
var theme = require('./theme.js');
var helper = require('./utils/helper.js');
var WithRootStore = require('./WithRootStore.js');
var StatusScoped = require('./StatusScoped.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var isPlainObject__default = /*#__PURE__*/_interopDefaultLegacy(isPlainObject);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
var rootWrappers = [];
function addRootWrapper(fn) {
    rootWrappers.push(fn);
}
var Root = /** @class */ (function (_super) {
    tslib.__extends(Root, _super);
    function Root() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Root.prototype.resolveDefinitions = function (name) {
        var definitions = this.props.schema.definitions;
        if (!name || helper.isEmpty(definitions)) {
            return {};
        }
        return definitions && definitions[name];
    };
    Root.prototype.render = function () {
        var _a = this.props, schema = _a.schema, rootStore = _a.rootStore, env = _a.env, pathPrefix = _a.pathPrefix, location = _a.location, data = _a.data, context = _a.context, locale$1 = _a.locale, translate = _a.translate, rest = tslib.__rest(_a, ["schema", "rootStore", "env", "pathPrefix", "location", "data", "context", "locale", "translate"]);
        var theme$1 = env.theme;
        var themeName = this.props.theme || 'cxd';
        if (themeName === 'default') {
            themeName = 'cxd';
        }
        return (_J$X_(WithRootStore.RootStoreContext.Provider, { value: rootStore },
            _J$X_(theme.ThemeContext.Provider, { value: themeName },
                _J$X_(locale.LocaleContext.Provider, { value: this.props.locale }, rootWrappers.reduce(function (props, wrapper) {
                    return tslib.__assign(tslib.__assign({}, props), { children: wrapper(props) });
                }, tslib.__assign(tslib.__assign({ pathPrefix: pathPrefix || '', schema: isPlainObject__default["default"](schema)
                        ? tslib.__assign({ type: 'page' }, schema) : schema }, rest), { render: renderChild, rootStore: rootStore, resolveDefinitions: this.resolveDefinitions, location: location, data: data, env: env, classnames: theme$1.classnames, classPrefix: theme$1.classPrefix, locale: locale$1, translate: translate, children: (_J$X_(RootRenderer.RootRenderer, tslib.__assign({ pathPrefix: pathPrefix || '', schema: isPlainObject__default["default"](schema)
                            ? tslib.__assign({ type: 'page' }, schema) : schema }, rest, { render: renderChild, rootStore: rootStore, resolveDefinitions: this.resolveDefinitions, location: location, data: data, context: context, env: env, classnames: theme$1.classnames, classPrefix: theme$1.classPrefix, locale: locale$1, translate: translate }))) })).children))));
    };
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [String]),
        tslib.__metadata("design:returntype", void 0)
    ], Root.prototype, "resolveDefinitions", null);
    return Root;
}(React__default["default"].Component));
function renderChildren(prefix, node, props) {
    if (Array.isArray(node)) {
        var elemKey = props.key || props.propKey || props.id || '';
        return node.map(function (node, index) {
            return renderChild("".concat(prefix, "/").concat(index), node, tslib.__assign(tslib.__assign({}, props), { key: "".concat(elemKey ? "".concat(elemKey, "-") : '').concat(index) }));
        });
    }
    return renderChild(prefix, node, props);
}
function renderChild(prefix, node, props) {
    var _a;
    if (Array.isArray(node)) {
        return renderChildren(prefix, node, props);
    }
    var typeofnode = typeof node;
    if (typeofnode === 'undefined' || node === null) {
        return null;
    }
    else if (React__default["default"].isValidElement(node)) {
        return node;
    }
    var schema = typeofnode === 'string' || typeofnode === 'number'
        ? { type: 'tpl', tpl: String(node) }
        : node;
    var transform = props.propsTransform;
    if (transform) {
        props = tslib.__assign({}, props);
        delete props.propsTransform;
        props = transform(props);
    }
    var Comp = props.env.SchemaRenderer || SchemaRenderer.SchemaRenderer;
    if (['dialog', 'drawer'].includes(schema === null || schema === void 0 ? void 0 : schema.type) &&
        !(schema === null || schema === void 0 ? void 0 : schema.component) &&
        !(schema === null || schema === void 0 ? void 0 : schema.children)) {
        // 因为状态判断实在 SchemaRenderer 里面判断的
        // 找渲染器也是在那，所以没办法在之前根据渲染器信息来包裹个组件下发 statusStore
        // 所以这里先根据 type 来处理一下
        // 等后续把状态处理再抽一层，可以把此处放到 SchemaRenderer 里面去
        return (_J$X_(StatusScoped.StatusScopedWrapper, null, function (_a) {
            var _b;
            var statusStore = _a.statusStore;
            return (_J$X_(Comp, tslib.__assign({ render: renderChild }, props, { key: (_b = props.key) !== null && _b !== void 0 ? _b : schema.key, schema: schema, propKey: schema.key, "$path": "".concat(prefix ? "".concat(prefix, "/") : '').concat((schema && schema.type) || ''), statusStore: statusStore })));
        }));
    }
    return (_J$X_(Comp, tslib.__assign({ render: renderChild }, props, { key: (_a = props.key) !== null && _a !== void 0 ? _a : schema.key, schema: schema, propKey: schema.key, "$path": "".concat(prefix ? "".concat(prefix, "/") : '').concat((schema && schema.type) || '') })));
}
var ScopedRootRenderer = StatusScoped.StatusScoped(Scoped.HocScoped(Root));

exports.Root = Root;
exports.addRootWrapper = addRootWrapper;
exports["default"] = ScopedRootRenderer;
exports.renderChild = renderChild;
exports.renderChildren = renderChildren;
