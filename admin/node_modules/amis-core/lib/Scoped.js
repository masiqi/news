/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var find = require('lodash/find');
var values = require('lodash/values');
var hoistNonReactStatic = require('hoist-non-react-statics');
var amisFormula = require('amis-formula');
require('moment');
var object = require('./utils/object.js');
var tokenize = require('./utils/tokenize.js');
var isPureVariable = require('./utils/isPureVariable.js');
require('@rc-component/mini-decimal');
var getVariable = require('./utils/getVariable.js');
require('./utils/memoryParse.js');
var dataMapping = require('./utils/dataMapping.js');
require('./utils/filter.js');
var helper = require('./utils/helper.js');
require('./utils/api.js');
require('file-saver');
require('./utils/browser.js');
require('./utils/ColorScale.js');
require('./utils/columnsSplit.js');
require('./utils/DataSchema.js');
require('./utils/DataScope.js');
require('./utils/debug.js');
require('./utils/dom.js');
require('./utils/errors.js');
var tpl = require('./utils/tpl.js');
require('lodash/isPlainObject');
require('lodash/isObject');
require('lodash/isString');
require('lodash/isBoolean');
require('./utils/highlight.js');
require('./utils/icon.js');
require('./utils/image.js');
require('lodash/isEqual');
var rendererEvent = require('./utils/renderer-event.js');
require('./utils/resize-sensor.js');
require('react-overlays/useRootClose');
require('react-dom');
require('./utils/SimpleMap.js');
require('lodash/mapValues');
require('lodash/camelCase');
require('lodash/cloneDeep');
require('lodash/map');
require('lodash/isEmpty');
require('lodash/kebabCase');
require('uncontrollable');
require('./utils/validations.js');
require('./utils/resolveCondition.js');
require('mobx');
require('./utils/Animation.js');
require('./actions/LoopAction.js');
require('./actions/BreakAction.js');
require('./actions/ContinueAction.js');
require('./actions/SwitchAction.js');
require('./actions/ParallelAction.js');
require('./actions/CustomAction.js');
require('./actions/BroadcastAction.js');
require('./actions/CmptAction.js');
require('./actions/StatusAction.js');
require('./actions/AjaxAction.js');
require('./actions/CopyAction.js');
require('./actions/DialogAction.js');
require('./actions/DrawerAction.js');
require('./actions/EmailAction.js');
require('./actions/EventAction.js');
require('./actions/LinkAction.js');
require('./actions/ToastAction.js');
require('./actions/WaitAction.js');
require('./actions/PageAction.js');
require('./actions/PrintAction.js');
var Action = require('./actions/Action.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var find__default = /*#__PURE__*/_interopDefaultLegacy(find);
var values__default = /*#__PURE__*/_interopDefaultLegacy(values);
var hoistNonReactStatic__default = /*#__PURE__*/_interopDefaultLegacy(hoistNonReactStatic);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
(__react_jsx__["default"] || __react_jsx__).Fragment;
/**
 * target 里面可能包含 ?xxx=xxx，这种情况下，需要把 ?xxx=xxx 保留下来，然后对前面的部分进行 filter
 * 因为后面会对 query 部分做不一样的处理。会保留原始的值。而不是会转成字符串。
 * @param target
 * @param data
 * @returns
 */
function filterTarget(target, data) {
    var idx = target.indexOf('?');
    if (~idx) {
        return tpl.filter(target.slice(0, idx), data) + target.slice(idx);
    }
    return tpl.filter(target, data, '| raw');
}
/**
 * 分割目标，如果里面有表达式，不要跟表达式里面的逗号冲突。
 * @param target
 * @returns
 */
function splitTarget(target) {
    try {
        var ast = tokenize.memoParse(target);
        var pos_1 = [];
        ast.body.forEach(function (item) {
            // 不要处理表达式里面的东西。
            if (item.type === 'raw') {
                var parts = item.value.split(',');
                if (parts.length > 1) {
                    parts.pop();
                    var start_1 = item.start.index;
                    parts.forEach(function (part) {
                        pos_1.push(start_1 + part.length);
                        start_1 += part.length + 1;
                    });
                }
            }
        });
        if (pos_1.length) {
            var parts = [];
            pos_1.reduceRight(function (arr, index) {
                var _a;
                arr.unshift((_a = target.slice(index + 1)) === null || _a === void 0 ? void 0 : _a.trim());
                target = target.slice(0, index);
                return arr;
            }, parts);
            parts.unshift(target);
            return parts;
        }
    }
    catch (e) { }
    return [target];
}
var rootScopedContext = createScopedTools('');
var ScopedContext = React__default["default"].createContext(rootScopedContext);
function createScopedTools(path, parent, env, rendererType) {
    var components = [];
    var self = {
        rendererType: rendererType,
        component: undefined,
        parent: parent,
        registerComponent: function (component) {
            // 不要把自己注册在自己的 Scoped 上，自己的 Scoped 是给子节点们注册的。
            if (component.props.$path === path && parent) {
                self.component = component;
                return parent.registerComponent(component);
            }
            if (!~components.indexOf(component)) {
                components.push(component);
            }
        },
        unRegisterComponent: function (component) {
            // 自己本身实际上注册在父级 Scoped 上。
            if (component.props.$path === path && parent) {
                // 如果是自己，尝试把自己从父级 Scoped 上移除，否则在某些场景下会导致父级的 children 一直增长。
                var idx_1 = parent.children.indexOf(self);
                ~idx_1 && parent.children.splice(idx_1, 1);
                return parent.unRegisterComponent(component);
            }
            var idx = components.indexOf(component);
            if (~idx) {
                components.splice(idx, 1);
            }
        },
        getComponentByName: function (name) {
            if (~name.indexOf('.')) {
                var paths = name.split('.');
                var len_1 = paths.length;
                return paths.reduce(function (scope, name, idx) {
                    if (scope && scope.getComponentByName) {
                        var result = scope.getComponentByName(name);
                        return result && idx < len_1 - 1 ? result.context : result;
                    }
                    return null;
                }, this);
            }
            var resolved = find__default["default"](components, function (component) {
                return tpl.filter(component.props.name, component.props.data) === name ||
                    component.props.id === name;
            });
            return resolved || (parent && parent.getComponentByName(name));
        },
        getComponentByIdUnderCurrentScope: function (id, ignoreScope) {
            var component = undefined;
            helper.findTree([this], function (item) {
                return item !== ignoreScope &&
                    item.getComponents().find(function (cmpt) {
                        if (tpl.filter(cmpt.props.id, cmpt.props.data) === id) {
                            component = cmpt;
                            return true;
                        }
                        return false;
                    });
            });
            return component;
        },
        getComponentById: function (id) {
            var root = this;
            var ignoreScope = undefined;
            // 找到顶端scoped
            while (root) {
                // 优先从当前scope查找
                // 直接跑到顶层查找，对于有历史标签一次渲染多个页面的情况，会有问题
                var component = root.getComponentByIdUnderCurrentScope(id, ignoreScope);
                if (component) {
                    return component;
                }
                if (!root.parent || root.parent === rootScopedContext) {
                    break;
                }
                ignoreScope = root;
                root = root.parent;
            }
            return undefined;
        },
        /**
         * 基于绑定的变量名称查找组件
         * 支持形如${xxx}的格式
         *
         * @param session store的session, 默认为全局的
         * @param path 变量路径, 包含命名空间
         */
        getComponentsByRefPath: function (session, path) {
            if (!path || typeof path !== 'string') {
                return [];
            }
            var cmptMaps = {};
            var root = this;
            while (root.parent) {
                root = root.parent;
            }
            helper.eachTree([root], function (item) {
                var e_1, _a, e_2, _b;
                var _c, _d, _e, _f, _g, _h;
                var scopedCmptList = item.getComponents() || [];
                if (Array.isArray(scopedCmptList)) {
                    try {
                        for (var scopedCmptList_1 = tslib.__values(scopedCmptList), scopedCmptList_1_1 = scopedCmptList_1.next(); !scopedCmptList_1_1.done; scopedCmptList_1_1 = scopedCmptList_1.next()) {
                            var cmpt = scopedCmptList_1_1.value;
                            var pathKey = (_d = (_c = cmpt === null || cmpt === void 0 ? void 0 : cmpt.props) === null || _c === void 0 ? void 0 : _c.$path) !== null && _d !== void 0 ? _d : 'unknown';
                            var schema = (_f = (_e = cmpt === null || cmpt === void 0 ? void 0 : cmpt.props) === null || _e === void 0 ? void 0 : _e.$schema) !== null && _f !== void 0 ? _f : {};
                            var cmptSession = (_h = (_g = cmpt === null || cmpt === void 0 ? void 0 : cmpt.props.env) === null || _g === void 0 ? void 0 : _g.session) !== null && _h !== void 0 ? _h : 'global';
                            /** 仅查找当前session的组件 */
                            if (cmptMaps[pathKey] || session !== cmptSession) {
                                continue;
                            }
                            /** 非Scoped组件, 查找其所属的父容器 */
                            if ((cmpt === null || cmpt === void 0 ? void 0 : cmpt.setData) && typeof cmpt.setData === 'function') {
                                cmptMaps[pathKey] = cmpt;
                                continue;
                            }
                            try {
                                /** 查找Scoped组件中的引用 */
                                for (var _j = (e_2 = void 0, tslib.__values(Object.keys(schema))), _k = _j.next(); !_k.done; _k = _j.next()) {
                                    var key = _k.value;
                                    var expression = schema[key];
                                    if (typeof expression === 'string' &&
                                        isPureVariable.isPureVariable(expression)) {
                                        /** 考虑到数据映射函数的情况，将宿主变量提取出来 */
                                        var host = expression
                                            .substring(2, expression.length - 1)
                                            .split('|')[0];
                                        if (host && host === path) {
                                            cmptMaps[pathKey] = cmpt;
                                            break;
                                        }
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (scopedCmptList_1_1 && !scopedCmptList_1_1.done && (_a = scopedCmptList_1.return)) _a.call(scopedCmptList_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
            return values__default["default"](cmptMaps);
        },
        getComponents: function () {
            return components.concat();
        },
        reload: function (target, ctx) {
            var scoped = this;
            var targets = typeof target === 'string' ? splitTarget(target) : target;
            targets.forEach(function (name) {
                var idx2 = name.indexOf('?');
                var query = null;
                if (~idx2) {
                    var queryObj = helper.qsparse(name
                        .substring(idx2 + 1)
                        .replace(/\$\{(.*?)\}/, function (_, match) { return '${' + encodeURIComponent(match) + '}'; }));
                    query = dataMapping.dataMapping(queryObj, ctx);
                    name = name.substring(0, idx2);
                }
                var idx = name.indexOf('.');
                var subPath = '';
                if (~idx) {
                    subPath = name.substring(1 + idx);
                    name = name.substring(0, idx);
                }
                if (name === 'window') {
                    if (query) {
                        var link = location.pathname + '?' + helper.qsstringify(query);
                        env ? env.updateLocation(link, true) : location.replace(link);
                    }
                    else {
                        location.reload();
                    }
                }
                else {
                    var component = scoped.getComponentByName(name) || scoped.getComponentById(name);
                    component &&
                        component.reload &&
                        component.reload(subPath, query, ctx);
                }
            });
        },
        send: function (receive, values) {
            var scoped = this;
            var receives = typeof receive === 'string' ? splitTarget(receive) : receive;
            // todo 没找到做提示！
            receives.forEach(function (name) {
                var askIdx = name.indexOf('?');
                if (~askIdx) {
                    var query = name.substring(askIdx + 1);
                    var queryObj = helper.qsparse(query.replace(/\$\{(.*?)\}/, function (_, match) { return '${' + encodeURIComponent(match) + '}'; }));
                    name = name.substring(0, askIdx);
                    values = dataMapping.dataMapping(queryObj, values);
                }
                var idx = name.indexOf('.');
                var subPath = '';
                if (~idx) {
                    subPath = name.substring(1 + idx);
                    name = name.substring(0, idx);
                }
                var component = scoped.getComponentByName(name);
                if (component && component.receive) {
                    component.receive(values, subPath);
                }
                else if (name === 'window' && env && env.updateLocation) {
                    var query = tslib.__assign(tslib.__assign({}, helper.parseQuery(location)), values);
                    var link = location.pathname + '?' + helper.qsstringify(query);
                    env.updateLocation(link, true);
                }
            });
        },
        /**
         * 主要是用来关闭指定弹框的
         *
         * @param target 目标 name
         */
        close: function (target) {
            var scoped = this;
            if (typeof target === 'string') {
                // 过滤已经关掉的，当用户 close 配置多个弹框 name 时会出现这种情况
                splitTarget(target)
                    .map(function (name) { return scoped.getComponentByName(name); })
                    .filter(function (component) { return component && component.props.show; })
                    .forEach(closeDialog);
            }
        },
        /**
         * 关闭指定id的弹窗
         * @param id
         */
        closeById: function (id) {
            var scoped = this;
            var component = scoped.getComponentById(id);
            if (component && component.props.show) {
                closeDialog(component);
            }
        },
        doAction: function (actions, ctx) {
            return tslib.__awaiter(this, void 0, void 0, function () {
                var renderer, rendererEvent$1;
                return tslib.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            renderer = this.getComponents()[0];
                            rendererEvent$1 = rendererEvent.createRendererEvent('embed', {
                                env: env,
                                nativeEvent: undefined,
                                data: object.createObject(renderer.props.data, ctx),
                                scoped: this
                            });
                            return [4 /*yield*/, Action.runActions(actions, renderer, rendererEvent$1)];
                        case 1:
                            _a.sent();
                            if (rendererEvent$1.prevented) {
                                return [2 /*return*/];
                            }
                            return [2 /*return*/];
                    }
                });
            });
        }
    };
    amisFormula.registerFunction('GETRENDERERDATA', function (componentId, path, scoped) {
        var _a;
        if (scoped === void 0) { scoped = self; }
        var component = scoped.getComponentById(componentId);
        var data = (_a = component === null || component === void 0 ? void 0 : component.getData) === null || _a === void 0 ? void 0 : _a.call(component);
        if (path) {
            var variable = getVariable.getVariable(data, path);
            return variable;
        }
        return data;
    });
    amisFormula.registerFunction('GETRENDERERPROP', function (componentId, path, scoped) {
        if (scoped === void 0) { scoped = self; }
        var component = scoped.getComponentById(componentId);
        var props = component === null || component === void 0 ? void 0 : component.props;
        if (path) {
            var variable = getVariable.getVariable(props, path);
            return variable;
        }
        return props;
    });
    if (!parent) {
        return self;
    }
    !parent.children && (parent.children = []);
    // 把孩子带上
    parent.children.push(self);
    return self;
}
function closeDialog(component) {
    component.context
        .getComponents()
        .filter(function (item) {
        return item &&
            (item.props.type === 'dialog' || item.props.type === 'drawer') &&
            item.props.show;
    })
        .forEach(closeDialog);
    component.props.onClose && component.props.onClose();
}
function HocScoped(ComposedComponent, rendererType) {
    var ScopedComponent = /** @class */ (function (_super) {
        tslib.__extends(ScopedComponent, _super);
        function ScopedComponent(props, context) {
            var _this = _super.call(this, props) || this;
            _this.scoped = createScopedTools(_this.props.$path, context, _this.props.env, rendererType);
            var scopeRef = props.scopeRef;
            scopeRef && scopeRef(_this.scoped);
            return _this;
        }
        ScopedComponent.prototype.getWrappedInstance = function () {
            return this.ref;
        };
        ScopedComponent.prototype.childRef = function (ref) {
            while (ref && ref.getWrappedInstance) {
                ref = ref.getWrappedInstance();
            }
            this.ref = ref;
        };
        ScopedComponent.prototype.componentWillUnmount = function () {
            var scopeRef = this.props.scopeRef;
            scopeRef && scopeRef(null);
            delete this.scoped;
        };
        ScopedComponent.prototype.render = function () {
            var _a = this.props; _a.scopeRef; var rest = tslib.__rest(_a, ["scopeRef"]);
            return (_J$X_(ScopedContext.Provider, { value: this.scoped },
                _J$X_(ComposedComponent, tslib.__assign({}, rest /* todo */, { ref: this.childRef }))));
        };
        ScopedComponent.displayName = "Scoped(".concat(ComposedComponent.displayName || ComposedComponent.name, ")");
        ScopedComponent.contextType = ScopedContext;
        ScopedComponent.ComposedComponent = ComposedComponent;
        tslib.__decorate([
            helper.autobind,
            tslib.__metadata("design:type", Function),
            tslib.__metadata("design:paramtypes", [Object]),
            tslib.__metadata("design:returntype", void 0)
        ], ScopedComponent.prototype, "childRef", null);
        return ScopedComponent;
    }(React__default["default"].Component));
    hoistNonReactStatic__default["default"](ScopedComponent, ComposedComponent);
    return ScopedComponent;
}

exports.HocScoped = HocScoped;
exports.ScopedContext = ScopedContext;
exports["default"] = HocScoped;
exports.filterTarget = filterTarget;
exports.splitTarget = splitTarget;
