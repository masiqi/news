/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var mobxStateTree = require('mobx-state-tree');
var iRenderer = require('./iRenderer.js');
var isEqual = require('lodash/isEqual');
var helper = require('../utils/helper.js');
var tpl = require('../utils/tpl.js');
var object = require('../utils/object.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

var Item = mobxStateTree.types
    .model('Item', {
    storeType: 'Item',
    id: mobxStateTree.types.identifier,
    pristine: mobxStateTree.types.frozen(),
    data: mobxStateTree.types.frozen(),
    index: mobxStateTree.types.number,
    newIndex: mobxStateTree.types.number
})
    .views(function (self) { return ({
    get checked() {
        return mobxStateTree.getParent(self, 2).isSelected(self);
    },
    get modified() {
        if (!self.data) {
            return false;
        }
        return Object.keys(self.data).some(function (key) { return !isEqual__default["default"](self.data[key], self.pristine[key]); });
    },
    get moved() {
        return self.index !== self.newIndex;
    },
    get locals() {
        var listStore = mobxStateTree.getParent(self, 2);
        return object.createObject(object.extendObject(listStore.data, tslib.__assign({ index: self.index }, listStore.eventContext)), self.data);
    },
    get checkable() {
        var table = mobxStateTree.getParent(self, 2);
        return table && table.itemCheckableOn
            ? tpl.evalExpression(table.itemCheckableOn, self.locals)
            : true;
    },
    get draggable() {
        var list = mobxStateTree.getParent(self, 2);
        return list && list.itemDraggableOn
            ? tpl.evalExpression(list.itemDraggableOn, self.locals)
            : list.draggable;
    }
}); })
    .actions(function (self) { return ({
    toggle: function () {
        mobxStateTree.getParent(self, 2).toggle(self);
    },
    change: function (values, savePristine) {
        self.data = helper.immutableExtends(self.data, values);
        savePristine && (self.pristine = self.data);
    },
    reset: function () {
        self.newIndex = self.index;
        self.data = self.pristine;
    },
    updateData: function (_a) {
        _a.children; var rest = tslib.__rest(_a, ["children"]);
        self.data = tslib.__assign(tslib.__assign({}, self.data), rest);
        // if (Array.isArray(children)) {
        // }
    }
}); });
var ListStore = iRenderer.iRendererStore
    .named('ListStore')
    .props({
    items: mobxStateTree.types.array(Item),
    // 记录原始列表和原始选中的列表
    // 因为如果是前端分页，上层 crud 或者 input-table 下发到这层的
    // 是某个页区间的数据，这个时候 items 和 selectedItems 会少很多条
    fullItems: mobxStateTree.types.optional(mobxStateTree.types.array(mobxStateTree.types.frozen()), []),
    fullSelectedItems: mobxStateTree.types.optional(mobxStateTree.types.array(mobxStateTree.types.frozen()), []),
    selectedItems: mobxStateTree.types.array(mobxStateTree.types.reference(Item)),
    primaryField: 'id',
    orderBy: '',
    orderDir: mobxStateTree.types.optional(mobxStateTree.types.union(mobxStateTree.types.literal('asc'), mobxStateTree.types.literal('desc')), 'asc'),
    draggable: false,
    dragging: false,
    multiple: true,
    strictMode: false,
    selectable: false,
    itemCheckableOn: '',
    itemDraggableOn: '',
    hideCheckToggler: false
})
    .views(function (self) {
    function isSelected(item) {
        return !!~self.selectedItems.indexOf(item);
    }
    function getModifiedItems() {
        return self.items.filter(function (item) { return item.modified; });
    }
    function getModified() {
        return getModifiedItems().length;
    }
    function getMovedItems() {
        return self.items.filter(function (item) { return item.moved; });
    }
    function getMovied() {
        return getMovedItems().length;
    }
    return {
        get allChecked() {
            return !!(self.selectedItems.length ===
                self.checkableItems.length &&
                self.checkableItems.length);
        },
        get checkableItems() {
            return self.items.filter(function (item) { return item.checkable; });
        },
        get unSelectedItems() {
            return self.items.filter(function (item) { return !item.checked; });
        },
        isSelected: isSelected,
        get modified() {
            return getModified();
        },
        get modifiedItems() {
            return getModifiedItems();
        },
        get moved() {
            return getMovied();
        },
        get movedItems() {
            return getMovedItems();
        },
        /**
         * 构建事件的上下文数据
         * @param buildChain
         * @returns
         */
        get eventContext() {
            var context = {
                selectedItems: self.selectedItems.map(function (item) { return item.data; }),
                selectedIndexes: self.selectedItems.map(function (item) { return item.index; }),
                items: self.items.map(function (item) { return item.data; }),
                unSelectedItems: this.unSelectedItems.map(function (item) { return item.data; })
            };
            // 如果是前端分页情况，需要根据全量数据计算
            // 如果不是前端分页，数据都没有返回，那种就没办法支持全量数据信息了
            if (self.fullItems.length > self.items.length) {
                // todo 这里的选择顺序会一直变，这个有影响吗?
                var selectedItems_1 = self.fullSelectedItems
                    .filter(function (item) {
                    return !self.items.find(function (row) { return row.pristine === (item.__pristine || item); });
                })
                    .concat(context.selectedItems);
                context.selectedItems = selectedItems_1;
                context.items = self.fullItems.concat();
                context.unSelectedItems = self.fullItems.filter(function (item) { return !selectedItems_1.includes(item); });
                context.selectedIndexes = selectedItems_1.map(function (item) {
                    return self.fullItems.indexOf(item.__pristine || item);
                });
            }
            return context;
        }
    };
})
    .actions(function (self) {
    function update(config) {
        config.selectable === void 0 || (self.selectable = config.selectable);
        config.draggable === void 0 || (self.draggable = config.draggable);
        config.multiple === void 0 || (self.multiple = config.multiple);
        config.strictMode === void 0 || (self.strictMode = config.strictMode);
        config.hideCheckToggler === void 0 ||
            (self.hideCheckToggler = config.hideCheckToggler);
        if (typeof config.orderBy !== 'undefined') {
            setOrderByInfo(config.orderBy, config.orderDir === 'desc' ? 'desc' : 'asc');
        }
        config.itemCheckableOn === void 0 ||
            (self.itemCheckableOn = config.itemCheckableOn);
        config.itemDraggableOn === void 0 ||
            (self.itemDraggableOn = config.itemDraggableOn);
    }
    function initItems(items, fullItems, fullSelectedItems) {
        var arr = items.map(function (item, key) {
            item = object.isObject(item)
                ? item
                : {
                    item: item
                };
            return {
                // id: String((item as any)[self.primaryField] || key),
                id: helper.guid(),
                index: key,
                newIndex: key,
                pristine: item.__pristine || item,
                data: item
            };
        });
        self.selectedItems.clear();
        self.items.replace(arr);
        self.dragging = false;
        Array.isArray(fullItems) && self.fullItems.replace(fullItems);
        Array.isArray(fullSelectedItems) &&
            self.fullSelectedItems.replace(fullSelectedItems);
    }
    function updateSelected(selected, valueField) {
        self.selectedItems.clear();
        selected.forEach(function (item) {
            var resolved = self.items.find(function (a) { return a.pristine === item; });
            // 先严格比较，
            if (!resolved) {
                resolved = self.items.find(function (a) {
                    var selectValue = item[valueField || 'value'];
                    var itemValue = a.pristine[valueField || 'value'];
                    return selectValue === itemValue;
                });
            }
            // 再宽松比较
            if (!resolved) {
                resolved = self.items.find(function (a) {
                    var selectValue = item[valueField || 'value'];
                    var itemValue = a.pristine[valueField || 'value'];
                    return selectValue == itemValue;
                });
            }
            resolved && self.selectedItems.push(resolved);
        });
    }
    function toggleAll() {
        if (self.allChecked) {
            self.selectedItems.clear();
        }
        else {
            self.selectedItems.replace(self.checkableItems);
        }
    }
    function clearAll() {
        self.selectedItems.clear();
    }
    function selectAll() {
        self.selectedItems.replace(self.checkableItems);
    }
    function toggle(item) {
        if (!item.checkable) {
            return;
        }
        var idx = self.selectedItems.indexOf(item);
        if (self.multiple) {
            ~idx
                ? self.selectedItems.splice(idx, 1)
                : self.selectedItems.push(item);
        }
        else {
            ~idx
                ? self.selectedItems.splice(idx, 1)
                : self.selectedItems.replace([item]);
        }
    }
    function clear() {
        self.selectedItems.clear();
    }
    function setOrderByInfo(key, direction) {
        self.orderBy = key;
        self.orderDir = direction;
    }
    function reset() {
        self.items.forEach(function (item) { return item.reset(); });
        self.dragging = false;
    }
    function toggleDragging() {
        self.dragging = !self.dragging;
    }
    function startDragging() {
        self.dragging = true;
    }
    function stopDragging() {
        self.dragging = false;
    }
    function exchange(fromIndex, toIndex) {
        var item = self.items[fromIndex];
        item.newIndex = toIndex;
        var newItems = self.items.slice();
        newItems.splice(fromIndex, 1);
        newItems.splice(toIndex, 0, item);
        self.items.replace(newItems);
    }
    function getData(superData) {
        return object.createObject(superData, tslib.__assign({}, self.eventContext));
    }
    return {
        getData: getData,
        update: update,
        initItems: initItems,
        updateSelected: updateSelected,
        toggleAll: toggleAll,
        clearAll: clearAll,
        selectAll: selectAll,
        toggle: toggle,
        clear: clear,
        setOrderByInfo: setOrderByInfo,
        reset: reset,
        toggleDragging: toggleDragging,
        startDragging: startDragging,
        stopDragging: stopDragging,
        exchange: exchange
    };
});

exports.Item = Item;
exports.ListStore = ListStore;
