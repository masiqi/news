/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var mobxStateTree = require('mobx-state-tree');
var iRenderer = require('./iRenderer.js');
var helper = require('../utils/helper.js');
var errors = require('../utils/errors.js');
var api = require('../utils/api.js');
var replaceText = require('../utils/replaceText.js');
var concatData = require('../utils/concatData.js');
var envOverwrite = require('../envOverwrite.js');
require('amis-formula');
require('moment');
var object = require('../utils/object.js');
require('../utils/memoryParse.js');
require('@rc-component/mini-decimal');
require('lodash/isPlainObject');
require('../utils/filter.js');
require('file-saver');
require('../utils/browser.js');
require('../utils/ColorScale.js');
require('../utils/columnsSplit.js');
require('../utils/DataSchema.js');
require('../utils/DataScope.js');
require('../utils/debug.js');
require('../utils/dom.js');
var tpl = require('../utils/tpl.js');
require('lodash/isObject');
require('lodash/isString');
require('lodash/isBoolean');
require('../utils/highlight.js');
require('../utils/icon.js');
require('../utils/image.js');
require('lodash/isEqual');
require('../actions/Action.js');
require('lodash/debounce');
require('../utils/resize-sensor.js');
require('react');
require('react-overlays/useRootClose');
require('react-dom');
require('../utils/SimpleMap.js');
require('lodash/mapValues');
require('lodash/camelCase');
require('lodash/cloneDeep');
require('lodash/map');
require('lodash/isEmpty');
require('lodash/kebabCase');
require('uncontrollable');
require('hoist-non-react-statics');
require('../utils/validations.js');
require('../utils/resolveCondition.js');
require('mobx');
require('../utils/Animation.js');

var ServiceStore = iRenderer.iRendererStore
    .named('ServiceStore')
    .props({
    msg: '',
    error: false,
    fetching: false,
    saving: false,
    busying: false,
    checking: false,
    initializing: false,
    schema: mobxStateTree.types.optional(mobxStateTree.types.frozen(), null),
    schemaKey: ''
})
    .views(function (self) { return ({
    get loading() {
        return self.fetching || self.saving || self.busying || self.initializing;
    }
}); })
    .actions(function (self) {
    var fetchCancel;
    var fetchSchemaCancel;
    function markFetching(fetching) {
        if (fetching === void 0) { fetching = true; }
        self.fetching = fetching;
    }
    function markSaving(saving) {
        if (saving === void 0) { saving = true; }
        self.saving = saving;
    }
    function markBusying(busying) {
        if (busying === void 0) { busying = true; }
        self.busying = busying;
    }
    function reInitData(data, replace, concatFields) {
        if (replace === void 0) { replace = false; }
        if (concatFields) {
            data = concatData.concatData(data, self.data, concatFields);
        }
        var newData = object.extendObject(self.data, data, !replace);
        self.data = self.pristine = newData;
    }
    function updateMessage(msg, error) {
        if (error === void 0) { error = false; }
        self.msg = (msg && tpl.filter(msg, self.data)) || '';
        self.error = error;
    }
    function clearMessage() {
        updateMessage('');
    }
    var fetchInitData = mobxStateTree.flow(function getInitData(api$1, data, options) {
        var json, replace, data_1, ret, e_1, env, message;
        var _a, _b, _c, _d, _e, _f, _g;
        return tslib.__generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _h.trys.push([0, 6, , 7]);
                    if (fetchCancel) {
                        fetchCancel();
                        fetchCancel = null;
                        self.fetching = false;
                    }
                    if (self.fetching) {
                        return [2 /*return*/];
                    }
                    (options && options.silent) || markFetching(true);
                    return [4 /*yield*/, mobxStateTree.getEnv(self).fetcher(api$1, data, tslib.__assign(tslib.__assign({}, options), { cancelExecutor: function (executor) { return (fetchCancel = executor); } }))];
                case 1:
                    json = _h.sent();
                    fetchCancel = null;
                    if (!!json.ok) return [3 /*break*/, 2];
                    updateMessage((_c = (_b = (_a = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage), true);
                    !api$1.silent &&
                        mobxStateTree.getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    return [3 /*break*/, 5];
                case 2:
                    self.updatedAt = Date.now();
                    replace = !!api$1.replaceData;
                    data_1 = tslib.__assign(tslib.__assign({}, (replace ? {} : self.data)), api.normalizeApiResponseData(json.data));
                    reInitData(data_1, replace, api$1.concatDataFields);
                    self.hasRemoteData = true;
                    if (!(options && options.onSuccess)) return [3 /*break*/, 4];
                    ret = options.onSuccess(json, data_1);
                    if (!(ret && ret.then)) return [3 /*break*/, 4];
                    return [4 /*yield*/, ret];
                case 3:
                    _h.sent();
                    _h.label = 4;
                case 4:
                    updateMessage((_g = (_f = (_e = (_d = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _d === void 0 ? void 0 : _d.success) !== null && _e !== void 0 ? _e : json.msg) !== null && _f !== void 0 ? _f : (options && options.successMessage)) !== null && _g !== void 0 ? _g : json.defaultMsg);
                    // 配置了获取成功提示后提示，默认是空不会提示。
                    options &&
                        options.successMessage &&
                        mobxStateTree.getEnv(self).notify('success', self.msg);
                    _h.label = 5;
                case 5:
                    markFetching(false);
                    return [2 /*return*/, json];
                case 6:
                    e_1 = _h.sent();
                    env = mobxStateTree.getEnv(self);
                    if (!mobxStateTree.isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_1)) {
                        return [2 /*return*/];
                    }
                    markFetching(false);
                    console.error(e_1);
                    message = e_1.message || e_1;
                    if (e_1 && e_1.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !api$1.silent && env.notify('error', message);
                    return [2 /*return*/];
                case 7: return [2 /*return*/];
            }
        });
    });
    var setHasRemoteData = function () {
        self.hasRemoteData = true;
    };
    var fetchData = mobxStateTree.flow(function getInitData(api$1, data, options) {
        var json, ret, e_2, env, message;
        var _a, _b, _c, _d, _e, _f;
        return tslib.__generator(this, function (_g) {
            switch (_g.label) {
                case 0:
                    _g.trys.push([0, 6, , 7]);
                    if (fetchCancel) {
                        fetchCancel();
                        fetchCancel = null;
                        self.fetching = false;
                    }
                    if (self.fetching) {
                        return [2 /*return*/];
                    }
                    (options && options.silent) || markFetching(true);
                    return [4 /*yield*/, mobxStateTree.getEnv(self).fetcher(api$1, data, tslib.__assign(tslib.__assign({}, options), { cancelExecutor: function (executor) { return (fetchCancel = executor); } }))];
                case 1:
                    json = _g.sent();
                    fetchCancel = null;
                    if (!helper.isEmpty(json.data) || json.ok) {
                        self.updatedAt = Date.now();
                        json.data &&
                            self.updateData(api.normalizeApiResponseData(json.data), undefined, !!api$1.replaceData, api$1.concatDataFields, {
                                type: 'api'
                            });
                        self.hasRemoteData = true;
                    }
                    if (!!json.ok) return [3 /*break*/, 2];
                    updateMessage((_c = (_b = (_a = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage), true);
                    !api$1.silent &&
                        mobxStateTree.getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    return [3 /*break*/, 5];
                case 2:
                    if (!(options && options.onSuccess)) return [3 /*break*/, 4];
                    ret = options.onSuccess(json, json.data);
                    if (!(ret && ret.then)) return [3 /*break*/, 4];
                    return [4 /*yield*/, ret];
                case 3:
                    _g.sent();
                    _g.label = 4;
                case 4:
                    updateMessage((_f = (_e = (_d = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _d === void 0 ? void 0 : _d.success) !== null && _e !== void 0 ? _e : json.msg) !== null && _f !== void 0 ? _f : (options && options.successMessage));
                    // 配置了获取成功提示后提示，默认是空不会提示。
                    options &&
                        options.successMessage &&
                        mobxStateTree.getEnv(self).notify('success', self.msg);
                    _g.label = 5;
                case 5:
                    markFetching(false);
                    return [2 /*return*/, json];
                case 6:
                    e_2 = _g.sent();
                    env = mobxStateTree.getEnv(self);
                    if (!mobxStateTree.isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_2)) {
                        return [2 /*return*/];
                    }
                    markFetching(false);
                    console.error(e_2);
                    message = e_2.message || e_2;
                    if (e_2 && e_2.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !api$1.silent && env.notify('error', message);
                    return [2 /*return*/];
                case 7: return [2 /*return*/];
            }
        });
    });
    var saveRemote = mobxStateTree.flow(function saveRemote(api$1, data, options) {
        var json, ret, ret, e_3, result;
        var _a, _b, _c, _d, _e, _f, _g;
        if (options === void 0) { options = {}; }
        return tslib.__generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _h.trys.push([0, 8, , 9]);
                    options = tslib.__assign({ method: 'post' }, options);
                    if (self.saving) {
                        return [2 /*return*/];
                    }
                    markSaving(true);
                    return [4 /*yield*/, mobxStateTree.getEnv(self).fetcher(api$1, data, options)];
                case 1:
                    json = _h.sent();
                    if (!helper.isEmpty(json.data) || json.ok) {
                        self.updatedAt = Date.now();
                        json.data &&
                            self.updateData(api.normalizeApiResponseData(json.data), undefined, !!api$1.replaceData, api$1.concatDataFields, {
                                type: 'api'
                            });
                    }
                    if (!!json.ok) return [3 /*break*/, 4];
                    if (!(options && options.onFailed)) return [3 /*break*/, 3];
                    ret = options.onFailed(json);
                    if (!(ret && ret.then)) return [3 /*break*/, 3];
                    return [4 /*yield*/, ret];
                case 2:
                    _h.sent();
                    _h.label = 3;
                case 3:
                    updateMessage((_d = (_c = (_b = (_a = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage)) !== null && _d !== void 0 ? _d : self.__('saveFailed'), true);
                    throw new errors.ServerError(self.msg, json);
                case 4:
                    if (!(options && options.onSuccess)) return [3 /*break*/, 6];
                    ret = options.onSuccess(json, json.data);
                    if (!(ret && ret.then)) return [3 /*break*/, 6];
                    return [4 /*yield*/, ret];
                case 5:
                    _h.sent();
                    _h.label = 6;
                case 6:
                    updateMessage((_g = (_f = (_e = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _e === void 0 ? void 0 : _e.success) !== null && _f !== void 0 ? _f : json.msg) !== null && _g !== void 0 ? _g : (options && options.successMessage));
                    self.msg &&
                        mobxStateTree.getEnv(self).notify('success', self.msg, json.msgTimeout !== undefined
                            ? {
                                closeButton: true,
                                timeout: json.msgTimeout
                            }
                            : undefined);
                    _h.label = 7;
                case 7:
                    markSaving(false);
                    return [2 /*return*/, json.data];
                case 8:
                    e_3 = _h.sent();
                    self.saving = false;
                    if (!mobxStateTree.isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    console.error(e_3);
                    if (!api$1.silent) {
                        if (e_3.type === 'ServerError') {
                            result = e_3.response;
                            mobxStateTree.getEnv(self).notify('error', e_3.message, result.msgTimeout !== undefined
                                ? {
                                    closeButton: true,
                                    timeout: result.msgTimeout
                                }
                                : undefined);
                        }
                        else {
                            mobxStateTree.getEnv(self).notify('error', e_3.message);
                        }
                    }
                    throw e_3;
                case 9: return [2 /*return*/];
            }
        });
    });
    var fetchSchema = mobxStateTree.flow(function fetchSchema(api$1, data, options) {
        var json, env, e_4, env, message;
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (options === void 0) { options = {}; }
        return tslib.__generator(this, function (_j) {
            switch (_j.label) {
                case 0:
                    _j.trys.push([0, 2, , 3]);
                    options = tslib.__assign(tslib.__assign({ method: 'post' }, options), { cancelExecutor: function (executor) { return (fetchSchemaCancel = executor); } });
                    if (fetchSchemaCancel) {
                        fetchSchemaCancel();
                        fetchSchemaCancel = null;
                        self.initializing = false;
                    }
                    if (self.initializing) {
                        return [2 /*return*/];
                    }
                    self.initializing = true;
                    if (typeof api$1 === 'string') {
                        api$1 += (~api$1.indexOf('?') ? '&' : '?') + '_replace=1';
                    }
                    else {
                        api$1 = tslib.__assign(tslib.__assign({}, api$1), { url: api$1.url +
                                (~api$1.url.indexOf('?') ? '&' : '?') +
                                '_replace=1' });
                    }
                    return [4 /*yield*/, mobxStateTree.getEnv(self).fetcher(api$1, data, options)];
                case 1:
                    json = _j.sent();
                    fetchSchemaCancel = null;
                    if (!json.ok) {
                        updateMessage((_d = (_c = (_b = (_a = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _a === void 0 ? void 0 : _a.failed) !== null && _b !== void 0 ? _b : json.msg) !== null && _c !== void 0 ? _c : (options && options.errorMessage)) !== null && _d !== void 0 ? _d : self.__('fetchFailed'), true);
                        !(api$1 === null || api$1 === void 0 ? void 0 : api$1.silent) &&
                            mobxStateTree.getEnv(self).notify('error', self.msg, json.msgTimeout !== undefined
                                ? {
                                    closeButton: true,
                                    timeout: json.msgTimeout
                                }
                                : undefined);
                    }
                    else {
                        if (json.data) {
                            env = mobxStateTree.getEnv(self);
                            json.data = envOverwrite.envOverwrite(json.data, env.locale);
                            json.data = replaceText.replaceText(json.data, env.replaceText, env.replaceTextIgnoreKeys);
                            self.schema = Array.isArray(json.data)
                                ? json.data
                                : Object.assign(((_e = json.data) === null || _e === void 0 ? void 0 : _e.type)
                                    ? {}
                                    : {
                                        type: 'wrapper',
                                        wrap: false
                                    }, api.normalizeApiResponseData(json.data));
                            self.schemaKey = '' + Date.now();
                            object.isObject(json.data.data) &&
                                self.updateData(json.data.data, undefined, !!api$1.replaceData, api$1.concatDataFields, {
                                    type: 'api'
                                });
                        }
                        updateMessage((_h = (_g = (_f = api$1 === null || api$1 === void 0 ? void 0 : api$1.messages) === null || _f === void 0 ? void 0 : _f.success) !== null && _g !== void 0 ? _g : json.msg) !== null && _h !== void 0 ? _h : (options && options.successMessage));
                        // 配置了获取成功提示后提示，默认是空不会提示。
                        options &&
                            options.successMessage &&
                            mobxStateTree.getEnv(self).notify('success', self.msg);
                    }
                    self.initializing = false;
                    return [2 /*return*/, json.data];
                case 2:
                    e_4 = _j.sent();
                    env = mobxStateTree.getEnv(self);
                    self.initializing = false;
                    if (!mobxStateTree.isAlive(self) || self.disposed) {
                        return [2 /*return*/];
                    }
                    if (env.isCancel(e_4)) {
                        return [2 /*return*/];
                    }
                    console.error(e_4);
                    message = e_4.message || e_4;
                    if (e_4 && e_4.message === 'Network Error') {
                        message = self.__('networkError');
                    }
                    !(api$1 === null || api$1 === void 0 ? void 0 : api$1.silent) && env.notify('error', message);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
    var checkRemote = mobxStateTree.flow(function checkRemote(api, data, options) {
        var json;
        return tslib.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (self.checking) {
                        return [2 /*return*/];
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    self.checking = true;
                    return [4 /*yield*/, mobxStateTree.getEnv(self).fetcher(api, data, options)];
                case 2:
                    json = _a.sent();
                    json.ok &&
                        self.updateData(json.data, undefined, !!api.replaceData, api.concatDataFields);
                    if (!json.ok) {
                        throw new Error(json.msg);
                    }
                    return [2 /*return*/, json.data];
                case 3:
                    self.checking = false;
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    });
    return {
        markFetching: markFetching,
        markSaving: markSaving,
        markBusying: markBusying,
        fetchInitData: fetchInitData,
        fetchData: fetchData,
        reInitData: reInitData,
        updateMessage: updateMessage,
        clearMessage: clearMessage,
        setHasRemoteData: setHasRemoteData,
        saveRemote: saveRemote,
        fetchSchema: fetchSchema,
        checkRemote: checkRemote
    };
});

exports.ServiceStore = ServiceStore;
