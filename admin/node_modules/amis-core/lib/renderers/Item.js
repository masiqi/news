/**
 * amis-core v6.13.0
 * Copyright 2018-2025 fex
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var React = require('react');
var hoistNonReactStatic = require('hoist-non-react-statics');
var mobx = require('mobx');
var mobxStateTree = require('mobx-state-tree');
var factory = require('../factory.js');
var helper = require('../utils/helper.js');
var mobxReact = require('mobx-react');
var WithStore = require('../WithStore.js');
var wrapControl = require('./wrapControl.js');
var debounce = require('lodash/debounce');
var api = require('../utils/api.js');
var ReactDOM = require('react-dom');
require('../utils/index.js');
var Overlay = require('../components/Overlay.js');
var PopOver = require('../components/PopOver.js');
var CustomStyle = require('../components/CustomStyle.js');
var cx = require('classnames');
var isPlainObject = require('lodash/isPlainObject');
var styleHelper = require('../utils/style-helper.js');
var getVariable = require('../utils/getVariable.js');
var object = require('../utils/object.js');
var dataMapping = require('../utils/dataMapping.js');
var keyToPath = require('../utils/keyToPath.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var hoistNonReactStatic__default = /*#__PURE__*/_interopDefaultLegacy(hoistNonReactStatic);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);
var isPlainObject__default = /*#__PURE__*/_interopDefaultLegacy(isPlainObject);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
var _J$F_ = (__react_jsx__["default"] || __react_jsx__).Fragment;


;var getItemLabelClassName = function (props) {
    var staticLabelClassName = props.staticLabelClassName, labelClassName = props.labelClassName, id = props.id, themeCss = props.themeCss;
    return props.static && staticLabelClassName
        ? staticLabelClassName
        : cx__default["default"](labelClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'labelClassName', id: id, themeCss: themeCss, extra: 'item' })));
};
var getItemInputClassName = function (props) {
    var staticInputClassName = props.staticInputClassName, inputClassName = props.inputClassName;
    return props.static && staticInputClassName
        ? staticInputClassName
        : inputClassName;
};
var FormItemWrap = /** @class */ (function (_super) {
    tslib.__extends(FormItemWrap, _super);
    function FormItemWrap(props) {
        var _this = _super.call(this, props) || this;
        _this.mounted = false;
        _this.initedOptionFilled = false;
        _this.initedApiFilled = false;
        _this.toDispose = [];
        _this.syncApiAutoFill = debounce__default["default"](function (term, forceLoad, skipIfExits) {
            if (skipIfExits === void 0) { skipIfExits = false; }
            return tslib.__awaiter(_this, void 0, void 0, function () {
                var _a, autoFill, onBulkChange, formItem, data_1, itemName, ctx, result, e_1;
                var _b, _c, _d;
                return tslib.__generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            _e.trys.push([0, 4, , 5]);
                            _a = this.props, autoFill = _a.autoFill, onBulkChange = _a.onBulkChange, formItem = _a.formItem, data_1 = _a.data;
                            // 参照录入
                            if (!onBulkChange ||
                                !formItem ||
                                !autoFill ||
                                (autoFill && !(autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('api')))) {
                                return [2 /*return*/];
                            }
                            else if (skipIfExits &&
                                (!autoFill.fillMapping ||
                                    Object.keys(autoFill.fillMapping).some(function (key) { return typeof getVariable.getVariable(data_1, key) !== 'undefined'; }))) {
                                // 只要目标填充值有一个有值，就初始不自动填充
                                return [2 /*return*/];
                            }
                            if (!(autoFill === null || autoFill === void 0 ? void 0 : autoFill.showSuggestion)) return [3 /*break*/, 1];
                            this.handleAutoFill('change');
                            return [3 /*break*/, 3];
                        case 1:
                            itemName = formItem.name;
                            ctx = object.createObject(data_1, {
                                __term: term
                            });
                            object.setVariable(ctx, itemName, term);
                            if (!(forceLoad ||
                                (api.isEffectiveApi(autoFill.api, ctx) && this.lastSearchTerm !== term))) return [3 /*break*/, 3];
                            return [4 /*yield*/, formItem.loadAutoUpdateData(autoFill.api, ctx, !!((_b = autoFill.api) === null || _b === void 0 ? void 0 : _b.silent))];
                        case 2:
                            result = _e.sent();
                            this.lastSearchTerm =
                                (_c = (result && getVariable.getVariable(result, itemName))) !== null && _c !== void 0 ? _c : term;
                            // 如果没有返回不应该处理
                            if (!result) {
                                return [2 /*return*/];
                            }
                            this.applyMapping((_d = autoFill === null || autoFill === void 0 ? void 0 : autoFill.fillMapping) !== null && _d !== void 0 ? _d : { '&': '$$' }, result, false);
                            _e.label = 3;
                        case 3: return [3 /*break*/, 5];
                        case 4:
                            e_1 = _e.sent();
                            console.error(e_1);
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        }, 250, {
            trailing: true,
            leading: false
        });
        var model = props.formItem, formInited = props.formInited, addHook = props.addHook, initAutoFill = props.initAutoFill;
        if (!model) {
            return _this;
        }
        _this.toDispose.push(mobx.reaction(function () {
            return "".concat(model.errors.join('')).concat(model.isFocused).concat(model.dialogOpen).concat(JSON.stringify(model.filteredOptions)).concat(model.popOverOpen);
        }, function () { return _this.forceUpdate(); }));
        var onInit = function () {
            var _a;
            _this.initedOptionFilled = true;
            initAutoFill !== false &&
                mobxStateTree.isAlive(model) &&
                _this.syncOptionAutoFill(model.getSelectedOptions(model.tmpValue), initAutoFill === 'fillIfNotSet');
            _this.initedApiFilled = true;
            initAutoFill !== false &&
                mobxStateTree.isAlive(model) &&
                _this.syncApiAutoFill((_a = model.tmpValue) !== null && _a !== void 0 ? _a : '', false, initAutoFill === 'fillIfNotSet');
            _this.toDispose.push(mobx.reaction(function () { return JSON.stringify(model.tmpValue); }, function () {
                return _this.mounted &&
                    _this.initedApiFilled &&
                    _this.syncApiAutoFill(model.tmpValue);
            }));
            _this.toDispose.push(mobx.reaction(function () { return JSON.stringify(model.getSelectedOptions(model.tmpValue)); }, function () {
                return _this.mounted &&
                    _this.initedOptionFilled &&
                    _this.syncOptionAutoFill(model.getSelectedOptions(model.tmpValue));
            }));
        };
        _this.toDispose.push(formInited || !addHook
            ? model.addInitHook(onInit, 999)
            : addHook(onInit, 'init', 'post'));
        return _this;
    }
    FormItemWrap.prototype.componentDidMount = function () {
        this.mounted = true;
        this.target = ReactDOM.findDOMNode(this);
    };
    FormItemWrap.prototype.componentDidUpdate = function (prevProps) {
        var _a, _b, _c;
        var props = this.props;
        var model = props.formItem;
        if (api.isEffectiveApi((_a = props.autoFill) === null || _a === void 0 ? void 0 : _a.api, props.data) &&
            api.isApiOutdated((_b = prevProps.autoFill) === null || _b === void 0 ? void 0 : _b.api, (_c = props.autoFill) === null || _c === void 0 ? void 0 : _c.api, prevProps.data, props.data)) {
            this.syncApiAutoFill(model === null || model === void 0 ? void 0 : model.tmpValue, true);
        }
    };
    FormItemWrap.prototype.componentWillUnmount = function () {
        this.syncApiAutoFill.cancel();
        this.mounted = false;
        this.toDispose.forEach(function (fn) { return fn(); });
        this.toDispose = [];
    };
    FormItemWrap.prototype.handleFocus = function (e) {
        var _a = this.props, model = _a.formItem, autoFill = _a.autoFill;
        model && model.focus();
        this.props.onFocus && this.props.onFocus(e);
        if (!autoFill ||
            (autoFill && !(autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('showSuggestion')))) {
            return;
        }
        this.handleAutoFill('focus');
    };
    FormItemWrap.prototype.handleBlur = function (e) {
        var _a = this.props, model = _a.formItem, autoFill = _a.autoFill;
        model && model.blur();
        this.props.onBlur && this.props.onBlur(e);
        if (!autoFill ||
            (autoFill && !(autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('showSuggestion')))) {
            return;
        }
        this.handleAutoFill('blur');
    };
    FormItemWrap.prototype.handleAutoFill = function (type) {
        var _this = this;
        var _a = this.props, autoFill = _a.autoFill, formItem = _a.formItem, data = _a.data;
        var trigger = autoFill.trigger, mode = autoFill.mode;
        if (trigger === type && mode === 'popOver') {
            // 参照录入 popOver形式
            formItem === null || formItem === void 0 ? void 0 : formItem.openPopOver(this.buildAutoFillSchema(), data, function (confirmed, result) {
                if (!confirmed || !(result === null || result === void 0 ? void 0 : result.selectedItems)) {
                    return;
                }
                _this.updateAutoFillData(result.selectedItems);
            });
        }
        else if (
        // 参照录入 dialog | drawer
        trigger === type &&
            (mode === 'dialog' || mode === 'drawer')) {
            formItem === null || formItem === void 0 ? void 0 : formItem.openDialog(this.buildAutoFillSchema(), data, function (confirmed, result) {
                if (!confirmed || !(result === null || result === void 0 ? void 0 : result.selectedItems)) {
                    return;
                }
                _this.updateAutoFillData(result.selectedItems);
            });
        }
    };
    FormItemWrap.prototype.updateAutoFillData = function (context) {
        var _a = this.props, data = _a.data, autoFill = _a.autoFill, onBulkChange = _a.onBulkChange;
        var fillMapping = autoFill.fillMapping, multiple = autoFill.multiple;
        // form原始数据
        var contextData = Array.isArray(context)
            ? object.createObject(data, {
                items: context
            })
            : object.createObjectFromChain([
                data,
                {
                    items: [context]
                },
                context
            ]);
        this.applyMapping(fillMapping !== null && fillMapping !== void 0 ? fillMapping : {}, contextData, false);
    };
    FormItemWrap.prototype.syncOptionAutoFill = function (selectedOptions, skipIfExits) {
        if (skipIfExits === void 0) { skipIfExits = false; }
        var _a = this.props, autoFill = _a.autoFill, multiple = _a.multiple, onBulkChange = _a.onBulkChange, data = _a.data;
        var formItem = this.props.formItem;
        // 参照录入｜自动填充
        if (autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('api')) {
            return;
        }
        if (onBulkChange &&
            autoFill &&
            !helper.isEmpty(autoFill) &&
            formItem.filteredOptions.length) {
            this.applyMapping(autoFill, multiple
                ? {
                    items: selectedOptions.map(function (item) {
                        return object.createObject(tslib.__assign(tslib.__assign({}, data), { ancestors: helper.getTreeAncestors(formItem.filteredOptions, item, true) }), item);
                    })
                }
                : object.createObject(tslib.__assign(tslib.__assign({}, data), { ancestors: helper.getTreeAncestors(formItem.filteredOptions, selectedOptions[0], true) }), selectedOptions[0]), skipIfExits);
        }
    };
    /**
     * 应用映射函数，根据给定的映射关系，更新数据对象
     *
     * @param mapping 映射关系，类型为任意类型
     * @param ctx 上下文对象，类型为任意类型
     * @param skipIfExits 是否跳过已存在的属性，默认为 false
     */
    FormItemWrap.prototype.applyMapping = function (mapping, ctx, skipIfExits) {
        if (skipIfExits === void 0) { skipIfExits = false; }
        var _a = this.props, onBulkChange = _a.onBulkChange, data = _a.data, formItem = _a.formItem;
        var toSync = dataMapping.dataMapping(mapping, ctx);
        var tmpData = tslib.__assign({}, data);
        var result = tslib.__assign({}, toSync);
        Object.keys(mapping).forEach(function (key) {
            if (key === '&') {
                return;
            }
            var keys = keyToPath.keyToPath(key);
            var value = getVariable.getVariable(toSync, key);
            if (skipIfExits) {
                var originValue = getVariable.getVariable(data, key);
                if (typeof originValue !== 'undefined') {
                    value = originValue;
                }
            }
            object.setVariable(result, key, value);
            // 如果左边的 key 是一个路径
            // 这里不希望直接把原始对象都给覆盖没了
            // 而是保留原始的对象，只修改指定的属性
            if (keys.length > 1 && isPlainObject__default["default"](tmpData[keys[0]])) {
                // 存在情况：依次更新同一子路径的多个key，eg: a.b.c1 和 a.b.c2，所以需要同步更新data
                object.setVariable(tmpData, key, value);
                result[keys[0]] = tmpData[keys[0]];
            }
        });
        // 是否忽略自己的设置
        // if (ignoreSelf && formItem?.name) {
        //   deleteVariable(result, formItem.name);
        // }
        onBulkChange(result);
    };
    FormItemWrap.prototype.buildAutoFillSchema = function () {
        var _a = this.props, formItem = _a.formItem, autoFill = _a.autoFill, __ = _a.translate;
        if (!autoFill || (autoFill && !(autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('api')))) {
            return;
        }
        var api = autoFill.api, mode = autoFill.mode, size = autoFill.size, offset = autoFill.offset, position = autoFill.position, placement = autoFill.placement, multiple = autoFill.multiple, filter = autoFill.filter, columns = autoFill.columns, labelField = autoFill.labelField, popOverContainer = autoFill.popOverContainer, popOverClassName = autoFill.popOverClassName, valueField = autoFill.valueField, defaultSelection = autoFill.defaultSelection;
        var form = {
            type: 'form',
            // debug: true,
            title: '',
            className: 'suggestion-form',
            body: [
                {
                    type: 'picker',
                    embed: true,
                    joinValues: false,
                    strictMode: false,
                    label: false,
                    labelField: labelField,
                    valueField: valueField || 'value',
                    multiple: multiple,
                    name: 'selectedItems',
                    value: defaultSelection || [],
                    options: [],
                    required: true,
                    source: api,
                    pickerSchema: {
                        type: 'crud',
                        bodyClassName: 'mb-0',
                        affixHeader: false,
                        alwaysShowPagination: true,
                        keepItemSelectionOnPageChange: true,
                        headerToolbar: [],
                        footerToolbar: [
                            {
                                type: 'pagination',
                                align: 'left'
                            },
                            {
                                type: 'bulkActions',
                                align: 'right',
                                className: 'ml-2'
                            }
                        ],
                        multiple: multiple,
                        filter: filter,
                        columns: columns || []
                    }
                }
            ],
            actions: [
                {
                    type: 'button',
                    actionType: 'cancel',
                    label: __('cancel')
                },
                {
                    type: 'submit',
                    actionType: 'submit',
                    level: 'primary',
                    label: __('confirm')
                }
            ]
        };
        if (mode === 'popOver') {
            return {
                popOverContainer: popOverContainer,
                popOverClassName: popOverClassName,
                placement: placement !== null && placement !== void 0 ? placement : position,
                offset: offset,
                body: form
            };
        }
        else {
            return {
                type: mode,
                className: 'auto-fill-dialog',
                title: __('FormItem.autoFillSuggest'),
                size: size,
                body: tslib.__assign(tslib.__assign({}, form), { wrapWithPanel: false }),
                actions: [
                    {
                        type: 'button',
                        actionType: 'cancel',
                        label: __('cancel')
                    },
                    {
                        type: 'submit',
                        actionType: 'submit',
                        level: 'primary',
                        label: __('confirm')
                    }
                ]
            };
        }
    };
    // 参照录入popOver提交
    FormItemWrap.prototype.handlePopOverConfirm = function (values) {
        var _a = this.props, onBulkChange = _a.onBulkChange, autoFill = _a.autoFill;
        if (!autoFill || (autoFill && !(autoFill === null || autoFill === void 0 ? void 0 : autoFill.hasOwnProperty('api')))) {
            return;
        }
        this.updateAutoFillData(values.selectedItems);
        this.closePopOver();
    };
    FormItemWrap.prototype.handlePopOverAction = function (e, action, data, throwErrors, delegate) {
        if (throwErrors === void 0) { throwErrors = false; }
        var onAction = this.props.onAction;
        if (action.actionType === 'cancel') {
            this.closePopOver();
        }
        else if (onAction) {
            // 不识别的丢给上层去处理。
            return onAction(e, action, data, throwErrors, delegate);
        }
    };
    FormItemWrap.prototype.closePopOver = function () {
        var _a;
        (_a = this.props.formItem) === null || _a === void 0 ? void 0 : _a.closePopOver();
    };
    FormItemWrap.prototype.handleOpenDialog = function (schema, data) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var model;
            return tslib.__generator(this, function (_a) {
                model = this.props.formItem;
                if (!model) {
                    return [2 /*return*/];
                }
                return [2 /*return*/, new Promise(function (resolve) {
                        return model.openDialog(schema, data, function (confirmed, value) {
                            return resolve(confirmed ? value : false);
                        });
                    })];
            });
        });
    };
    FormItemWrap.prototype.handleDialogConfirm = function (_a) {
        var _b = tslib.__read(_a, 1), values = _b[0];
        var model = this.props.formItem;
        if (!model) {
            return;
        }
        model.closeDialog(true, values);
    };
    FormItemWrap.prototype.handleDialogClose = function (confirmed) {
        if (confirmed === void 0) { confirmed = false; }
        var model = this.props.formItem;
        if (!model) {
            return;
        }
        model.closeDialog(confirmed);
    };
    FormItemWrap.prototype.renderControl = function () {
        var _a;
        var _b = this.props, 
        // 这里解构，不可轻易删除，避免被rest传到子组件
        inputClassName = _b.inputClassName, model = _b.formItem, cx = _b.classnames, children = _b.children, type = _b.type, renderControl = _b.renderControl, formItemConfig = _b.formItemConfig, sizeMutable = _b.sizeMutable, size = _b.size, defaultSize = _b.defaultSize, mobileUI = _b.mobileUI, rest = tslib.__rest(_b, ["inputClassName", "formItem", "classnames", "children", "type", "renderControl", "formItemConfig", "sizeMutable", "size", "defaultSize", "mobileUI"]);
        if (renderControl) {
            var controlSize = size || defaultSize;
            return renderControl(tslib.__assign(tslib.__assign({}, rest), { onOpenDialog: this.handleOpenDialog, type: type, classnames: cx, formItem: model, className: cx("Form-control", (_a = {
                        'is-inline': !!rest.inline && !mobileUI,
                        'is-error': model && !model.valid,
                        'is-full': size === 'full'
                    },
                    _a["Form-control--withSize Form-control--size".concat(helper.ucFirst(controlSize))] = sizeMutable !== false &&
                        typeof controlSize === 'string' &&
                        !!controlSize &&
                        controlSize !== 'full',
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, this.props), { name: 'wrapperCustomStyle', id: rest.id, themeCss: rest.wrapperCustomStyle, extra: 'item' })), getItemInputClassName(this.props)) }));
        }
        return null;
    };
    FormItemWrap.prototype.render = function () {
        var _this = this;
        var _a, _b, _c, _d;
        var _e = this.props, formMode = _e.formMode, inputOnly = _e.inputOnly, wrap = _e.wrap, render = _e.render, model = _e.formItem, css = _e.css, themeCss = _e.themeCss, id = _e.id, wrapperCustomStyle = _e.wrapperCustomStyle, env = _e.env, cx = _e.classnames, popOverContainer = _e.popOverContainer, data = _e.data;
        var mode = this.props.mode || formMode;
        if (wrap === false || inputOnly) {
            return this.renderControl();
        }
        var renderLayout = FormItemWrap.layoutRenderers[mode] ||
            FormItemWrap.layoutRenderers['normal'];
        return (_J$X_(React__default["default"].Fragment, null,
            renderLayout(this.props, this.renderControl.bind(this)),
            model
                ? render('modal', tslib.__assign({ type: 'dialog' }, model.dialogSchema), {
                    show: model.dialogOpen,
                    onClose: this.handleDialogClose,
                    onConfirm: this.handleDialogConfirm,
                    data: model.dialogData,
                    formStore: undefined
                })
                : null,
            model ? (_J$X_(Overlay["default"], { container: popOverContainer || this.target, target: function () { return _this.target; }, placement: ((_a = model.popOverSchema) === null || _a === void 0 ? void 0 : _a.placement) || 'left-bottom-left-top', show: model.popOverOpen },
                _J$X_(PopOver["default"], { className: cx("Autofill-popOver", (_b = model.popOverSchema) === null || _b === void 0 ? void 0 : _b.popOverClassName), style: {
                        minWidth: this.target ? this.target.offsetWidth : undefined
                    }, offset: (_c = model.popOverSchema) === null || _c === void 0 ? void 0 : _c.offset, onHide: this.closePopOver }, render('popOver-auto-fill-form', (_d = model.popOverSchema) === null || _d === void 0 ? void 0 : _d.body, {
                    // data: model.popOverData,
                    onAction: this.handlePopOverAction,
                    onSubmit: this.handlePopOverConfirm
                })))) : null,
            _J$X_(CustomStyle["default"], tslib.__assign({}, this.props, { config: {
                    themeCss: themeCss || css,
                    classNames: [
                        {
                            key: 'labelClassName',
                            weights: {
                                default: {
                                    suf: ".".concat(cx('Form-label')),
                                    parent: ".".concat(cx('Form-item'))
                                }
                            }
                        },
                        {
                            key: 'descriptionClassName'
                        }
                    ],
                    wrapperCustomStyle: wrapperCustomStyle,
                    id: id && id + '-item'
                }, env: env }))));
    };
    /**
     * 布局扩充点，可以自己扩充表单项的布局方式
     */
    FormItemWrap.layoutRenderers = {
        horizontal: function (props, renderControl) {
            var _a, _b, _c;
            var className = props.className, style = props.style, cx = props.classnames, description = props.description, descriptionClassName = props.descriptionClassName, captionClassName = props.captionClassName, desc = props.desc, label = props.label, render = props.render, required = props.required, caption = props.caption, remark = props.remark, labelRemark = props.labelRemark, env = props.env, model = props.formItem, renderLabel = props.renderLabel, renderDescription = props.renderDescription, hint = props.hint, data = props.data, showErrorMsg = props.showErrorMsg, mobileUI = props.mobileUI, __ = props.translate, isStatic = props.static, staticClassName = props.staticClassName, id = props.id, wrapperCustomStyle = props.wrapperCustomStyle, themeCss = props.themeCss;
            // 强制不渲染 label 的话
            if (renderLabel === false) {
                label = label === false ? false : '';
            }
            description = description || desc;
            var horizontal = props.horizontal || props.formHorizontal || {};
            var left = helper.getWidthRate(horizontal.left);
            var right = helper.getWidthRate(horizontal.right);
            var labelAlign = (props.labelAlign !== 'inherit' && props.labelAlign) ||
                props.formLabelAlign;
            var labelWidth = props.labelWidth || props.formLabelWidth;
            var labelOverflow = props.labelOverflow || props.formLabelOverflow;
            return (_J$X_("div", { "data-role": "form-item", "data-amis-name": props.name, className: cx("Form-item Form-item--horizontal", isStatic && staticClassName ? staticClassName : className, (_a = {
                        'Form-item--horizontal-justify': horizontal.justify
                    },
                    _a["is-error"] = model && !model.valid,
                    _a["is-required"] = required,
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'wrapperCustomStyle', id: id, themeCss: wrapperCustomStyle, extra: 'item' }))), style: style },
                label !== false ? (_J$X_("label", { className: cx("Form-label", (_b = {},
                        _b["Form-itemColumn--".concat(typeof horizontal.leftFixed === 'string'
                            ? horizontal.leftFixed
                            : 'normal')] = horizontal.leftFixed,
                        _b["Form-itemColumn--".concat(left)] = !horizontal.leftFixed,
                        _b['Form-label--left'] = labelAlign === 'left',
                        _b['Form-label-noLabel'] = label === '',
                        _b), getItemLabelClassName(props)), style: labelWidth != null ? { width: labelWidth } : undefined },
                    _J$X_("span", tslib.__assign({}, (labelOverflow === 'ellipsis'
                        ? {
                            className: cx('Form-ellipsis'),
                            title: label
                        }
                        : {})),
                        label ? render('label', label) : null,
                        required && (label || labelRemark) ? (_J$X_("span", { className: cx("Form-star") }, "*")) : null,
                        labelRemark
                            ? render('label-remark', {
                                type: 'remark',
                                icon: labelRemark.icon || 'warning-mark',
                                tooltip: labelRemark,
                                mobileUI: mobileUI,
                                className: cx("Form-labelRemark"),
                                container: props.popOverContainer || env.getModalContainer
                            })
                            : null))) : null,
                _J$X_("div", { className: cx("Form-value", (_c = {},
                        // [`Form-itemColumn--offset${getWidthRate(horizontal.offset)}`]: !label && label !== false,
                        _c["Form-itemColumn--".concat(right)] = !horizontal.leftFixed && !!right && right !== 12 - left,
                        _c)) },
                    renderControl(),
                    caption
                        ? render('caption', caption, {
                            className: cx("Form-caption", captionClassName)
                        })
                        : null,
                    remark
                        ? render('remark', {
                            type: 'remark',
                            icon: remark.icon || 'warning-mark',
                            tooltip: remark,
                            className: cx("Form-remark"),
                            mobileUI: mobileUI,
                            container: props.popOverContainer || env.getModalContainer
                        })
                        : null,
                    hint && model && model.isFocused
                        ? render('hint', hint, {
                            className: cx("Form-hint")
                        })
                        : null,
                    model &&
                        !model.valid &&
                        showErrorMsg !== false &&
                        Array.isArray(model.errors) ? (_J$X_("ul", { className: cx("Form-feedback") }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                    renderDescription !== false && description
                        ? render('description', description, {
                            className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                        })
                        : null)));
        },
        normal: function (props, renderControl) {
            var _a;
            var className = props.className, style = props.style, cx = props.classnames, desc = props.desc, description = props.description, label = props.label, render = props.render, required = props.required, caption = props.caption, remark = props.remark, labelRemark = props.labelRemark, env = props.env, descriptionClassName = props.descriptionClassName, captionClassName = props.captionClassName, model = props.formItem, renderLabel = props.renderLabel, renderDescription = props.renderDescription, hint = props.hint, data = props.data, showErrorMsg = props.showErrorMsg, mobileUI = props.mobileUI, __ = props.translate, isStatic = props.static, staticClassName = props.staticClassName, themeCss = props.themeCss, wrapperCustomStyle = props.wrapperCustomStyle, id = props.id;
            description = description || desc;
            return (_J$X_("div", { "data-role": "form-item", "data-amis-name": props.name, className: cx("Form-item Form-item--normal", isStatic && staticClassName ? staticClassName : className, (_a = {
                        'is-error': model && !model.valid
                    },
                    _a["is-required"] = required,
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'wrapperCustomStyle', id: id, themeCss: wrapperCustomStyle, extra: 'item' }))), style: style },
                label && renderLabel !== false ? (_J$X_("label", { className: cx("Form-label", getItemLabelClassName(props)) },
                    _J$X_("span", null,
                        label ? render('label', label) : null,
                        required && (label || labelRemark) ? (_J$X_("span", { className: cx("Form-star") }, "*")) : null,
                        labelRemark
                            ? render('label-remark', {
                                type: 'remark',
                                icon: labelRemark.icon || 'warning-mark',
                                tooltip: labelRemark,
                                className: cx("Form-lableRemark"),
                                mobileUI: mobileUI,
                                container: props.popOverContainer || env.getModalContainer
                            })
                            : null))) : null,
                mobileUI ? (_J$X_("div", { className: cx('Form-item-controlBox') },
                    renderControl(),
                    caption
                        ? render('caption', caption, {
                            className: cx("Form-caption", captionClassName)
                        })
                        : null,
                    remark
                        ? render('remark', {
                            type: 'remark',
                            icon: remark.icon || 'warning-mark',
                            className: cx("Form-remark"),
                            tooltip: remark,
                            mobileUI: mobileUI,
                            container: props.popOverContainer || env.getModalContainer
                        })
                        : null,
                    hint && model && model.isFocused
                        ? render('hint', hint, {
                            className: cx("Form-hint")
                        })
                        : null,
                    model &&
                        !model.valid &&
                        showErrorMsg !== false &&
                        Array.isArray(model.errors) ? (_J$X_("ul", { className: cx("Form-feedback") }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                    renderDescription !== false && description
                        ? render('description', description, {
                            className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                        })
                        : null)) : (_J$X_(React__default["default"].Fragment, null,
                    renderControl(),
                    caption
                        ? render('caption', caption, {
                            className: cx("Form-caption", captionClassName)
                        })
                        : null,
                    remark
                        ? render('remark', {
                            type: 'remark',
                            icon: remark.icon || 'warning-mark',
                            className: cx("Form-remark"),
                            tooltip: remark,
                            mobileUI: mobileUI,
                            container: props.popOverContainer || env.getModalContainer
                        })
                        : null,
                    hint && model && model.isFocused
                        ? render('hint', hint, {
                            className: cx("Form-hint")
                        })
                        : null,
                    model &&
                        !model.valid &&
                        showErrorMsg !== false &&
                        Array.isArray(model.errors) ? (_J$X_("ul", { className: cx("Form-feedback") }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                    renderDescription !== false && description
                        ? render('description', description, {
                            className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                        })
                        : null))));
        },
        inline: function (props, renderControl) {
            var _a;
            var className = props.className, style = props.style, cx = props.classnames, desc = props.desc, description = props.description, label = props.label, render = props.render, required = props.required, caption = props.caption, descriptionClassName = props.descriptionClassName, captionClassName = props.captionClassName, model = props.formItem, remark = props.remark, labelRemark = props.labelRemark, env = props.env, hint = props.hint, renderLabel = props.renderLabel, renderDescription = props.renderDescription, data = props.data, showErrorMsg = props.showErrorMsg, mobileUI = props.mobileUI, __ = props.translate, isStatic = props.static, staticClassName = props.staticClassName, themeCss = props.themeCss, wrapperCustomStyle = props.wrapperCustomStyle, id = props.id;
            var labelWidth = props.labelWidth || props.formLabelWidth;
            description = description || desc;
            return (_J$X_("div", { "data-role": "form-item", "data-amis-name": props.name, className: cx("Form-item Form-item--inline", isStatic && staticClassName ? staticClassName : className, (_a = {
                        'is-error': model && !model.valid
                    },
                    _a["is-required"] = required,
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'wrapperCustomStyle', id: id, themeCss: wrapperCustomStyle, extra: 'item' }))), style: style },
                label && renderLabel !== false ? (_J$X_("label", { className: cx("Form-label", getItemLabelClassName(props)), style: labelWidth != null ? { width: labelWidth } : undefined },
                    _J$X_("span", null,
                        label ? render('label', label) : label,
                        required && (label || labelRemark) ? (_J$X_("span", { className: cx("Form-star") }, "*")) : null,
                        labelRemark
                            ? render('label-remark', {
                                type: 'remark',
                                icon: labelRemark.icon || 'warning-mark',
                                tooltip: labelRemark,
                                className: cx("Form-lableRemark"),
                                mobileUI: mobileUI,
                                container: props.popOverContainer || env.getModalContainer
                            })
                            : null))) : null,
                _J$X_("div", { className: cx("Form-value") },
                    renderControl(),
                    caption
                        ? render('caption', caption, {
                            className: cx("Form-caption", captionClassName)
                        })
                        : null,
                    remark
                        ? render('remark', {
                            type: 'remark',
                            icon: remark.icon || 'warning-mark',
                            className: cx("Form-remark"),
                            tooltip: remark,
                            mobileUI: mobileUI,
                            container: props.popOverContainer || env.getModalContainer
                        })
                        : null,
                    hint && model && model.isFocused
                        ? render('hint', hint, {
                            className: cx("Form-hint")
                        })
                        : null,
                    model &&
                        !model.valid &&
                        showErrorMsg !== false &&
                        Array.isArray(model.errors) ? (_J$X_("ul", { className: cx("Form-feedback") }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                    renderDescription !== false && description
                        ? render('description', description, {
                            className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                        })
                        : null)));
        },
        row: function (props, renderControl) {
            var _a;
            var className = props.className, style = props.style, cx = props.classnames, desc = props.desc, description = props.description, label = props.label, render = props.render, required = props.required, caption = props.caption, remark = props.remark, labelRemark = props.labelRemark, env = props.env, descriptionClassName = props.descriptionClassName, captionClassName = props.captionClassName, model = props.formItem, renderLabel = props.renderLabel, renderDescription = props.renderDescription, hint = props.hint, data = props.data, showErrorMsg = props.showErrorMsg, mobileUI = props.mobileUI, __ = props.translate, isStatic = props.static, staticClassName = props.staticClassName, wrapperCustomStyle = props.wrapperCustomStyle, themeCss = props.themeCss, id = props.id;
            description = description || desc;
            var labelWidth = props.labelWidth || props.formLabelWidth;
            return (_J$X_("div", { "data-role": "form-item", "data-amis-name": props.name, className: cx("Form-item Form-item--row", isStatic && staticClassName ? staticClassName : className, (_a = {
                        'is-error': model && !model.valid
                    },
                    _a["is-required"] = required,
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'wrapperCustomStyle', id: id, themeCss: wrapperCustomStyle, extra: 'item' }))), style: style },
                _J$X_("div", { className: cx('Form-rowInner') },
                    label && renderLabel !== false ? (_J$X_("label", { className: cx("Form-label", getItemLabelClassName(props)), style: labelWidth != null ? { width: labelWidth } : undefined },
                        _J$X_("span", null,
                            render('label', label),
                            required && (label || labelRemark) ? (_J$X_("span", { className: cx("Form-star") }, "*")) : null,
                            labelRemark
                                ? render('label-remark', {
                                    type: 'remark',
                                    icon: labelRemark.icon || 'warning-mark',
                                    tooltip: labelRemark,
                                    className: cx("Form-lableRemark"),
                                    mobileUI: mobileUI,
                                    container: props.popOverContainer || env.getModalContainer
                                })
                                : null))) : null,
                    renderControl(),
                    caption
                        ? render('caption', caption, {
                            className: cx("Form-caption", captionClassName)
                        })
                        : null,
                    remark
                        ? render('remark', {
                            type: 'remark',
                            icon: remark.icon || 'warning-mark',
                            className: cx("Form-remark"),
                            tooltip: remark,
                            container: props.popOverContainer || env.getModalContainer
                        })
                        : null),
                hint && model && model.isFocused
                    ? render('hint', hint, {
                        className: cx("Form-hint")
                    })
                    : null,
                model &&
                    !model.valid &&
                    showErrorMsg !== false &&
                    Array.isArray(model.errors) ? (_J$X_("ul", { className: cx('Form-feedback') }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                description && renderDescription !== false
                    ? render('description', description, {
                        className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                    })
                    : null));
        },
        flex: function (props, renderControl) {
            var _a;
            var className = props.className, style = props.style, cx = props.classnames, desc = props.desc, description = props.description, label = props.label, render = props.render, required = props.required, caption = props.caption, remark = props.remark, labelRemark = props.labelRemark, env = props.env, descriptionClassName = props.descriptionClassName, captionClassName = props.captionClassName, model = props.formItem, renderLabel = props.renderLabel, renderDescription = props.renderDescription, hint = props.hint, data = props.data, showErrorMsg = props.showErrorMsg, mobileUI = props.mobileUI, __ = props.translate, isStatic = props.static, staticClassName = props.staticClassName, wrapperCustomStyle = props.wrapperCustomStyle, themeCss = props.themeCss, id = props.id;
            var labelAlign = (props.labelAlign !== 'inherit' && props.labelAlign) ||
                props.formLabelAlign;
            var labelWidth = props.labelWidth || props.formLabelWidth;
            description = description || desc;
            return (_J$X_("div", { "data-role": "form-item", "data-amis-name": props.name, className: cx("Form-item Form-item--flex", isStatic && staticClassName ? staticClassName : className, (_a = {
                        'is-error': model && !model.valid
                    },
                    _a["is-required"] = required,
                    _a), model === null || model === void 0 ? void 0 : model.errClassNames, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'wrapperCustomStyle', id: id, themeCss: wrapperCustomStyle, extra: 'item' }))), style: style },
                _J$X_("div", { className: cx('Form-flexInner', labelAlign && "Form-flexInner--label-".concat(labelAlign)) },
                    label && renderLabel !== false ? (_J$X_("label", { className: cx("Form-label", getItemLabelClassName(props)), style: labelWidth != null
                            ? { width: labelAlign === 'top' ? '100%' : labelWidth }
                            : undefined },
                        _J$X_("span", null,
                            render('label', label),
                            required && (label || labelRemark) ? (_J$X_("span", { className: cx("Form-star") }, "*")) : null,
                            labelRemark
                                ? render('label-remark', {
                                    type: 'remark',
                                    icon: labelRemark.icon || 'warning-mark',
                                    tooltip: labelRemark,
                                    className: cx("Form-lableRemark"),
                                    mobileUI: mobileUI,
                                    container: props.popOverContainer || env.getModalContainer
                                })
                                : null))) : null,
                    _J$X_("div", { className: cx("Form-value") },
                        renderControl(),
                        caption
                            ? render('caption', caption, {
                                className: cx("Form-caption", captionClassName)
                            })
                            : null,
                        remark
                            ? render('remark', {
                                type: 'remark',
                                icon: remark.icon || 'warning-mark',
                                className: cx("Form-remark"),
                                tooltip: remark,
                                container: props.popOverContainer || env.getModalContainer
                            })
                            : null,
                        hint && model && model.isFocused
                            ? render('hint', hint, {
                                className: cx("Form-hint")
                            })
                            : null,
                        model &&
                            !model.valid &&
                            showErrorMsg !== false &&
                            Array.isArray(model.errors) ? (_J$X_("ul", { className: cx('Form-feedback') }, model.errors.map(function (msg, key) { return (_J$X_("li", { key: key }, msg)); }))) : null,
                        description && renderDescription !== false
                            ? render('description', description, {
                                className: cx("Form-description", descriptionClassName, styleHelper.setThemeClassName(tslib.__assign(tslib.__assign({}, props), { name: 'descriptionClassName', id: id, themeCss: themeCss, extra: 'item' })))
                            })
                            : null))));
        }
    };
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handleFocus", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handleBlur", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handlePopOverConfirm", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object, Object, Boolean, Object]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handlePopOverAction", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", []),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "closePopOver", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object, Object]),
        tslib.__metadata("design:returntype", Promise)
    ], FormItemWrap.prototype, "handleOpenDialog", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Array]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handleDialogConfirm", null);
    tslib.__decorate([
        helper.autobind,
        tslib.__metadata("design:type", Function),
        tslib.__metadata("design:paramtypes", [Object]),
        tslib.__metadata("design:returntype", void 0)
    ], FormItemWrap.prototype, "handleDialogClose", null);
    return FormItemWrap;
}(React__default["default"].Component));
// 白名单形式，只有这些属性发生变化，才会往下更新。
// 除非配置  strictMode
var detectProps = [
    'formPristine',
    'formInited',
    'addable',
    'addButtonClassName',
    'addButtonText',
    'addOn',
    'btnClassName',
    'btnLabel',
    'style',
    'btnDisabled',
    'className',
    'clearable',
    'columns',
    'columnsCount',
    'controls',
    'desc',
    'description',
    'disabled',
    'static',
    'staticClassName',
    'staticLabelClassName',
    'staticInputClassName',
    'draggable',
    'editable',
    'editButtonClassName',
    'formHorizontal',
    'formMode',
    'hideRoot',
    'horizontal',
    'icon',
    'inline',
    'inputClassName',
    'label',
    'labelClassName',
    'labelField',
    'language',
    'level',
    'max',
    'maxRows',
    'min',
    'minRows',
    'multiLine',
    'multiple',
    'option',
    'placeholder',
    'removable',
    'required',
    'remark',
    'hint',
    'rows',
    'searchable',
    'showCompressOptions',
    'size',
    'step',
    'showInput',
    'unit',
    'value',
    'diffValue',
    'borderMode',
    'items',
    'showCounter',
    'minLength',
    'maxLength',
    'embed',
    'displayMode',
    'revealPassword',
    'loading',
    'themeCss',
    'formLabelAlign',
    'formLabelWidth',
    'formHorizontal',
    'labelAlign',
    'colSize'
];
function asFormItem(config) {
    return function (Control) {
        var _a;
        var supportRef = Control.prototype instanceof React__default["default"].Component ||
            Control.$$typeof === Symbol.for('react.forward_ref');
        // 兼容老的 FormItem 用法。
        if (config.validate && !Control.prototype.validate) {
            var fn_1 = config.validate;
            Control.prototype.validate = function () {
                var host = {
                    input: this
                };
                return fn_1.apply(host, arguments);
            };
        }
        else if (config.validate) {
            console.error('FormItem配置中的 validate 将不起作用，因为类的成员函数中已经定义了 validate 方法，将优先使用类里面的实现。');
        }
        if (config.storeType) {
            Control = WithStore.HocStoreFactory({
                storeType: config.storeType,
                extendsData: config.extendsData
            })(mobxReact.observer(Control));
            delete config.storeType;
        }
        return wrapControl.wrapControl(config, hoistNonReactStatic__default["default"]((_a = /** @class */ (function (_super) {
                tslib.__extends(class_1, _super);
                function class_1(props) {
                    var _this = _super.call(this, props) || this;
                    _this.refFn = _this.refFn.bind(_this);
                    _this.getData = _this.getData.bind(_this);
                    var validations = props.validations, model = props.formItem;
                    // 组件注册的时候可能默认指定验证器类型
                    if (model && !validations && config.validations) {
                        model.config({
                            rules: config.validations
                        });
                    }
                    return _this;
                }
                class_1.prototype.shouldComponentUpdate = function (nextProps) {
                    var _a;
                    if (((_a = config.shouldComponentUpdate) === null || _a === void 0 ? void 0 : _a.call(config, this.props, nextProps)) ||
                        nextProps.strictMode === false ||
                        config.strictMode === false) {
                        return true;
                    }
                    // 把可能会影响视图的白名单弄出来，减少重新渲染次数。
                    if (helper.anyChanged(detectProps.concat(config.detectProps || []), this.props, nextProps)) {
                        return true;
                    }
                    return false;
                };
                class_1.prototype.getWrappedInstance = function () {
                    return this.ref;
                };
                class_1.prototype.refFn = function (ref) {
                    this.ref = ref;
                };
                class_1.prototype.getData = function () {
                    return this.props.data;
                };
                class_1.prototype.renderControl = function () {
                    var _a;
                    var _b = this.props, 
                    // 这里解构，不可轻易删除，避免被rest传到子组件
                    inputClassName = _b.inputClassName, model = _b.formItem, cx = _b.classnames, children = _b.children, type = _b.type, size = _b.size, defaultSize = _b.defaultSize, mobileUI = _b.mobileUI, rest = tslib.__rest(_b, ["inputClassName", "formItem", "classnames", "children", "type", "size", "defaultSize", "mobileUI"]);
                    var isRuleSize = size && ['xs', 'sm', 'md', 'lg', 'full'].includes(size);
                    var controlSize = isRuleSize ? size : defaultSize;
                    return (_J$X_(React__default["default"].Fragment, null,
                        _J$X_(Control, tslib.__assign({}, rest, { 
                            // 因为 formItem 内部可能不会更新到最新的 data，所以暴露个方法可以获取到最新的
                            // 获取不到最新的因为做了限制，只有表单项目 name 关联的数值变化才更新
                            getData: this.getData, mobileUI: mobileUI, onOpenDialog: this.handleOpenDialog, size: config.sizeMutable !== false ? undefined : size, onFocus: this.handleFocus, onBlur: this.handleBlur, type: type, classnames: cx, ref: supportRef ? this.refFn : undefined, forwardedRef: supportRef ? undefined : this.refFn, formItem: model, style: {
                                width: !isRuleSize && size ? size : undefined
                            }, className: cx("Form-control", (_a = {
                                    'is-inline': !!rest.inline && !mobileUI,
                                    'is-error': model && !model.valid,
                                    'is-full': size === 'full',
                                    'is-thin': config.thin
                                },
                                _a["Form-control--withSize Form-control--size".concat(helper.ucFirst(controlSize))] = config.sizeMutable !== false &&
                                    typeof controlSize === 'string' &&
                                    !!controlSize &&
                                    controlSize !== 'full',
                                _a), model === null || model === void 0 ? void 0 : model.errClassNames, getItemInputClassName(this.props)) }))));
                };
                return class_1;
            }(FormItemWrap)),
            _a.defaultProps = tslib.__assign({ initAutoFill: 'fillIfNotSet', className: '', renderLabel: config.renderLabel, renderDescription: config.renderDescription, sizeMutable: config.sizeMutable, wrap: config.wrap, showErrorMsg: config.showErrorMsg }, Control.defaultProps),
            _a.propsList = tslib.__spreadArray([
                'value',
                'defaultValue',
                'onChange',
                'setPrinstineValue',
                'readOnly',
                'strictMode'
            ], tslib.__read((Control.propsList || [])), false),
            _a.displayName = "FormItem".concat(config.type ? "(".concat(config.type, ")") : ''),
            _a.ComposedComponent = Control,
            _a), Control));
    };
}
function registerFormItem(config) {
    var Control = asFormItem(config)(config.component);
    return factory.registerRenderer(tslib.__assign(tslib.__assign({}, config), { weight: typeof config.weight !== 'undefined' ? config.weight : -100, component: Control, isFormItem: true }));
}
function FormItem(config) {
    return function (component) {
        var renderer = registerFormItem(tslib.__assign(tslib.__assign({}, config), { component: component }));
        return renderer.component;
    };
}
function getFormItemByName(name) {
    return factory.renderersMap[name];
}

exports.FormItem = FormItem;
exports.FormItemWrap = FormItemWrap;
exports.asFormItem = asFormItem;
exports["default"] = FormItem;
exports.detectProps = detectProps;
exports.getFormItemByName = getFormItemByName;
exports.registerFormItem = registerFormItem;
