'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var xml = require('../../util/xml.js');

/**
 * 手动从 OMML2MML.XSL 里拷贝过来的，避免打包工具依赖
 */
var xsl = xml.parseXML("\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:mml=\"http://www.w3.org/1998/Math/MathML\"\n\txmlns:m=\"http://schemas.openxmlformats.org/officeDocument/2006/math\">\n  <xsl:output method=\"xml\" encoding=\"UTF-16\" />\n\n  <!-- %% Global Definitions -->\n\n  <!-- Every single unicode character that is recognized by OMML as an operator -->\n  <xsl:variable name=\"sOperators\"\n\t\tselect=\"concat(\n          '&#x00A8;&#x0021;&#x0022;&#x0023;&#x0026;&#x0028;&#x0029;&#x002B;&#x002C;&#x002D;&#x002E;&#x002F;&#x003A;',\n          '&#x003B;&#x003C;&#x003D;&#x003E;&#x003F;&#x0040;&#x005B;&#x005C;&#x005D;&#x005E;&#x005F;&#x0060;&#x007B;',\n          '&#x007C;&#x007D;&#x007E;&#x00A1;&#x00A6;&#x00AC;&#x00AF;&#x00B0;&#x00B1;&#x00B2;&#x00B3;&#x00B4;&#x00B7;&#x00B9;&#x00BF;',\n          '&#x00D7;&#x007E;&#x00F7;&#x02C7;&#x02D8;&#x02D9;&#x02DC;&#x02DD;&#x0300;&#x0301;&#x0302;&#x0303;&#x0304;&#x0305;&#x0306;&#x0307;&#x0308;&#x0309;',\n          '&#x030A;&#x030B;&#x030C;&#x030D;&#x030E;&#x030F;&#x0310;&#x0311;&#x0312;&#x0313;&#x0314;&#x0315;',\n          '&#x0316;&#x0317;&#x0318;&#x0319;&#x031A;&#x031B;&#x031C;&#x031D;&#x031E;&#x031F;&#x0320;&#x0321;',\n          '&#x0322;&#x0323;&#x0324;&#x0325;&#x0326;&#x0327;&#x0328;&#x0329;&#x032A;&#x032B;&#x032C;&#x032D;',\n          '&#x032E;&#x032F;&#x0330;&#x0331;&#x0332;&#x0333;&#x0334;&#x0335;&#x0336;&#x0337;&#x0338;&#x033F;',\n          '&#x2000;&#x2001;&#x2002;&#x2003;&#x2004;&#x2005;&#x2006;&#x2009;&#x200A;&#x2010;&#x2012;&#x2013;',\n          '&#x2014;&#x2016;&#x2020;&#x2021;&#x2022;&#x2024;&#x2025;&#x2026;&#x2032;&#x2033;&#x2034;&#x203C;',\n          '&#x2040;&#x2044;&#x204E;&#x204F;&#x2050;&#x2057;&#x2061;&#x2062;&#x2063;&#x2070;&#x2074;&#x2075;',\n          '&#x2076;&#x2077;&#x2078;&#x2079;&#x207A;&#x207B;&#x207C;&#x207D;&#x207E;&#x2080;&#x2081;&#x2082;',\n          '&#x2083;&#x2084;&#x2085;&#x2086;&#x2087;&#x2088;&#x2089;&#x208A;&#x208B;&#x208C;&#x208D;&#x208E;',\n          '&#x20D0;&#x20D1;&#x20D2;&#x20D3;&#x20D4;&#x20D5;&#x20D6;&#x20D7;&#x20D8;&#x20D9;&#x20DA;&#x20DB;',\n          '&#x20DC;&#x20DD;&#x20DE;&#x20DF;&#x20E0;&#x20E1;&#x20E4;&#x20E5;&#x20E6;&#x20E7;&#x20E8;&#x20E9;',\n          '&#x20EA;&#x2140;&#x2146;&#x2190;&#x2191;&#x2192;&#x2193;&#x2194;&#x2195;&#x2196;&#x2197;&#x2198;&#x2199;',\n          '&#x219A;&#x219B;&#x219C;&#x219D;&#x219E;&#x219F;&#x21A0;&#x21A1;&#x21A2;&#x21A3;&#x21A4;&#x21A5;',\n          '&#x21A6;&#x21A7;&#x21A8;&#x21A9;&#x21AA;&#x21AB;&#x21AC;&#x21AD;&#x21AE;&#x21AF;&#x21B0;&#x21B1;',\n          '&#x21B2;&#x21B3;&#x21B6;&#x21B7;&#x21BA;&#x21BB;&#x21BC;&#x21BD;&#x21BE;&#x21BF;&#x21C0;&#x21C1;',\n          '&#x21C2;&#x21C3;&#x21C4;&#x21C5;&#x21C6;&#x21C7;&#x21C8;&#x21C9;&#x21CA;&#x21CB;&#x21CC;&#x21CD;',\n          '&#x21CE;&#x21CF;&#x21D0;&#x21D1;&#x21D2;&#x21D3;&#x21D4;&#x21D5;&#x21D6;&#x21D7;&#x21D8;&#x21D9;',\n          '&#x21DA;&#x21DB;&#x21DC;&#x21DD;&#x21DE;&#x21DF;&#x21E0;&#x21E1;&#x21E2;&#x21E3;&#x21E4;&#x21E5;',\n          '&#x21E6;&#x21E7;&#x21E8;&#x21E9;&#x21F3;&#x21F4;&#x21F5;&#x21F6;&#x21F7;&#x21F8;&#x21F9;&#x21FA;',\n          '&#x21FB;&#x21FC;&#x21FD;&#x21FE;&#x21FF;&#x2200;&#x2201;&#x2202;&#x2203;&#x2204;&#x2206;&#x2207;',\n          '&#x2208;&#x2209;&#x220A;&#x220B;&#x220C;&#x220D;&#x220F;&#x2210;&#x2211;&#x2212;&#x2213;&#x2214;',\n          '&#x2215;&#x2216;&#x2217;&#x2218;&#x2219;&#x221A;&#x221B;&#x221C;&#x221D;&#x2223;&#x2224;&#x2225;',\n          '&#x2226;&#x2227;&#x2228;&#x2229;&#x222A;&#x222B;&#x222C;&#x222D;&#x222E;&#x222F;&#x2230;&#x2231;',\n          '&#x2232;&#x2233;&#x2234;&#x2235;&#x2236;&#x2237;&#x2238;&#x2239;&#x223A;&#x223B;&#x223C;&#x223D;',\n          '&#x223E;&#x2240;&#x2241;&#x2242;&#x2243;&#x2244;&#x2245;&#x2246;&#x2247;&#x2248;&#x2249;&#x224A;',\n          '&#x224B;&#x224C;&#x224D;&#x224E;&#x224F;&#x2250;&#x2251;&#x2252;&#x2253;&#x2254;&#x2255;&#x2256;',\n          '&#x2257;&#x2258;&#x2259;&#x225A;&#x225B;&#x225C;&#x225D;&#x225E;&#x225F;&#x2260;&#x2261;&#x2262;',\n          '&#x2263;&#x2264;&#x2265;&#x2266;&#x2267;&#x2268;&#x2269;&#x226A;&#x226B;&#x226C;&#x226D;&#x226E;',\n          '&#x226F;&#x2270;&#x2271;&#x2272;&#x2273;&#x2274;&#x2275;&#x2276;&#x2277;&#x2278;&#x2279;&#x227A;',\n          '&#x227B;&#x227C;&#x227D;&#x227E;&#x227F;&#x2280;&#x2281;&#x2282;&#x2283;&#x2284;&#x2285;&#x2286;',\n          '&#x2287;&#x2288;&#x2289;&#x228A;&#x228B;&#x228C;&#x228D;&#x228E;&#x228F;&#x2290;&#x2291;&#x2292;',\n          '&#x2293;&#x2294;&#x2295;&#x2296;&#x2297;&#x2298;&#x2299;&#x229A;&#x229B;&#x229C;&#x229D;&#x229E;',\n          '&#x229F;&#x22A0;&#x22A1;&#x22A2;&#x22A3;&#x22A5;&#x22A6;&#x22A7;&#x22A8;&#x22A9;&#x22AA;&#x22AB;',\n          '&#x22AC;&#x22AD;&#x22AE;&#x22AF;&#x22B0;&#x22B1;&#x22B2;&#x22B3;&#x22B4;&#x22B5;&#x22B6;&#x22B7;',\n          '&#x22B8;&#x22B9;&#x22BA;&#x22BB;&#x22BC;&#x22BD;&#x22C0;&#x22C1;&#x22C2;&#x22C3;&#x22C4;&#x22C5;',\n          '&#x22C6;&#x22C7;&#x22C8;&#x22C9;&#x22CA;&#x22CB;&#x22CC;&#x22CD;&#x22CE;&#x22CF;&#x22D0;&#x22D1;',\n          '&#x22D2;&#x22D3;&#x22D4;&#x22D5;&#x22D6;&#x22D7;&#x22D8;&#x22D9;&#x22DA;&#x22DB;&#x22DC;&#x22DD;',\n          '&#x22DE;&#x22DF;&#x22E0;&#x22E1;&#x22E2;&#x22E3;&#x22E4;&#x22E5;&#x22E6;&#x22E7;&#x22E8;&#x22E9;',\n          '&#x22EA;&#x22EB;&#x22EC;&#x22ED;&#x22EE;&#x22EF;&#x22F0;&#x22F1;&#x22F2;&#x22F3;&#x22F4;&#x22F5;',\n          '&#x22F6;&#x22F7;&#x22F8;&#x22F9;&#x22FA;&#x22FB;&#x22FC;&#x22FD;&#x22FE;&#x22FF;&#x2305;&#x2306;',\n          '&#x2308;&#x2309;&#x230A;&#x230B;&#x231C;&#x231D;&#x231E;&#x231F;&#x2322;&#x2323;&#x2329;&#x232A;',\n          '&#x233D;&#x233F;&#x23B0;&#x23B1;&#x23DC;&#x23DD;&#x23DE;&#x23DF;&#x23E0;&#x2502;&#x251C;&#x2524;',\n          '&#x252C;&#x2534;&#x2581;&#x2588;&#x2592;&#x25A0;&#x25A1;&#x25AD;&#x25B2;&#x25B3;&#x25B4;&#x25B5;',\n          '&#x25B6;&#x25B7;&#x25B8;&#x25B9;&#x25BC;&#x25BD;&#x25BE;&#x25BF;&#x25C0;&#x25C1;&#x25C2;&#x25C3;',\n          '&#x25C4;&#x25C5;&#x25CA;&#x25CB;&#x25E6;&#x25EB;&#x25EC;&#x25F8;&#x25F9;&#x25FA;&#x25FB;&#x25FC;',\n          '&#x25FD;&#x25FE;&#x25FF;&#x2605;&#x2606;&#x2772;&#x2773;&#x27D1;&#x27D2;&#x27D3;&#x27D4;&#x27D5;',\n          '&#x27D6;&#x27D7;&#x27D8;&#x27D9;&#x27DA;&#x27DB;&#x27DC;&#x27DD;&#x27DE;&#x27DF;&#x27E0;&#x27E1;',\n          '&#x27E2;&#x27E3;&#x27E4;&#x27E5;&#x27E6;&#x27E7;&#x27E8;&#x27E9;&#x27EA;&#x27EB;&#x27F0;&#x27F1;',\n          '&#x27F2;&#x27F3;&#x27F4;&#x27F5;&#x27F6;&#x27F7;&#x27F8;&#x27F9;&#x27FA;&#x27FB;&#x27FC;&#x27FD;',\n          '&#x27FE;&#x27FF;&#x2900;&#x2901;&#x2902;&#x2903;&#x2904;&#x2905;&#x2906;&#x2907;&#x2908;&#x2909;',\n          '&#x290A;&#x290B;&#x290C;&#x290D;&#x290E;&#x290F;&#x2910;&#x2911;&#x2912;&#x2913;&#x2914;&#x2915;',\n          '&#x2916;&#x2917;&#x2918;&#x2919;&#x291A;&#x291B;&#x291C;&#x291D;&#x291E;&#x291F;&#x2920;&#x2921;',\n          '&#x2922;&#x2923;&#x2924;&#x2925;&#x2926;&#x2927;&#x2928;&#x2929;&#x292A;&#x292B;&#x292C;&#x292D;',\n          '&#x292E;&#x292F;&#x2930;&#x2931;&#x2932;&#x2933;&#x2934;&#x2935;&#x2936;&#x2937;&#x2938;&#x2939;',\n          '&#x293A;&#x293B;&#x293C;&#x293D;&#x293E;&#x293F;&#x2940;&#x2941;&#x2942;&#x2943;&#x2944;&#x2945;',\n          '&#x2946;&#x2947;&#x2948;&#x2949;&#x294A;&#x294B;&#x294C;&#x294D;&#x294E;&#x294F;&#x2950;&#x2951;',\n          '&#x2952;&#x2953;&#x2954;&#x2955;&#x2956;&#x2957;&#x2958;&#x2959;&#x295A;&#x295B;&#x295C;&#x295D;',\n          '&#x295E;&#x295F;&#x2960;&#x2961;&#x2962;&#x2963;&#x2964;&#x2965;&#x2966;&#x2967;&#x2968;&#x2969;',\n          '&#x296A;&#x296B;&#x296C;&#x296D;&#x296E;&#x296F;&#x2970;&#x2971;&#x2972;&#x2973;&#x2974;&#x2975;',\n          '&#x2976;&#x2977;&#x2978;&#x2979;&#x297A;&#x297B;&#x297C;&#x297D;&#x297E;&#x297F;&#x2980;&#x2982;',\n          '&#x2983;&#x2984;&#x2985;&#x2986;&#x2987;&#x2988;&#x2989;&#x298A;&#x298B;&#x298C;&#x298D;&#x298E;',\n          '&#x298F;&#x2990;&#x2991;&#x2992;&#x2993;&#x2994;&#x2995;&#x2996;&#x2997;&#x2998;&#x2999;&#x299A;',\n          '&#x29B6;&#x29B7;&#x29B8;&#x29B9;&#x29C0;&#x29C1;&#x29C4;&#x29C5;&#x29C6;&#x29C7;&#x29C8;&#x29CE;',\n          '&#x29CF;&#x29D0;&#x29D1;&#x29D2;&#x29D3;&#x29D4;&#x29D5;&#x29D6;&#x29D7;&#x29D8;&#x29D9;&#x29DA;',\n          '&#x29DB;&#x29DF;&#x29E1;&#x29E2;&#x29E3;&#x29E4;&#x29E5;&#x29E6;&#x29EB;&#x29F4;&#x29F5;&#x29F6;',\n          '&#x29F7;&#x29F8;&#x29F9;&#x29FA;&#x29FB;&#x29FC;&#x29FD;&#x29FE;&#x29FF;&#x2A00;&#x2A01;&#x2A02;',\n          '&#x2A03;&#x2A04;&#x2A05;&#x2A06;&#x2A07;&#x2A08;&#x2A09;&#x2A0A;&#x2A0B;&#x2A0C;&#x2A0D;&#x2A0E;',\n          '&#x2A0F;&#x2A10;&#x2A11;&#x2A12;&#x2A13;&#x2A14;&#x2A15;&#x2A16;&#x2A17;&#x2A18;&#x2A19;&#x2A1A;',\n          '&#x2A1B;&#x2A1C;&#x2A1D;&#x2A1E;&#x2A1F;&#x2A20;&#x2A21;&#x2A22;&#x2A23;&#x2A24;&#x2A25;&#x2A26;',\n          '&#x2A27;&#x2A28;&#x2A29;&#x2A2A;&#x2A2B;&#x2A2C;&#x2A2D;&#x2A2E;&#x2A2F;&#x2A30;&#x2A31;&#x2A32;',\n          '&#x2A33;&#x2A34;&#x2A35;&#x2A36;&#x2A37;&#x2A38;&#x2A39;&#x2A3A;&#x2A3B;&#x2A3C;&#x2A3D;&#x2A3E;',\n          '&#x2A3F;&#x2A40;&#x2A41;&#x2A42;&#x2A43;&#x2A44;&#x2A45;&#x2A46;&#x2A47;&#x2A48;&#x2A49;&#x2A4A;',\n          '&#x2A4B;&#x2A4C;&#x2A4D;&#x2A4E;&#x2A4F;&#x2A50;&#x2A51;&#x2A52;&#x2A53;&#x2A54;&#x2A55;&#x2A56;',\n          '&#x2A57;&#x2A58;&#x2A59;&#x2A5A;&#x2A5B;&#x2A5C;&#x2A5D;&#x2A5E;&#x2A5F;&#x2A60;&#x2A61;&#x2A62;',\n          '&#x2A63;&#x2A64;&#x2A65;&#x2A66;&#x2A67;&#x2A68;&#x2A69;&#x2A6A;&#x2A6B;&#x2A6C;&#x2A6D;&#x2A6E;',\n          '&#x2A6F;&#x2A70;&#x2A71;&#x2A72;&#x2A73;&#x2A74;&#x2A75;&#x2A76;&#x2A77;&#x2A78;&#x2A79;&#x2A7A;',\n          '&#x2A7B;&#x2A7C;&#x2A7D;&#x2A7E;&#x2A7F;&#x2A80;&#x2A81;&#x2A82;&#x2A83;&#x2A84;&#x2A85;&#x2A86;',\n          '&#x2A87;&#x2A88;&#x2A89;&#x2A8A;&#x2A8B;&#x2A8C;&#x2A8D;&#x2A8E;&#x2A8F;&#x2A90;&#x2A91;&#x2A92;',\n          '&#x2A93;&#x2A94;&#x2A95;&#x2A96;&#x2A97;&#x2A98;&#x2A99;&#x2A9A;&#x2A9B;&#x2A9C;&#x2A9D;&#x2A9E;',\n          '&#x2A9F;&#x2AA0;&#x2AA1;&#x2AA2;&#x2AA3;&#x2AA4;&#x2AA5;&#x2AA6;&#x2AA7;&#x2AA8;&#x2AA9;&#x2AAA;',\n          '&#x2AAB;&#x2AAC;&#x2AAD;&#x2AAE;&#x2AAF;&#x2AB0;&#x2AB1;&#x2AB2;&#x2AB3;&#x2AB4;&#x2AB5;&#x2AB6;',\n          '&#x2AB7;&#x2AB8;&#x2AB9;&#x2ABA;&#x2ABB;&#x2ABC;&#x2ABD;&#x2ABE;&#x2ABF;&#x2AC0;&#x2AC1;&#x2AC2;',\n          '&#x2AC3;&#x2AC4;&#x2AC5;&#x2AC6;&#x2AC7;&#x2AC8;&#x2AC9;&#x2ACA;&#x2ACB;&#x2ACC;&#x2ACD;&#x2ACE;',\n          '&#x2ACF;&#x2AD0;&#x2AD1;&#x2AD2;&#x2AD3;&#x2AD4;&#x2AD5;&#x2AD6;&#x2AD7;&#x2AD8;&#x2AD9;&#x2ADA;',\n          '&#x2ADB;&#x2ADC;&#x2ADD;&#x2ADE;&#x2ADF;&#x2AE0;&#x2AE2;&#x2AE3;&#x2AE4;&#x2AE5;&#x2AE6;&#x2AE7;',\n          '&#x2AE8;&#x2AE9;&#x2AEA;&#x2AEB;&#x2AEC;&#x2AED;&#x2AEE;&#x2AEF;&#x2AF0;&#x2AF2;&#x2AF3;&#x2AF4;',\n          '&#x2AF5;&#x2AF6;&#x2AF7;&#x2AF8;&#x2AF9;&#x2AFA;&#x2AFB;&#x2AFC;&#x2AFD;&#x2AFE;&#x2AFF;&#x2B04;',\n          '&#x2B06;&#x2B07;&#x2B0C;&#x2B0D;&#x3014;&#x3015;&#x3016;&#x3017;&#x3018;&#x3019;&#xFF01;&#xFF06;',\n          '&#xFF08;&#xFF09;&#xFF0B;&#xFF0C;&#xFF0D;&#xFF0E;&#xFF0F;&#xFF1A;&#xFF1B;&#xFF1C;&#xFF1D;&#xFF1E;',\n          '&#xFF1F;&#xFF20;&#xFF3B;&#xFF3C;&#xFF3D;&#xFF3E;&#xFF3F;&#xFF5B;&#xFF5C;&#xFF5D;')\" />\n\n  <!-- A string of '-'s repeated exactly as many times as the operators above -->\n  <xsl:variable name=\"sMinuses\">\n    <xsl:call-template name=\"SRepeatChar\">\n      <xsl:with-param name=\"cchRequired\" select=\"string-length($sOperators)\" />\n      <xsl:with-param name=\"ch\" select=\"'-'\" />\n    </xsl:call-template>\n  </xsl:variable>\n\n  <!-- Every single unicode character that is recognized by OMML as a number -->\n  <xsl:variable name=\"sNumbers\" select=\"'0123456789'\" />\n\n  <!-- A string of '0's repeated exactly as many times as the list of numbers above -->\n  <xsl:variable name=\"sZeros\">\n    <xsl:call-template name=\"SRepeatChar\">\n      <xsl:with-param name=\"cchRequired\" select=\"string-length($sNumbers)\" />\n      <xsl:with-param name=\"ch\" select=\"'0'\" />\n    </xsl:call-template>\n  </xsl:variable>\n\n  <!-- %%Template: SReplace\n\n\t\tReplace all occurences of sOrig in sInput with sReplacement\n\t\tand return the resulting string. -->\n  <xsl:template name=\"SReplace\">\n    <xsl:param name=\"sInput\" />\n    <xsl:param name=\"sOrig\" />\n    <xsl:param name=\"sReplacement\" />\n\n    <xsl:choose>\n      <xsl:when test=\"not(contains($sInput, $sOrig))\">\n        <xsl:value-of select=\"$sInput\" />\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:variable name=\"sBefore\" select=\"substring-before($sInput, $sOrig)\" />\n        <xsl:variable name=\"sAfter\" select=\"substring-after($sInput, $sOrig)\" />\n        <xsl:variable name=\"sAfterProcessed\">\n          <xsl:call-template name=\"SReplace\">\n            <xsl:with-param name=\"sInput\" select=\"$sAfter\" />\n            <xsl:with-param name=\"sOrig\" select=\"$sOrig\" />\n            <xsl:with-param name=\"sReplacement\" select=\"$sReplacement\" />\n          </xsl:call-template>\n        </xsl:variable>\n\n        <xsl:value-of select=\"concat($sBefore, concat($sReplacement, $sAfterProcessed))\" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Templates -->\n  <xsl:template match=\"/\">\n    <mml:math>\n      <xsl:apply-templates select=\"*\" />\n    </mml:math>\n  </xsl:template>\n\n  <xsl:template match=\"m:borderBox\">\n\n    <!-- Get Lowercase versions of properties -->\n    <xsl:variable name=\"sLowerCaseHideTop\" select=\"translate(m:borderBoxPr[last()]/m:hideTop[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseHideBot\" select=\"translate(m:borderBoxPr[last()]/m:hideBot[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseHideLeft\" select=\"translate(m:borderBoxPr[last()]/m:hideLeft[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseHideRight\" select=\"translate(m:borderBoxPr[last()]/m:hideRight[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseStrikeH\" select=\"translate(m:borderBoxPr[last()]/m:strikeH[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseStrikeV\" select=\"translate(m:borderBoxPr[last()]/m:strikeV[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseStrikeBLTR\" select=\"translate(m:borderBoxPr[last()]/m:strikeBLTR[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseStrikeTLBR\" select=\"translate(m:borderBoxPr[last()]/m:strikeTLBR[last()]/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"fHideTop\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseHideTop\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fHideBot\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseHideBot\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fHideLeft\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseHideLeft\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fHideRight\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseHideRight\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fStrikeH\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseStrikeH\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fStrikeV\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseStrikeV\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fStrikeBLTR\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseStrikeBLTR\" />\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:variable name=\"fStrikeTLBR\">\n      <xsl:call-template name=\"ForceTrueStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseStrikeTLBR\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <xsl:choose>\n      <xsl:when test=\"$fHideTop=1\n                      and $fHideBot=1\n                      and $fHideLeft=1\n                      and $fHideRight=1\n                      and $fStrikeH=0\n                      and $fStrikeV=0\n                      and $fStrikeBLTR=0\n                      and $fStrikeTLBR=0\">\n        <mml:mrow>\n          <xsl:apply-templates select=\"m:e[1]\" />\n        </mml:mrow>\n      </xsl:when>\n      <xsl:otherwise>\n        <mml:menclose>\n          <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n            <xsl:with-param name=\"fHideTop\" select=\"$fHideTop\" />\n            <xsl:with-param name=\"fHideBot\" select=\"$fHideBot\" />\n            <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n            <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n            <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n            <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n            <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n            <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n          </xsl:call-template>\n          <xsl:apply-templates select=\"m:e[1]\" />\n        </mml:menclose>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"*\">\n    <xsl:apply-templates select=\"*\" />\n  </xsl:template>\n\n  <!--\n      { Non-combining, Upper-combining, Lower-combining }\n      {U+02D8, U+0306, U+032E}, // BREVE\n      {U+00B8, U+0312, U+0327}, // CEDILLA\n      {U+0060, U+0300, U+0316}, // GRAVE ACCENT\n      {U+002D, U+0305, U+0332}, // HYPHEN-MINUS/OVERLINE\n      {U+2212, U+0305, U+0332}, // MINUS SIGN/OVERLINE\n      {U+002E, U+0305, U+0323}, // FULL STOP/DOT ABOVE\n      {U+02D9, U+0307, U+0323}, // DOT ABOVE\n      {U+02DD, U+030B, U+02DD}, // DOUBLE ACUTE ACCENT\n      {U+00B4, U+0301, U+0317}, // ACUTE ACCENT\n      {U+007E, U+0303, U+0330}, // TILDE\n      {U+02DC, U+0303, U+0330}, // SMALL TILDE\n      {U+00A8, U+0308, U+0324}, // DIAERESIS\n      {U+02C7, U+030C, U+032C}, // CARON\n      {U+005E, U+0302, U+032D}, // CIRCUMFLEX ACCENT\n      {U+00AF, U+0305, ::::::}, // MACRON\n      {U+005F, ::::::, U+0332}, // LOW LINE\n      {U+2192, U+20D7, U+20EF}, // RIGHTWARDS ARROW\n      {U+27F6, U+20D7, U+20EF}, // LONG RIGHTWARDS ARROW\n      {U+2190, U+20D6, U+20EE}, // LEFT ARROW\n  -->\n  <xsl:template name=\"ToNonCombining\">\n    <xsl:param name=\"ch\" />\n    <xsl:choose>\n      <!-- BREVE -->\n      <xsl:when test=\"$ch='&#x0306;' or $ch='&#x032e;'\">&#x02D8;</xsl:when>\n      <!-- CEDILLA -->\n      <xsl:when test=\"$ch='&#x0312;' or $ch='&#x0327;'\">&#x00B8;</xsl:when>\n      <!-- GRAVE ACCENT -->\n      <xsl:when test=\"$ch='&#x0300;' or $ch='&#x0316;'\">&#x0060;</xsl:when>\n      <!-- HYPHEN-MINUS/OVERLINE -->\n      <xsl:when test=\"$ch='&#x0305;' or $ch='&#x0332;'\">&#x002D;</xsl:when>\n      <!-- MINUS SIGN/OVERLINE -->\n      <xsl:when test=\"$ch='&#x0305;' or $ch='&#x0332;'\">&#x2212;</xsl:when>\n      <!-- FULL STOP/DOT ABOVE -->\n      <xsl:when test=\"$ch='&#x0305;' or $ch='&#x0323;'\">&#x002E;</xsl:when>\n      <!-- DOT ABOVE -->\n      <xsl:when test=\"$ch='&#x0307;' or $ch='&#x0323;'\">&#x02D9;</xsl:when>\n      <!-- DOUBLE ACUTE ACCENT -->\n      <xsl:when test=\"$ch='&#x030B;' or $ch='&#x02DD;'\">&#x02DD;</xsl:when>\n      <!-- ACUTE ACCENT -->\n      <xsl:when test=\"$ch='&#x0301;' or $ch='&#x0317;'\">&#x00B4;</xsl:when>\n      <!-- TILDE -->\n      <xsl:when test=\"$ch='&#x0303;' or $ch='&#x0330;'\">&#x007E;</xsl:when>\n      <!-- SMALL TILDE -->\n      <xsl:when test=\"$ch='&#x0303;' or $ch='&#x0330;'\">&#x02DC;</xsl:when>\n      <!-- DIAERESIS -->\n      <xsl:when test=\"$ch='&#x0308;' or $ch='&#x0324;'\">&#x00A8;</xsl:when>\n      <!-- CARON -->\n      <xsl:when test=\"$ch='&#x030C;' or $ch='&#x032C;'\">&#x02C7;</xsl:when>\n      <!-- CIRCUMFLEX ACCENT -->\n      <xsl:when test=\"$ch='&#x0302;' or $ch='&#x032D;'\">&#x005E;</xsl:when>\n      <!-- MACRON -->\n      <xsl:when test=\"$ch='&#x0305;'                   \">&#x00AF;</xsl:when>\n      <!-- LOW LINE -->\n      <xsl:when test=\"                   $ch='&#x0332;'\">&#x005F;</xsl:when>\n      <!-- RIGHTWARDS ARROW -->\n      <xsl:when test=\"$ch='&#x20D7;' or $ch='&#x20EF;'\">&#x2192;</xsl:when>\n      <!-- LONG RIGHTWARDS ARROW -->\n      <xsl:when test=\"$ch='&#x20D7;' or $ch='&#x20EF;'\">&#x27F6;</xsl:when>\n      <!-- LEFT ARROW -->\n      <xsl:when test=\"$ch='&#x20D6;' or $ch='&#x20EE;'\">&#x2190;</xsl:when>\n      <xsl:otherwise>\n        <xsl:value-of select=\"$ch\"/>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"m:acc\">\n    <mml:mover>\n      <xsl:attribute name=\"accent\">true</xsl:attribute>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <xsl:variable name=\"chAcc\">\n        <xsl:choose>\n          <xsl:when test=\"not(m:accPr[last()]/m:chr)\">\n            <xsl:value-of select=\"'&#x0302;'\" />\n          </xsl:when>\n          <xsl:otherwise>\n            <xsl:value-of select=\"substring(m:accPr/m:chr/@m:val,1,1)\" />\n          </xsl:otherwise>\n        </xsl:choose>\n      </xsl:variable>\n      <xsl:variable name=\"chNonComb\">\n        <xsl:call-template name=\"ToNonCombining\">\n          <xsl:with-param name=\"ch\" select=\"$chAcc\" />\n        </xsl:call-template>\n      </xsl:variable>\n      <xsl:choose>\n        <xsl:when test=\"string-length($chAcc)=0\">\n          <mml:mo/>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ParseMt\">\n            <xsl:with-param name=\"sToParse\" select=\"$chNonComb\" />\n            <xsl:with-param name=\"scr\" select=\"m:e[1]/*/m:rPr[last()]/m:scr/@m:val\" />\n            <xsl:with-param name=\"sty\" select=\"m:e[1]/*/m:rPr[last()]/m:sty/@m:val\" />\n            <xsl:with-param name=\"nor\">\n              <xsl:choose>\n                <xsl:when test=\"count(m:e[1]/*/m:rPr[last()]/m:nor) = 0\">0</xsl:when>\n                <xsl:otherwise>\n                  <xsl:call-template name=\"ForceFalseStrVal\">\n                    <xsl:with-param name=\"str\" select=\"translate(m:e[1]/*/m:rPr[last()]/m:nor/@m:val,\n                                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                                 'abcdefghijklmnopqrstuvwxyz')\" />\n                  </xsl:call-template>\n                </xsl:otherwise>\n              </xsl:choose>\n            </xsl:with-param>\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </mml:mover>\n  </xsl:template>\n\n  <xsl:template name=\"OutputScript\">\n    <xsl:param name=\"ndCur\" select=\".\" />\n    <xsl:choose>\n      <!-- Only output contents of $ndCur if $ndCur exists\n           and $ndCur has children -->\n      <xsl:when test=\"count($ndCur/*) &gt; 0\">\n        <mml:mrow>\n          <xsl:apply-templates select=\"$ndCur\" />\n        </mml:mrow>\n      </xsl:when>\n      <xsl:otherwise>\n        <mml:none />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"m:sPre\">\n    <mml:mmultiscripts>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mprescripts />\n      <xsl:call-template name=\"OutputScript\">\n        <xsl:with-param name=\"ndCur\" select=\"m:sub[1]\"/>\n      </xsl:call-template>\n      <xsl:call-template name=\"OutputScript\">\n        <xsl:with-param name=\"ndCur\" select=\"m:sup[1]\" />\n      </xsl:call-template>\n    </mml:mmultiscripts>\n  </xsl:template>\n\n  <xsl:template match=\"m:m\">\n    <mml:mtable>\n      <xsl:call-template name=\"CreateMathMLMatrixAttr\">\n        <xsl:with-param name=\"mcJc\" select=\"m:mPr[last()]/m:mcs/m:mc/m:mcPr[last()]/m:mcJc/@m:val\" />\n      </xsl:call-template>\n      <xsl:for-each select=\"m:mr\">\n        <mml:mtr>\n          <xsl:for-each select=\"m:e\">\n            <mml:mtd>\n              <xsl:apply-templates select=\".\" />\n            </mml:mtd>\n          </xsl:for-each>\n        </mml:mtr>\n      </xsl:for-each>\n    </mml:mtable>\n  </xsl:template>\n\n  <xsl:template name=\"CreateMathMLMatrixAttr\">\n    <xsl:param name=\"mcJc\" />\n    <xsl:variable name=\"sLowerCaseMcjc\" select=\"translate($mcJc, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                             'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:choose>\n      <xsl:when test=\"$sLowerCaseMcjc='left'\">\n        <xsl:attribute name=\"columnalign\">left</xsl:attribute>\n      </xsl:when>\n      <xsl:when test=\"$sLowerCaseMcjc='right'\">\n        <xsl:attribute name=\"columnalign\">right</xsl:attribute>\n      </xsl:when>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"m:phant\">\n    <xsl:variable name=\"sLowerCaseZeroWidVal\" select=\"translate(m:phantPr[last()]/m:zeroWid[last()]/@m:val,\n\t\t                                                       'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                       'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseZeroAscVal\" select=\"translate(m:phantPr[last()]/m:zeroAsc[last()]/@m:val,\n\t\t                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                     'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseZeroDescVal\" select=\"translate(m:phantPr[last()]/m:zeroDesc[last()]/@m:val,\n\t\t                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                     'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"sLowerCaseShowVal\" select=\"translate(m:phantPr[last()]/m:show[last()]/@m:val,\n\t\t                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                     'abcdefghijklmnopqrstuvwxyz')\" />\n\n\n    <!-- The following properties default to 'yes' unless the last value equals 'no' or there isn't any node for\n         the property -->\n\n    <xsl:variable name=\"fZeroWid\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:phantPr[last()]/m:zeroWid[last()]) = 0\">0</xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ForceFalseStrVal\">\n            <xsl:with-param name=\"str\" select=\"$sLowerCaseZeroWidVal\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n    <xsl:variable name=\"fZeroAsc\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:phantPr[last()]/m:zeroAsc[last()]) = 0\">0</xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ForceFalseStrVal\">\n            <xsl:with-param name=\"str\" select=\"$sLowerCaseZeroAscVal\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n    <xsl:variable name=\"fZeroDesc\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:phantPr[last()]/m:zeroDesc[last()]) = 0\">0</xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ForceFalseStrVal\">\n            <xsl:with-param name=\"str\" select=\"$sLowerCaseZeroDescVal\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <!-- The show property defaults to 'on' unless there exists a show property and its value is 'off' -->\n\n    <xsl:variable name=\"fShow\">\n      <xsl:call-template name=\"ForceFalseStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseShowVal\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <xsl:choose>\n      <!-- Show the phantom contents, therefore, just use mpadded. -->\n      <xsl:when test=\"$fShow = 1\">\n        <xsl:element name=\"mml:mpadded\">\n          <xsl:call-template name=\"CreateMpaddedAttributes\">\n            <xsl:with-param name=\"fZeroWid\" select=\"$fZeroWid\" />\n            <xsl:with-param name=\"fZeroAsc\" select=\"$fZeroAsc\" />\n            <xsl:with-param name=\"fZeroDesc\" select=\"$fZeroDesc\" />\n          </xsl:call-template>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:e\" />\n          </mml:mrow>\n        </xsl:element>\n      </xsl:when>\n      <!-- Don't show phantom contents, but don't smash anything, therefore, just\n           use mphantom -->\n      <xsl:when test=\"$fZeroWid=0 and $fZeroAsc=0 and $fZeroDesc=0\">\n        <xsl:element name=\"mml:mphantom\">\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:e\" />\n          </mml:mrow>\n        </xsl:element>\n      </xsl:when>\n      <!-- Combination -->\n      <xsl:otherwise>\n        <xsl:element name=\"mml:mphantom\">\n          <xsl:element name=\"mml:mpadded\">\n            <xsl:call-template name=\"CreateMpaddedAttributes\">\n              <xsl:with-param name=\"fZeroWid\" select=\"$fZeroWid\" />\n              <xsl:with-param name=\"fZeroAsc\" select=\"$fZeroAsc\" />\n              <xsl:with-param name=\"fZeroDesc\" select=\"$fZeroDesc\" />\n            </xsl:call-template>\n            <mml:mrow>\n              <xsl:apply-templates select=\"m:e\" />\n            </mml:mrow>\n          </xsl:element>\n        </xsl:element>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template name=\"CreateMpaddedAttributes\">\n    <xsl:param name=\"fZeroWid\" />\n    <xsl:param name=\"fZeroAsc\" />\n    <xsl:param name=\"fZeroDesc\" />\n\n    <xsl:if test=\"$fZeroWid=1\">\n      <xsl:attribute name=\"width\">0in</xsl:attribute>\n    </xsl:if>\n    <xsl:if test=\"$fZeroAsc=1\">\n      <xsl:attribute name=\"height\">0in</xsl:attribute>\n    </xsl:if>\n    <xsl:if test=\"$fZeroDesc=1\">\n      <xsl:attribute name=\"depth\">0in</xsl:attribute>\n    </xsl:if>\n  </xsl:template>\n\n\n\n  <xsl:template match=\"m:rad\">\n    <xsl:variable name=\"fDegHide\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:radPr[last()]/m:degHide)=0\">0</xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ForceFalseStrVal\">\n            <xsl:with-param name=\"str\" select=\"translate(m:radPr[last()]/m:degHide/@m:val,\n\t\t                                                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                          'abcdefghijklmnopqrstuvwxyz')\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$fDegHide=1\">\n        <mml:msqrt>\n          <xsl:apply-templates select=\"m:e[1]\" />\n        </mml:msqrt>\n      </xsl:when>\n      <xsl:otherwise>\n        <mml:mroot>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:e[1]\" />\n          </mml:mrow>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:deg[1]\" />\n          </mml:mrow>\n        </mml:mroot>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template name=\"OutputNaryMo\">\n    <xsl:param name=\"ndCur\" select=\".\" />\n    <xsl:param name=\"fGrow\" select=\"0\" />\n    <mml:mo>\n      <xsl:choose>\n        <xsl:when test=\"$fGrow=1\">\n          <xsl:attribute name=\"stretchy\">true</xsl:attribute>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:attribute name=\"stretchy\">false</xsl:attribute>\n        </xsl:otherwise>\n      </xsl:choose>\n      <xsl:choose>\n        <xsl:when test=\"not($ndCur/m:naryPr[last()]/m:chr/@m:val) or\n\t\t\t                            $ndCur/m:naryPr[last()]/m:chr/@m:val=''\">\n          <xsl:text>&#x222b;</xsl:text>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:value-of select=\"$ndCur/m:naryPr[last()]/m:chr/@m:val\" />\n        </xsl:otherwise>\n      </xsl:choose>\n    </mml:mo>\n  </xsl:template>\n\n  <!-- %%Template match m:nary\n\t\tProcess an n-ary.\n\n\t\tDecides, based on which arguments are supplied, between\n\t\tusing an mo, msup, msub, or msubsup for the n-ary operator\n\t-->\n  <xsl:template match=\"m:nary\">\n    <xsl:variable name=\"sLowerCaseSubHide\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:naryPr[last()]/m:subHide) = 0\">\n          <xsl:text>off</xsl:text>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:value-of select=\"translate(m:naryPr[last()]/m:subHide/@m:val,\n\t                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t                                  'abcdefghijklmnopqrstuvwxyz')\" />\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <xsl:variable name=\"sLowerCaseSupHide\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:naryPr[last()]/m:supHide) = 0\">\n          <xsl:text>off</xsl:text>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:value-of select=\"translate(m:naryPr[last()]/m:supHide/@m:val,\n\t                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t                                  'abcdefghijklmnopqrstuvwxyz')\" />\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <xsl:variable name=\"sLowerCaseLimLoc\">\n      <xsl:value-of select=\"translate(m:naryPr[last()]/m:limLoc/@m:val,\n\t                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t                                  'abcdefghijklmnopqrstuvwxyz')\" />\n    </xsl:variable>\n\n    <xsl:variable name=\"sLowerGrow\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:naryPr[last()]/m:grow)=0\">off</xsl:when>\n        <xsl:otherwise>\n          <xsl:value-of select=\"translate(m:naryPr[last()]/m:grow/@m:val,\n\t                                  'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t                                  'abcdefghijklmnopqrstuvwxyz')\" />\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <xsl:variable name=\"fLimLocSubSup\">\n      <xsl:choose>\n        <xsl:when test=\"count(m:naryPr[last()]/m:limLoc)=0 or $sLowerCaseLimLoc='subsup'\">1</xsl:when>\n        <xsl:otherwise>0</xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <xsl:variable name=\"fGrow\">\n      <xsl:call-template name=\"ForceFalseStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerGrow\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <xsl:variable name=\"fSupHide\">\n      <xsl:call-template name=\"ForceFalseStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseSupHide\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <xsl:variable name=\"fSubHide\">\n      <xsl:call-template name=\"ForceFalseStrVal\">\n        <xsl:with-param name=\"str\" select=\"$sLowerCaseSubHide\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <mml:mrow>\n      <xsl:choose>\n        <xsl:when test=\"$fSupHide=1 and $fSubHide=1\">\n          <xsl:call-template name=\"OutputNaryMo\">\n            <xsl:with-param name=\"ndCur\" select=\".\" />\n            <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n          </xsl:call-template>\n        </xsl:when>\n        <xsl:when test=\"$fSubHide=1\">\n          <xsl:choose>\n            <xsl:when test=\"$fLimLocSubSup=1\">\n              <mml:msup>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sup[1]\" />\n                </mml:mrow>\n              </mml:msup>\n            </xsl:when>\n            <xsl:otherwise>\n              <mml:mover>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sup[1]\" />\n                </mml:mrow>\n              </mml:mover>\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:when>\n        <xsl:when test=\"$fSupHide=1\">\n          <xsl:choose>\n            <xsl:when test=\"$fLimLocSubSup=1\">\n              <mml:msub>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sub[1]\" />\n                </mml:mrow>\n              </mml:msub>\n            </xsl:when>\n            <xsl:otherwise>\n              <mml:munder>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sub[1]\" />\n                </mml:mrow>\n              </mml:munder>\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:choose>\n            <xsl:when test=\"$fLimLocSubSup=1\">\n              <mml:msubsup>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sub[1]\" />\n                </mml:mrow>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sup[1]\" />\n                </mml:mrow>\n              </mml:msubsup>\n            </xsl:when>\n            <xsl:otherwise>\n              <mml:munderover>\n                <xsl:call-template name=\"OutputNaryMo\">\n                  <xsl:with-param name=\"ndCur\" select=\".\" />\n                  <xsl:with-param name=\"fGrow\" select=\"$fGrow\" />\n                </xsl:call-template>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sub[1]\" />\n                </mml:mrow>\n                <mml:mrow>\n                  <xsl:apply-templates select=\"m:sup[1]\" />\n                </mml:mrow>\n              </mml:munderover>\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:otherwise>\n      </xsl:choose>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n    </mml:mrow>\n  </xsl:template>\n\n  <xsl:template match=\"m:limLow\">\n    <mml:munder>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:lim[1]\" />\n      </mml:mrow>\n    </mml:munder>\n  </xsl:template>\n\n  <xsl:template match=\"m:limUpp\">\n    <mml:mover>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:lim[1]\" />\n      </mml:mrow>\n    </mml:mover>\n  </xsl:template>\n\n  <xsl:template match=\"m:sSub\">\n    <mml:msub>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:sub[1]\" />\n      </mml:mrow>\n    </mml:msub>\n  </xsl:template>\n\n  <xsl:template match=\"m:sSup\">\n    <mml:msup>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:sup[1]\" />\n      </mml:mrow>\n    </mml:msup>\n  </xsl:template>\n\n  <xsl:template match=\"m:sSubSup\">\n    <mml:msubsup>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:sub[1]\" />\n      </mml:mrow>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:sup[1]\" />\n      </mml:mrow>\n    </mml:msubsup>\n  </xsl:template>\n\n  <xsl:template match=\"m:groupChr\">\n    <xsl:variable name=\"ndLastGroupChrPr\" select=\"m:groupChrPr[last()]\" />\n    <xsl:variable name=\"sLowerCasePos\" select=\"translate($ndLastGroupChrPr/m:pos/@m:val,\n\t\t                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                     'abcdefghijklmnopqrstuvwxyz')\" />\n\n    <xsl:variable name=\"sLowerCaseVertJc\" select=\"translate($ndLastGroupChrPr/m:vertJc/@m:val,\n\t\t                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                     'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:variable name=\"ndLastChr\" select=\"$ndLastGroupChrPr/m:chr\" />\n\n    <xsl:variable name=\"chr\">\n      <xsl:choose>\n        <xsl:when test=\"$ndLastChr and (not($ndLastChr/@m:val) or string-length($ndLastChr/@m:val) = 0)\"></xsl:when>\n        <xsl:when test=\"string-length($ndLastChr/@m:val) &gt;= 1\">\n          <xsl:value-of select=\"substring($ndLastChr/@m:val,1,1)\" />\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:text>&#x023DF;</xsl:text>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$sLowerCasePos = 'top'\">\n        <xsl:choose>\n          <xsl:when test=\"$sLowerCaseVertJc = 'bot'\">\n            <mml:mover accent=\"false\">\n              <mml:mrow>\n                <xsl:apply-templates select=\"m:e[1]\" />\n              </mml:mrow>\n              <mml:mo>\n                <xsl:value-of select=\"$chr\" />\n              </mml:mo>\n            </mml:mover>\n          </xsl:when>\n          <xsl:otherwise>\n            <mml:munder accentunder=\"false\">\n              <mml:mo>\n                <xsl:value-of select=\"$chr\" />\n              </mml:mo>\n              <mml:mrow>\n                <xsl:apply-templates select=\"m:e[1]\" />\n              </mml:mrow>\n            </mml:munder>\n          </xsl:otherwise>\n        </xsl:choose>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:choose>\n          <xsl:when test=\"$sLowerCaseVertJc = 'bot'\">\n            <mml:mover accent=\"false\">\n              <mml:mo>\n                <xsl:value-of select=\"$chr\" />\n              </mml:mo>\n              <mml:mrow>\n                <xsl:apply-templates select=\"m:e[1]\" />\n              </mml:mrow>\n            </mml:mover>\n          </xsl:when>\n          <xsl:otherwise>\n            <mml:munder accentunder=\"false\">\n              <mml:mrow>\n                <xsl:apply-templates select=\"m:e[1]\" />\n              </mml:mrow>\n              <mml:mo>\n                <xsl:value-of select=\"$chr\" />\n              </mml:mo>\n            </mml:munder>\n          </xsl:otherwise>\n        </xsl:choose>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template name=\"fName\">\n    <xsl:for-each select=\"m:fName/*\">\n      <xsl:apply-templates select=\".\" />\n    </xsl:for-each>\n  </xsl:template>\n\n  <xsl:template match=\"m:func\">\n    <mml:mrow>\n      <mml:mrow>\n        <xsl:call-template name=\"fName\" />\n      </mml:mrow>\n      <mml:mo>&#x02061;</mml:mo>\n      <mml:mrow>\n        <xsl:apply-templates select=\"m:e\" />\n      </mml:mrow>\n    </mml:mrow>\n  </xsl:template>\n\n  <!-- %%Template: match m:f\n\n\t\tm:f maps directly to mfrac.\n\t-->\n  <xsl:template match=\"m:f\">\n    <xsl:variable name=\"sLowerCaseType\" select=\"translate(m:fPr[last()]/m:type/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')\" />\n    <xsl:choose>\n      <xsl:when test=\"$sLowerCaseType='lin'\">\n        <mml:mrow>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:num[1]\" />\n          </mml:mrow>\n          <mml:mo>/</mml:mo>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:den[1]\" />\n          </mml:mrow>\n        </mml:mrow>\n      </xsl:when>\n      <xsl:otherwise>\n        <mml:mfrac>\n          <xsl:call-template name=\"CreateMathMLFracProp\">\n            <xsl:with-param name=\"type\" select=\"$sLowerCaseType\" />\n          </xsl:call-template>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:num[1]\" />\n          </mml:mrow>\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:den[1]\" />\n          </mml:mrow>\n        </mml:mfrac>\n      </xsl:otherwise>\n    </xsl:choose>\n\n  </xsl:template>\n\n\n  <!-- %%Template: CreateMathMLFracProp\n\n\t\t\tMake fraction properties based on supplied parameters.\n\t\t\tOMML differentiates between a linear fraction and a skewed\n\t\t\tone. For MathML, we write both as bevelled.\n\t-->\n  <xsl:template name=\"CreateMathMLFracProp\">\n    <xsl:param name=\"type\" />\n    <xsl:variable name=\"sLowerCaseType\" select=\"translate($type, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')\" />\n\n    <xsl:if test=\"$sLowerCaseType='skw' or $sLowerCaseType='lin'\">\n      <xsl:attribute name=\"bevelled\">true</xsl:attribute>\n    </xsl:if>\n    <xsl:if test=\"$sLowerCaseType='nobar'\">\n      <xsl:attribute name=\"linethickness\">0pt</xsl:attribute>\n    </xsl:if>\n    <xsl:choose>\n      <xsl:when test=\"sLowerCaseNumJc='right'\">\n        <xsl:attribute name=\"numalign\">right</xsl:attribute>\n      </xsl:when>\n      <xsl:when test=\"sLowerCaseNumJc='left'\">\n        <xsl:attribute name=\"numalign\">left</xsl:attribute>\n      </xsl:when>\n    </xsl:choose>\n    <xsl:choose>\n      <xsl:when test=\"sLowerCaseDenJc='right'\">\n        <xsl:attribute name=\"numalign\">right</xsl:attribute>\n      </xsl:when>\n      <xsl:when test=\"sLowerCaseDenJc='left'\">\n        <xsl:attribute name=\"numalign\">left</xsl:attribute>\n      </xsl:when>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- %%Template: match m:e | m:den | m:num | m:lim | m:sup | m:sub\n\n\t\tThese element delinate parts of an expression (like the numerator).  -->\n  <xsl:template match=\"m:e | m:den | m:num | m:lim | m:sup | m:sub\">\n    <xsl:choose>\n\n      <!-- If there is no scriptLevel specified, just call through -->\n      <xsl:when test=\"not(m:argPr[last()]/m:scrLvl/@m:val)\">\n        <xsl:apply-templates select=\"*\" />\n      </xsl:when>\n\n      <!-- Otherwise, create an mstyle and set the script level -->\n      <xsl:otherwise>\n        <mml:mstyle>\n          <xsl:attribute name=\"scriptlevel\">\n            <xsl:value-of select=\"m:argPr[last()]/m:scrLvl/@m:val\" />\n          </xsl:attribute>\n          <xsl:apply-templates select=\"*\" />\n        </mml:mstyle>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"m:bar\">\n    <xsl:variable name=\"sLowerCasePos\" select=\"translate(m:barPr/m:pos/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                                       'abcdefghijklmnopqrstuvwxyz')\" />\n\n    <xsl:variable name=\"fTop\">\n\n      <xsl:choose>\n        <xsl:when test=\"$sLowerCasePos='top'\">1</xsl:when>\n        <xsl:otherwise>0</xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$fTop=1\">\n        <mml:mover accent=\"false\">\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:e[1]\" />\n          </mml:mrow>\n          <mml:mo>\n            <xsl:text>&#x00AF;</xsl:text>\n          </mml:mo>\n        </mml:mover>\n      </xsl:when>\n      <xsl:otherwise>\n        <mml:munder underaccent=\"false\">\n          <mml:mrow>\n            <xsl:apply-templates select=\"m:e[1]\" />\n          </mml:mrow>\n          <mml:mo>\n            <xsl:text>&#x005F;</xsl:text>\n          </mml:mo>\n        </mml:munder>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- %%Template match m:d\n\n\t\tProcess a delimiter.\n\t-->\n  <xsl:template match=\"m:d\">\n    <mml:mfenced>\n      <!-- open: default is '(' for both OMML and MathML -->\n      <xsl:if test=\"m:dPr[1]/m:begChr/@m:val and not(m:dPr[1]/m:begChr/@m:val ='(')\">\n        <xsl:attribute name=\"open\">\n          <xsl:value-of select=\"m:dPr[1]/m:begChr/@m:val\" />\n        </xsl:attribute>\n      </xsl:if>\n\n      <!-- close: default is ')' for both OMML and MathML -->\n      <xsl:if test=\"m:dPr[1]/m:endChr/@m:val and not(m:dPr[1]/m:endChr/@m:val =')')\">\n        <xsl:attribute name=\"close\">\n          <xsl:value-of select=\"m:dPr[1]/m:endChr/@m:val\" />\n        </xsl:attribute>\n      </xsl:if>\n\n      <!-- separator: the default is ',' for MathML, and '|' for OMML -->\n      <xsl:choose>\n        <!-- Matches MathML default. Write nothing -->\n        <xsl:when test=\"m:dPr[1]/m:sepChr/@m:val = ','\" />\n\n        <!-- OMML default: | -->\n        <xsl:when test=\"not(m:dPr[1]/m:sepChr/@m:val)\">\n          <xsl:attribute name=\"separators\">\n            <xsl:value-of select=\"'|'\" />\n          </xsl:attribute>\n        </xsl:when>\n\n        <xsl:otherwise>\n          <xsl:attribute name=\"separators\">\n            <xsl:value-of select=\"m:dPr[1]/m:sepChr/@m:val\" />\n          </xsl:attribute>\n        </xsl:otherwise>\n      </xsl:choose>\n\n      <!-- now write all the children. Put each one into an mrow\n\t\t\tjust in case it produces multiple runs, etc -->\n      <xsl:for-each select=\"m:e\">\n        <mml:mrow>\n          <xsl:apply-templates select=\".\" />\n        </mml:mrow>\n      </xsl:for-each>\n    </mml:mfenced>\n  </xsl:template>\n\n  <xsl:template match=\"m:r\">\n    <xsl:variable name=\"fNor\">\n      <xsl:choose>\n        <xsl:when test=\"count(child::m:rPr[last()]/m:nor) = 0\">0</xsl:when>\n        <xsl:otherwise>\n          <xsl:call-template name=\"ForceFalseStrVal\">\n            <xsl:with-param name=\"str\" select=\"translate(child::m:rPr[last()]/m:nor/@m:val, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                                       'abcdefghijklmnopqrstuvwxyz')\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:variable>\n\n    <xsl:choose>\n      <xsl:when test=\"$fNor=1\">\n        <mml:mtext>\n          <xsl:variable name=\"sOutput\" select=\"translate(.//m:t, ' ', '&#xa0;')\" />\n          <xsl:value-of select=\"$sOutput\" />\n        </mml:mtext>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:for-each select=\".//m:t\">\n          <xsl:call-template name=\"ParseMt\">\n            <xsl:with-param name=\"sToParse\" select=\"text()\" />\n            <xsl:with-param name=\"scr\" select=\"../m:rPr[last()]/m:scr/@m:val\" />\n            <xsl:with-param name=\"sty\" select=\"../m:rPr[last()]/m:sty/@m:val\" />\n            <xsl:with-param name=\"nor\">0</xsl:with-param>\n          </xsl:call-template>\n        </xsl:for-each>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n\n  <xsl:template name=\"CreateTokenAttributes\">\n    <xsl:param name=\"scr\" />\n    <xsl:param name=\"sty\" />\n    <xsl:param name=\"nor\" />\n    <xsl:param name=\"nCharToPrint\" />\n    <xsl:param name=\"sTokenType\" />\n\n    <xsl:choose>\n      <xsl:when test=\"$nor=1\">\n        <xsl:attribute name=\"mathvariant\">normal</xsl:attribute>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:variable name=\"mathvariant\">\n          <xsl:choose>\n            <!-- numbers don't care -->\n            <xsl:when test=\"$sTokenType='mn'\" />\n\n            <xsl:when test=\"$scr='monospace'\">monospace</xsl:when>\n            <xsl:when test=\"$scr='sans-serif' and $sty='i'\">sans-serif-italic</xsl:when>\n            <xsl:when test=\"$scr='sans-serif' and $sty='b'\">bold-sans-serif</xsl:when>\n            <xsl:when test=\"$scr='sans-serif' and $sty='bi'\">sans-serif-bold-italic</xsl:when>\n            <xsl:when test=\"$scr='sans-serif'\">sans-serif</xsl:when>\n            <xsl:when test=\"$scr='fraktur' and ($sty='b' or $sty='bi')\">bold-fraktur</xsl:when>\n            <xsl:when test=\"$scr='fraktur'\">fraktur</xsl:when>\n            <xsl:when test=\"$scr='double-struck'\">double-struck</xsl:when>\n            <xsl:when test=\"$scr='script' and ($sty='b' or $sty='bi')\">bold-script</xsl:when>\n            <xsl:when test=\"$scr='script'\">script</xsl:when>\n            <xsl:when test=\"($scr='roman' or not($scr) or $scr='') and $sty='b'\">bold</xsl:when>\n            <xsl:when test=\"($scr='roman' or not($scr) or $scr='') and $sty='i'\">italic</xsl:when>\n            <xsl:when test=\"($scr='roman' or not($scr) or $scr='') and $sty='p'\">normal</xsl:when>\n            <xsl:when test=\"($scr='roman' or not($scr) or $scr='') and $sty='bi'\">bold-italic</xsl:when>\n            <xsl:otherwise />\n          </xsl:choose>\n        </xsl:variable>\n        <xsl:variable name=\"fontweight\">\n          <xsl:choose>\n            <xsl:when test=\"$sty='b' or $sty='bi'\">bold</xsl:when>\n            <xsl:otherwise>normal</xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n        <xsl:variable name=\"fontstyle\">\n          <xsl:choose>\n            <xsl:when test=\"$sty='p' or $sty='b'\">normal</xsl:when>\n            <xsl:otherwise>italic</xsl:otherwise>\n          </xsl:choose>\n        </xsl:variable>\n\n        <!-- Writing of attributes begins here -->\n        <xsl:choose>\n          <!-- Don't write mathvariant for operators unless they want to be normal -->\n          <xsl:when test=\"$sTokenType='mo' and $mathvariant!='normal'\" />\n\n          <!-- A single character within an mi is already italics, don't write -->\n          <xsl:when test=\"$sTokenType='mi' and $nCharToPrint=1 and ($mathvariant='' or $mathvariant='italic')\" />\n\n          <xsl:when test=\"$sTokenType='mi' and $nCharToPrint &gt; 1 and ($mathvariant='' or $mathvariant='italic')\">\n            <xsl:attribute name=\"mathvariant\">\n              <xsl:value-of select=\"'italic'\" />\n            </xsl:attribute>\n          </xsl:when>\n          <xsl:when test=\"$mathvariant!='italic' and $mathvariant!=''\">\n            <xsl:attribute name=\"mathvariant\">\n              <xsl:value-of select=\"$mathvariant\" />\n            </xsl:attribute>\n          </xsl:when>\n          <xsl:otherwise>\n            <xsl:if test=\"not($sTokenType='mi' and $nCharToPrint=1) and $fontstyle='italic'\">\n              <xsl:attribute name=\"fontstyle\">italic</xsl:attribute>\n            </xsl:if>\n            <xsl:if test=\"$fontweight='bold'\">\n              <xsl:attribute name=\"fontweight\">bold</xsl:attribute>\n            </xsl:if>\n          </xsl:otherwise>\n        </xsl:choose>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <xsl:template match=\"m:eqArr\">\n    <mml:mtable>\n      <xsl:for-each select=\"m:e\">\n        <mml:mtr>\n          <mml:mtd>\n            <xsl:choose>\n              <xsl:when test=\"m:argPr[last()]/m:scrLvl/@m:val!='0' or\n\t\t\t\t\t            not(m:argPr[last()]/m:scrLvl/@m:val)  or\n\t\t\t\t\t            m:argPr[last()]/m:scrLvl/@m:val=''\">\n                <mml:mrow>\n                  <mml:maligngroup />\n                  <xsl:call-template name=\"CreateEqArrRow\">\n                    <xsl:with-param name=\"align\" select=\"1\" />\n                    <xsl:with-param name=\"ndCur\" select=\"*[1]\" />\n                  </xsl:call-template>\n                </mml:mrow>\n              </xsl:when>\n              <xsl:otherwise>\n                <mml:mstyle>\n                  <xsl:attribute name=\"scriptlevel\">\n                    <xsl:value-of select=\"m:argPr[last()]/m:scrLvl/@m:val\" />\n                  </xsl:attribute>\n                  <mml:maligngroup />\n                  <xsl:call-template name=\"CreateEqArrRow\">\n                    <xsl:with-param name=\"align\" select=\"1\" />\n                    <xsl:with-param name=\"ndCur\" select=\"*[1]\" />\n                  </xsl:call-template>\n                </mml:mstyle>\n              </xsl:otherwise>\n            </xsl:choose>\n          </mml:mtd>\n        </mml:mtr>\n      </xsl:for-each>\n    </mml:mtable>\n  </xsl:template>\n\n  <xsl:template name=\"CreateEqArrRow\">\n    <xsl:param name=\"align\" />\n    <xsl:param name=\"ndCur\" />\n    <xsl:variable name=\"sAllMt\">\n      <xsl:for-each select=\"$ndCur/m:t\">\n        <xsl:value-of select=\".\" />\n      </xsl:for-each>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$ndCur/self::m:r\">\n        <xsl:call-template name=\"ParseEqArrMr\">\n          <xsl:with-param name=\"sToParse\" select=\"$sAllMt\" />\n          <xsl:with-param name=\"scr\" select=\"../m:rPr[last()]/m:scr/@m:val\" />\n          <xsl:with-param name=\"sty\" select=\"../m:rPr[last()]/m:sty/@m:val\" />\n          <xsl:with-param name=\"nor\">\n            <xsl:choose>\n              <xsl:when test=\"count($ndCur/m:rPr[last()]/m:nor) = 0\">0</xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"ForceFalseStrVal\">\n                  <xsl:with-param name=\"str\" select=\"translate($ndCur/m:rPr[last()]/m:nor/@m:val,\n                                                                     'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\t\t                                                                 'abcdefghijklmnopqrstuvwxyz')\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:with-param>\n          <xsl:with-param name=\"align\" select=\"$align\" />\n        </xsl:call-template>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:apply-templates select=\"$ndCur\" />\n      </xsl:otherwise>\n    </xsl:choose>\n    <xsl:if test=\"count($ndCur/following-sibling::*) &gt; 0\">\n      <xsl:variable name=\"cAmp\">\n        <xsl:call-template name=\"CountAmp\">\n          <xsl:with-param name=\"sAllMt\" select=\"$sAllMt\" />\n          <xsl:with-param name=\"cAmp\" select=\"0\" />\n        </xsl:call-template>\n      </xsl:variable>\n      <xsl:call-template name=\"CreateEqArrRow\">\n        <xsl:with-param name=\"align\" select=\"($align+($cAmp mod 2)) mod 2\" />\n        <xsl:with-param name=\"ndCur\" select=\"$ndCur/following-sibling::*[1]\" />\n      </xsl:call-template>\n    </xsl:if>\n  </xsl:template>\n\n  <xsl:template name=\"CountAmp\">\n    <xsl:param name=\"sAllMt\" />\n    <xsl:param name=\"cAmp\" />\n    <xsl:choose>\n      <xsl:when test=\"string-length(substring-after($sAllMt, '&amp;')) &gt; 0 or\n\t\t\t                substring($sAllMt, string-length($sAllMt))='&#x0026;'\">\n        <xsl:call-template name=\"CountAmp\">\n          <xsl:with-param name=\"sAllMt\" select=\"substring-after($sAllMt, '&#x0026;')\" />\n          <xsl:with-param name=\"cAmp\" select=\"$cAmp+1\" />\n        </xsl:call-template>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:value-of select=\"$cAmp\" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- %%Template: ParseEqArrMr\n\n\t\t\tSimilar to ParseMt, but this one has to do more for an equation array.\n      In equation arrays &amp; is a special character which denotes alignment.\n\n      The &amp; in an equation works by alternating between meaning insert alignment spacing\n      and insert alignment mark.  For each equation in the equation array\n      there is an implied align space at the beginning of the equation.  Within each equation,\n      the first &amp; means alignmark, the second, align space, the third, alignmark, etc.\n\n      For this reason when parsing m:r's in equation arrays it is important to keep track of what\n      the next ampersand will mean.\n\n      $align=0 => Omml's align space, which is similar to MathML's maligngroup.\n      $align=1 => Omml's alignment mark, which is similar to MathML's malignmark.\n\t-->\n  <xsl:template name=\"ParseEqArrMr\">\n    <xsl:param name=\"sToParse\" />\n    <xsl:param name=\"sty\" />\n    <xsl:param name=\"scr\" />\n    <xsl:param name=\"nor\" />\n    <xsl:param name=\"align\" />\n\n    <xsl:if test=\"string-length($sToParse) &gt; 0\">\n      <xsl:choose>\n        <xsl:when test=\"substring($sToParse,1,1) = '&amp;'\">\n          <xsl:choose>\n            <xsl:when test=\"$align='0'\">\n              <mml:maligngroup />\n            </xsl:when>\n            <xsl:when test=\"$align='1'\">\n              <mml:malignmark />\n            </xsl:when>\n          </xsl:choose>\n          <xsl:call-template name=\"ParseEqArrMr\">\n            <xsl:with-param name=\"sToParse\" select=\"substring($sToParse,2)\" />\n            <xsl:with-param name=\"scr\" select=\"$scr\" />\n            <xsl:with-param name=\"sty\" select=\"$sty\" />\n            <xsl:with-param name=\"nor\" select=\"$nor\" />\n            <xsl:with-param name=\"align\">\n              <xsl:choose>\n                <xsl:when test=\"$align='1'\">0</xsl:when>\n                <xsl:otherwise>1</xsl:otherwise>\n              </xsl:choose>\n            </xsl:with-param>\n          </xsl:call-template>\n        </xsl:when>\n        <xsl:otherwise>\n          <xsl:variable name=\"sRepNumWith0\">\n            <xsl:call-template name=\"SReplaceNumWithZero\">\n              <xsl:with-param name=\"sToParse\" select=\"$sToParse\" />\n            </xsl:call-template>\n          </xsl:variable>\n          <xsl:variable name=\"sRepOperWith-\">\n            <xsl:call-template name=\"SReplaceOperWithMinus\">\n              <xsl:with-param name=\"sToParse\" select=\"$sRepNumWith0\" />\n            </xsl:call-template>\n          </xsl:variable>\n\n          <xsl:variable name=\"iFirstOper\" select=\"string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '-'))\" />\n          <xsl:variable name=\"iFirstNum\" select=\"string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '0'))\" />\n          <xsl:variable name=\"iFirstAmp\" select=\"string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '&#x0026;'))\" />\n          <xsl:variable name=\"fNumAtPos1\">\n            <xsl:choose>\n              <xsl:when test=\"substring($sRepOperWith-,1,1)='0'\">1</xsl:when>\n              <xsl:otherwise>0</xsl:otherwise>\n            </xsl:choose>\n          </xsl:variable>\n          <xsl:variable name=\"fOperAtPos1\">\n            <xsl:choose>\n              <xsl:when test=\"substring($sRepOperWith-,1,1)='-'\">1</xsl:when>\n              <xsl:otherwise>0</xsl:otherwise>\n            </xsl:choose>\n          </xsl:variable>\n          <xsl:choose>\n\n            <!-- Case I: The string begins with neither a number, nor an operator -->\n            <xsl:when test=\"$fNumAtPos1='0' and $fOperAtPos1='0'\">\n              <xsl:choose>\n                <xsl:when test=\"$nor = 0\">\n                  <mml:mi>\n                    <xsl:call-template name=\"CreateTokenAttributes\">\n                      <xsl:with-param name=\"scr\" select=\"$scr\" />\n                      <xsl:with-param name=\"sty\" select=\"$sty\" />\n                      <xsl:with-param name=\"nor\" select=\"$nor\" />\n                      <xsl:with-param name=\"nCharToPrint\" select=\"1\" />\n                      <xsl:with-param name=\"sTokenType\" select=\"'mi'\" />\n                    </xsl:call-template>\n                    <xsl:variable name=\"sOutput\" select=\"translate(substring($sToParse, 1, 1), ' ', '&#xa0;')\" />\n                    <xsl:value-of select=\"$sOutput\" />\n                  </mml:mi>\n                </xsl:when>\n                <xsl:otherwise>\n                  <mml:mtext>\n                    <xsl:variable name=\"sOutput\" select=\"translate(substring($sToParse, 1, 1), ' ', '&#xa0;')\" />\n                    <xsl:value-of select=\"$sOutput\" />\n                  </mml:mtext>\n                </xsl:otherwise>\n              </xsl:choose>\n              <xsl:call-template name=\"ParseEqArrMr\">\n                <xsl:with-param name=\"sToParse\" select=\"substring($sToParse, 2)\" />\n                <xsl:with-param name=\"scr\" select=\"$scr\" />\n                <xsl:with-param name=\"sty\" select=\"$sty\" />\n                <xsl:with-param name=\"nor\" select=\"$nor\" />\n                <xsl:with-param name=\"align\" select=\"$align\" />\n              </xsl:call-template>\n            </xsl:when>\n\n            <!-- Case II: There is an operator at position 1 -->\n            <xsl:when test=\"$fOperAtPos1='1'\">\n              <xsl:choose>\n                <xsl:when test=\"$nor = 0\">\n                  <mml:mo>\n                    <xsl:call-template name=\"CreateTokenAttributes\">\n                      <xsl:with-param name=\"scr\" />\n                      <xsl:with-param name=\"sty\" />\n                      <xsl:with-param name=\"nor\" select=\"$nor\" />\n                      <xsl:with-param name=\"sTokenType\" select=\"'mo'\" />\n                    </xsl:call-template>\n                    <xsl:value-of select=\"substring($sToParse,1,1)\" />\n                  </mml:mo>\n                </xsl:when>\n                <xsl:otherwise>\n                  <mml:mtext>\n                    <xsl:value-of select=\"substring($sToParse,1,1)\" />\n                  </mml:mtext>\n                </xsl:otherwise>\n              </xsl:choose>\n              <xsl:call-template name=\"ParseEqArrMr\">\n                <xsl:with-param name=\"sToParse\" select=\"substring($sToParse, 2)\" />\n                <xsl:with-param name=\"scr\" select=\"$scr\" />\n                <xsl:with-param name=\"sty\" select=\"$sty\" />\n                <xsl:with-param name=\"nor\" select=\"$nor\" />\n                <xsl:with-param name=\"align\" select=\"$align\" />\n              </xsl:call-template>\n            </xsl:when>\n\n            <!-- Case III: There is a number at position 1 -->\n            <xsl:otherwise>\n              <xsl:variable name=\"sConsecNum\">\n                <xsl:call-template name=\"SNumStart\">\n                  <xsl:with-param name=\"sToParse\" select=\"$sToParse\" />\n                  <xsl:with-param name=\"sPattern\" select=\"$sRepNumWith0\" />\n                </xsl:call-template>\n              </xsl:variable>\n              <xsl:choose>\n                <xsl:when test=\"$nor = 0\">\n                  <mml:mn>\n                    <xsl:call-template name=\"CreateTokenAttributes\">\n                      <xsl:with-param name=\"scr\" />\n                      <xsl:with-param name=\"sty\" select=\"'p'\"/>\n                      <xsl:with-param name=\"nor\" select=\"$nor\" />\n                      <xsl:with-param name=\"sTokenType\" select=\"'mn'\" />\n                    </xsl:call-template>\n                    <xsl:value-of select=\"$sConsecNum\" />\n                  </mml:mn>\n                </xsl:when>\n                <xsl:otherwise>\n                  <mml:mtext>\n                    <xsl:value-of select=\"$sConsecNum\" />\n                  </mml:mtext>\n                </xsl:otherwise>\n              </xsl:choose>\n              <xsl:call-template name=\"ParseEqArrMr\">\n                <xsl:with-param name=\"sToParse\" select=\"substring-after($sToParse, $sConsecNum)\" />\n                <xsl:with-param name=\"scr\" select=\"$scr\" />\n                <xsl:with-param name=\"sty\" select=\"$sty\" />\n                <xsl:with-param name=\"nor\" select=\"$nor\" />\n                <xsl:with-param name=\"align\" select=\"$align\" />\n              </xsl:call-template>\n            </xsl:otherwise>\n          </xsl:choose>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:if>\n  </xsl:template>\n\n  <!-- %%Template: ParseMt\n\n\t\t\tProduce a run of text. Technically, OMML makes no distinction\n\t\t\tbetween numbers, operators, and other characters in a run. For\n\t\t\tMathML we need to break these into mi, mn, or mo elements.\n\n\t\t\tSee also ParseEqArrMr\n\t-->\n  <xsl:template name=\"ParseMt\">\n    <xsl:param name=\"sToParse\" />\n    <xsl:param name=\"sty\" />\n    <xsl:param name=\"scr\" />\n    <xsl:param name=\"nor\" />\n    <xsl:if test=\"string-length($sToParse) &gt; 0\">\n      <xsl:variable name=\"sRepNumWith0\">\n        <xsl:call-template name=\"SReplaceNumWithZero\">\n          <xsl:with-param name=\"sToParse\" select=\"$sToParse\" />\n        </xsl:call-template>\n      </xsl:variable>\n      <xsl:variable name=\"sRepOperWith-\">\n        <xsl:call-template name=\"SReplaceOperWithMinus\">\n          <xsl:with-param name=\"sToParse\" select=\"$sRepNumWith0\" />\n        </xsl:call-template>\n      </xsl:variable>\n\n      <xsl:variable name=\"iFirstOper\" select=\"string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '-'))\" />\n      <xsl:variable name=\"iFirstNum\" select=\"string-length($sRepOperWith-) - string-length(substring-after($sRepOperWith-, '0'))\" />\n      <xsl:variable name=\"fNumAtPos1\">\n        <xsl:choose>\n          <xsl:when test=\"substring($sRepOperWith-,1,1)='0'\">1</xsl:when>\n          <xsl:otherwise>0</xsl:otherwise>\n        </xsl:choose>\n      </xsl:variable>\n      <xsl:variable name=\"fOperAtPos1\">\n        <xsl:choose>\n          <xsl:when test=\"substring($sRepOperWith-,1,1)='-'\">1</xsl:when>\n          <xsl:otherwise>0</xsl:otherwise>\n        </xsl:choose>\n      </xsl:variable>\n\n      <xsl:choose>\n\n        <!-- Case I: The string begins with neither a number, nor an operator -->\n        <xsl:when test=\"$fOperAtPos1='0' and $fNumAtPos1='0'\">\n          <xsl:variable name=\"nCharToPrint\">\n            <xsl:choose>\n              <xsl:when test=\"ancestor::m:fName\">\n                <xsl:choose>\n                  <xsl:when test=\"($iFirstOper=$iFirstNum) and\n\t\t\t\t\t\t\t\t\t\t\t($iFirstOper=string-length($sToParse)) and\n\t\t\t\t\t\t\t                (substring($sRepOperWith-, string-length($sRepOperWith-))!='0') and\n\t\t\t\t\t\t\t                (substring($sRepOperWith-, string-length($sRepOperWith-))!='-')\">\n                    <xsl:value-of select=\"string-length($sToParse)\" />\n                  </xsl:when>\n                  <xsl:when test=\"$iFirstOper &lt; $iFirstNum\">\n                    <xsl:value-of select=\"$iFirstOper - 1\" />\n                  </xsl:when>\n                  <xsl:otherwise>\n                    <xsl:value-of select=\"$iFirstNum - 1\" />\n                  </xsl:otherwise>\n                </xsl:choose>\n              </xsl:when>\n              <xsl:otherwise>1</xsl:otherwise>\n            </xsl:choose>\n          </xsl:variable>\n\n          <mml:mi>\n            <xsl:call-template name=\"CreateTokenAttributes\">\n              <xsl:with-param name=\"scr\" select=\"$scr\" />\n              <xsl:with-param name=\"sty\" select=\"$sty\" />\n              <xsl:with-param name=\"nor\" select=\"$nor\" />\n              <xsl:with-param name=\"nCharToPrint\" select=\"$nCharToPrint\" />\n              <xsl:with-param name=\"sTokenType\" select=\"'mi'\" />\n            </xsl:call-template>\n            <xsl:variable name=\"sWrite\" select=\"translate(substring($sToParse, 1, $nCharToPrint), ' ', '&#xa0;')\" />\n            <xsl:value-of select=\"$sWrite\" />\n          </mml:mi>\n          <xsl:call-template name=\"ParseMt\">\n            <xsl:with-param name=\"sToParse\" select=\"substring($sToParse, $nCharToPrint+1)\" />\n            <xsl:with-param name=\"scr\" select=\"$scr\" />\n            <xsl:with-param name=\"sty\" select=\"$sty\" />\n            <xsl:with-param name=\"nor\" select=\"$nor\" />\n          </xsl:call-template>\n        </xsl:when>\n\n        <!-- Case II: There is an operator at position 1 -->\n        <xsl:when test=\"$fOperAtPos1='1'\">\n          <mml:mo>\n            <xsl:call-template name=\"CreateTokenAttributes\">\n              <xsl:with-param name=\"scr\" />\n              <xsl:with-param name=\"sty\" />\n              <xsl:with-param name=\"nor\" select=\"$nor\" />\n              <xsl:with-param name=\"sTokenType\" select=\"'mo'\" />\n            </xsl:call-template>\n            <xsl:value-of select=\"substring($sToParse,1,1)\" />\n          </mml:mo>\n          <xsl:call-template name=\"ParseMt\">\n            <xsl:with-param name=\"sToParse\" select=\"substring($sToParse, 2)\" />\n            <xsl:with-param name=\"scr\" select=\"$scr\" />\n            <xsl:with-param name=\"sty\" select=\"$sty\" />\n            <xsl:with-param name=\"nor\" select=\"$nor\" />\n          </xsl:call-template>\n        </xsl:when>\n\n        <!-- Case III: There is a number at position 1 -->\n        <xsl:otherwise>\n          <xsl:variable name=\"sConsecNum\">\n            <xsl:call-template name=\"SNumStart\">\n              <xsl:with-param name=\"sToParse\" select=\"$sToParse\" />\n              <xsl:with-param name=\"sPattern\" select=\"$sRepNumWith0\" />\n            </xsl:call-template>\n          </xsl:variable>\n          <mml:mn>\n            <xsl:call-template name=\"CreateTokenAttributes\">\n              <xsl:with-param name=\"scr\" select=\"$scr\" />\n              <xsl:with-param name=\"sty\" select=\"'p'\" />\n              <xsl:with-param name=\"nor\" select=\"$nor\" />\n              <xsl:with-param name=\"sTokenType\" select=\"'mn'\" />\n            </xsl:call-template>\n            <xsl:value-of select=\"$sConsecNum\" />\n          </mml:mn>\n          <xsl:call-template name=\"ParseMt\">\n            <xsl:with-param name=\"sToParse\" select=\"substring-after($sToParse, $sConsecNum)\" />\n            <xsl:with-param name=\"scr\" select=\"$scr\" />\n            <xsl:with-param name=\"sty\" select=\"$sty\" />\n            <xsl:with-param name=\"nor\" select=\"$nor\" />\n          </xsl:call-template>\n        </xsl:otherwise>\n      </xsl:choose>\n    </xsl:if>\n  </xsl:template>\n\n  <!-- %%Template: SNumStart\n\n\t\tReturn the longest substring of sToParse starting from the\n\t\tstart of sToParse that is a number. In addition, it takes the\n\t\tpattern string, which is sToParse with all of its numbers\n\t\treplaced with a 0. sPattern should be the same length\n\t\tas sToParse\n\t-->\n  <xsl:template name=\"SNumStart\">\n    <xsl:param name=\"sToParse\" select=\"''\" />\n    <!-- if we don't get anything, take the string itself -->\n    <xsl:param name=\"sPattern\" select=\"'$sToParse'\" />\n\n\n    <xsl:choose>\n      <!-- the pattern says this is a number, recurse with the rest -->\n      <xsl:when test=\"substring($sPattern, 1, 1) = '0'\">\n        <xsl:call-template name=\"SNumStart\">\n          <xsl:with-param name=\"sToParse\" select=\"$sToParse\" />\n          <xsl:with-param name=\"sPattern\" select=\"substring($sPattern, 2)\" />\n        </xsl:call-template>\n      </xsl:when>\n\n      <!-- the pattern says we've run out of numbers. Take as many\n\t\t\t\tcharacters from sToParse as we shaved off sPattern -->\n      <xsl:otherwise>\n        <xsl:value-of select=\"substring($sToParse, 1, string-length($sToParse) - string-length($sPattern))\" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- %%Template SRepeatCharAcc\n\n\t\t\tThe core of SRepeatChar with an accumulator. The current\n\t\t\tstring is in param $acc, and we will double and recurse,\n\t\t\tif we're less than half of the required length or else just\n\t\t\tadd the right amount of characters to the accumulator and\n\t\t\treturn\n\t-->\n  <xsl:template name=\"SRepeatCharAcc\">\n    <xsl:param name=\"cchRequired\" select=\"1\" />\n    <xsl:param name=\"ch\" select=\"'-'\" />\n    <xsl:param name=\"acc\" select=\"$ch\" />\n\n    <xsl:variable name=\"cchAcc\" select=\"string-length($acc)\" />\n    <xsl:choose>\n      <xsl:when test=\"(2 * $cchAcc) &lt; $cchRequired\">\n        <xsl:call-template name=\"SRepeatCharAcc\">\n          <xsl:with-param name=\"cchRequired\" select=\"$cchRequired\" />\n          <xsl:with-param name=\"ch\" select=\"$ch\" />\n          <xsl:with-param name=\"acc\" select=\"concat($acc, $acc)\" />\n        </xsl:call-template>\n      </xsl:when>\n\n      <xsl:otherwise>\n        <xsl:value-of select=\"concat($acc, substring($acc, 1, $cchRequired - $cchAcc))\" />\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n\n  <!-- %%Template SRepeatChar\n\n\t\t\tGenerates a string nchRequired long by repeating the given character ch\n\t-->\n  <xsl:template name=\"SRepeatChar\">\n    <xsl:param name=\"cchRequired\" select=\"1\" />\n    <xsl:param name=\"ch\" select=\"'-'\" />\n\n    <xsl:call-template name=\"SRepeatCharAcc\">\n      <xsl:with-param name=\"cchRequired\" select=\"$cchRequired\" />\n      <xsl:with-param name=\"ch\" select=\"$ch\" />\n      <xsl:with-param name=\"acc\" select=\"$ch\" />\n    </xsl:call-template>\n  </xsl:template>\n\n  <!-- %%Template SReplaceOperWithMinus\n\n\t\tGo through the given string and replace every instance\n\t\tof an operator with a minus '-'. This helps quickly identify\n\t\tthe first instance of an operator.\n\t-->\n  <xsl:template name=\"SReplaceOperWithMinus\">\n    <xsl:param name=\"sToParse\" select=\"''\" />\n\n    <xsl:value-of select=\"translate($sToParse, $sOperators, $sMinuses)\" />\n  </xsl:template>\n\n  <!-- %%Template SReplaceNumWithZero\n\n\t\tGo through the given string and replace every instance\n\t\tof an number with a zero '0'. This helps quickly identify\n\t\tthe first occurence of a number.\n\n\t\tConsiders the '.' and ',' part of a number iff they are sandwiched\n\t\tbetween two other numbers. 0.3 will be recognized as a number,\n\t\tx.3 will not be. Since these characters can also be an operator, this\n\t\tshould be called before SReplaceOperWithMinus.\n\t-->\n  <xsl:template name=\"SReplaceNumWithZero\">\n    <xsl:param name=\"sToParse\" select=\"''\" />\n\n    <!-- First do a simple replace. Numbers will all be come 0's.\n\t\t\tAfter this point, the pattern involving the . or , that\n\t\t\twe are looking for will become 0.0 or 0,0 -->\n    <xsl:variable name=\"sSimpleReplace\" select=\"translate($sToParse, $sNumbers, $sZeros)\" />\n\n    <!-- And then, replace 0.0 with just 000. This means that the . will\n\t\t\tbecome part of the number -->\n    <xsl:variable name=\"sReplacePeriod\">\n      <xsl:call-template name=\"SReplace\">\n        <xsl:with-param name=\"sInput\" select=\"$sSimpleReplace\" />\n        <xsl:with-param name=\"sOrig\" select=\"'0.0'\" />\n        <xsl:with-param name=\"sReplacement\" select=\"'000'\" />\n      </xsl:call-template>\n    </xsl:variable>\n\n    <!-- And then, replace 0,0 with just 000. This means that the , will\n\t\t\tbecome part of the number -->\n    <xsl:call-template name=\"SReplace\">\n      <xsl:with-param name=\"sInput\" select=\"$sReplacePeriod\" />\n      <xsl:with-param name=\"sOrig\" select=\"'0,0'\" />\n      <xsl:with-param name=\"sReplacement\" select=\"'000'\" />\n    </xsl:call-template>\n  </xsl:template>\n\n  <!-- Template to translate Word's borderBox properties into the menclose notation attribute\n       The initial call to this SHOULD NOT pass an sAttribute.  Subsequent calls to\n       CreateMencloseNotationAttrFromBorderBoxAttr by CreateMencloseNotationAttrFromBorderBoxAttr will\n       update the sAttribute as appropriate.\n\n       CreateMencloseNotationAttrFromBorderBoxAttr looks at each attribute (fHideTop, fHideBot, etc.) one at a time\n       in the order they are listed and passes a modified sAttribute to CreateMencloseNotationAttrFromBorderBoxAttr.\n       Each successive call to CreateMencloseNotationAttrFromBorderBoxAttr knows which attribute to look at because\n       the previous call should have omitted passing the attribute it just analyzed.  This is why as you read lower\n       and lower in the template that each call to CreateMencloseNotationAttrFromBorderBoxAttr has fewer and fewer attributes.\n       -->\n  <xsl:template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n    <xsl:param name=\"fHideTop\" />\n    <xsl:param name=\"fHideBot\" />\n    <xsl:param name=\"fHideLeft\" />\n    <xsl:param name=\"fHideRight\" />\n    <xsl:param name=\"fStrikeH\" />\n    <xsl:param name=\"fStrikeV\" />\n    <xsl:param name=\"fStrikeBLTR\" />\n    <xsl:param name=\"fStrikeTLBR\" />\n    <xsl:param name=\"sAttribute\" />\n\n    <xsl:choose>\n      <xsl:when test=\"string-length($sAttribute) = 0\">\n        <xsl:choose>\n          <xsl:when test=\"string-length($fHideTop) &gt; 0\n                      and string-length($fHideBot) &gt; 0\n                      and string-length($fHideLeft) &gt; 0\n                      and string-length($fHideRight) &gt; 0\">\n\n            <xsl:choose>\n              <xsl:when test=\"$fHideTop = 0\n                              and $fHideBot = 0\n                              and $fHideLeft = 0\n                              and $fHideRight = 0\">\n                <!-- We can use 'box' instead of top, bot, left, and right.  Therefore,\n                  replace sAttribute with 'box' and begin analyzing params fStrikeH\n                  and below. -->\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <xsl:text>box</xsl:text>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <!-- Can't use 'box', theremore, must analyze all attributes -->\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideTop\" select=\"$fHideTop\" />\n                  <xsl:with-param name=\"fHideBot\" select=\"$fHideBot\" />\n                  <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <!-- Assume using all four (left right top bottom).  Subsequent calls\n                         will remove the sides which aren't to be includes. -->\n                    <xsl:text>left right top bottom</xsl:text>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n        </xsl:choose>\n      </xsl:when>\n      <xsl:otherwise>\n        <xsl:choose>\n          <xsl:when test=\"string-length($fHideTop) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fHideTop=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideBot\" select=\"$fHideBot\" />\n                  <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <xsl:call-template name=\"SReplace\">\n                      <xsl:with-param name=\"sInput\" select=\"$sAttribute\" />\n                      <xsl:with-param name=\"sOrig\" select=\"'top'\" />\n                      <xsl:with-param name=\"sReplacement\" select=\"''\" />\n                    </xsl:call-template>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideBot\" select=\"$fHideBot\" />\n                  <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fHideBot) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fHideBot=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <xsl:call-template name=\"SReplace\">\n                      <xsl:with-param name=\"sInput\" select=\"$sAttribute\" />\n                      <xsl:with-param name=\"sOrig\" select=\"'bottom'\" />\n                      <xsl:with-param name=\"sReplacement\" select=\"''\" />\n                    </xsl:call-template>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideLeft\" select=\"$fHideLeft\" />\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fHideLeft) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fHideLeft=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <xsl:call-template name=\"SReplace\">\n                      <xsl:with-param name=\"sInput\" select=\"$sAttribute\" />\n                      <xsl:with-param name=\"sOrig\" select=\"'left'\" />\n                      <xsl:with-param name=\"sReplacement\" select=\"''\" />\n                    </xsl:call-template>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fHideRight\" select=\"$fHideRight\" />\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fHideRight) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fHideRight=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\">\n                    <xsl:call-template name=\"SReplace\">\n                      <xsl:with-param name=\"sInput\" select=\"$sAttribute\" />\n                      <xsl:with-param name=\"sOrig\" select=\"'right'\" />\n                      <xsl:with-param name=\"sReplacement\" select=\"''\" />\n                    </xsl:call-template>\n                  </xsl:with-param>\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeH\" select=\"$fStrikeH\" />\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fStrikeH) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fStrikeH=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"concat($sAttribute, ' horizontalstrike')\" />\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeV\" select=\"$fStrikeV\" />\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fStrikeV) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fStrikeV=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"concat($sAttribute, ' verticalstrike')\" />\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeBLTR\" select=\"$fStrikeBLTR\" />\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fStrikeBLTR) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fStrikeBLTR=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"concat($sAttribute, ' updiagonalstrike')\" />\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"fStrikeTLBR\" select=\"$fStrikeTLBR\" />\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:when test=\"string-length($fStrikeTLBR) &gt; 0\">\n            <xsl:choose>\n              <xsl:when test=\"$fStrikeTLBR=1\">\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"sAttribute\" select=\"concat($sAttribute, ' downdiagonalstrike')\" />\n                </xsl:call-template>\n              </xsl:when>\n              <xsl:otherwise>\n                <xsl:call-template name=\"CreateMencloseNotationAttrFromBorderBoxAttr\">\n                  <xsl:with-param name=\"sAttribute\" select=\"$sAttribute\" />\n                </xsl:call-template>\n              </xsl:otherwise>\n            </xsl:choose>\n          </xsl:when>\n          <xsl:otherwise>\n            <xsl:attribute name=\"notation\">\n              <xsl:value-of select=\"normalize-space($sAttribute)\" />\n            </xsl:attribute>\n          </xsl:otherwise>\n        </xsl:choose>\n      </xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Tristate (true, false, neither) from string value -->\n  <xsl:template name=\"TFromStrVal\">\n    <xsl:param name=\"str\" />\n    <xsl:choose>\n      <xsl:when test=\"$str = 'on' or $str = '1' or $str = 'true'\">1</xsl:when>\n      <xsl:when test=\"$str = 'off' or $str = '0' or $str = 'false'\">0</xsl:when>\n      <xsl:otherwise>-1</xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Return 0 iff $str is explicitly set to a false value.\n       Return true otherwise -->\n  <xsl:template name=\"ForceFalseStrVal\">\n    <xsl:param name=\"str\" />\n    <xsl:variable name=\"tValue\">\n      <xsl:call-template name=\"TFromStrVal\">\n        <xsl:with-param name=\"str\" select=\"$str\"/>\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$tValue = '0'\">0</xsl:when>\n      <xsl:otherwise>1</xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n\n  <!-- Return 1 iff $str is explicitly set to a true value.\n       Return false otherwise -->\n  <xsl:template name=\"ForceTrueStrVal\">\n    <xsl:param name=\"str\" />\n    <xsl:variable name=\"tValue\">\n      <xsl:call-template name=\"TFromStrVal\">\n        <xsl:with-param name=\"str\" select=\"$str\"/>\n      </xsl:call-template>\n    </xsl:variable>\n    <xsl:choose>\n      <xsl:when test=\"$tValue = '1'\">1</xsl:when>\n      <xsl:otherwise>0</xsl:otherwise>\n    </xsl:choose>\n  </xsl:template>\n</xsl:stylesheet>\n".trim());

exports.xsl = xsl;
