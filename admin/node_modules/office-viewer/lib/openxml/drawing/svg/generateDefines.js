'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var arcToA = require('./arcToA.js');

function getVal(name, vars, scale) {
    var result = 0;
    if (name in vars) {
        result = vars[name];
    }
    else {
        result = parseInt(name, 10);
        if (isNaN(result)) {
            console.warn('var not found', name);
            return 0;
        }
    }
    if (scale) {
        return result * scale;
    }
    else {
        return result;
    }
}
/**
 *
 * 转成 svg path 里的定义
 * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
 */
function generateDefines(path, vars, prevPoint) {
    var e_1, _a;
    var defines = path.defines;
    var paths = [];
    var w = path.w;
    var h = path.h;
    var wScale = 1;
    var hScale = 1;
    if (w) {
        wScale = vars['w'] / w;
    }
    if (h) {
        hScale = vars['h'] / h;
    }
    try {
        for (var defines_1 = tslib.__values(defines), defines_1_1 = defines_1.next(); !defines_1_1.done; defines_1_1 = defines_1.next()) {
            var def = defines_1_1.value;
            switch (def.type) {
                case 'moveTo': {
                    var pt = def.pt;
                    var x = getVal(pt.x, vars, wScale);
                    var y = getVal(pt.y, vars, hScale);
                    paths.push("M ".concat(x, " ").concat(y));
                    prevPoint.push({ x: x, y: y });
                    break;
                }
                case 'lnTo': {
                    var pt = def.pt;
                    var x = getVal(pt.x, vars, wScale);
                    var y = getVal(pt.y, vars, hScale);
                    paths.push("L ".concat(x, " ").concat(y));
                    prevPoint.push({ x: x, y: y });
                    break;
                }
                case 'arcTo': {
                    var arc = def;
                    var wR = getVal(arc.wR, vars, wScale);
                    var hR = getVal(arc.hR, vars, hScale);
                    var stAng = getVal(arc.stAng, vars);
                    var swAng = getVal(arc.swAng, vars);
                    var prev = {
                        x: 0,
                        y: 0
                    };
                    if (prevPoint.length > 0) {
                        prev = prevPoint[prevPoint.length - 1];
                    }
                    var aPath = arcToA["default"](wR, hR, stAng, swAng, prev.x, prev.y);
                    paths.push(aPath.path);
                    prevPoint.push({ x: aPath.end.x, y: aPath.end.y });
                    break;
                }
                case 'quadBezTo': {
                    var quadBezTo = def;
                    if (quadBezTo.pts.length >= 2) {
                        var pt1 = quadBezTo.pts[0];
                        var pt2 = quadBezTo.pts[1];
                        var x1 = getVal(pt1.x, vars, wScale);
                        var y1 = getVal(pt1.y, vars, hScale);
                        var x2 = getVal(pt2.x, vars, wScale);
                        var y2 = getVal(pt2.y, vars, hScale);
                        paths.push("Q ".concat(x1, ",").concat(y1, " ").concat(x2, ",").concat(y2));
                        if (quadBezTo.pts.length > 2) {
                            var pt3 = quadBezTo.pts[2];
                            var x3 = getVal(pt3.x, vars, wScale);
                            var y3 = getVal(pt3.y, vars, hScale);
                            paths.push("T ".concat(x3, ",").concat(y3));
                            prevPoint.push({ x: x3, y: y3 });
                        }
                        else {
                            prevPoint.push({ x: x2, y: y2 });
                        }
                    }
                    else {
                        console.warn('quadBezTo pts length must large than 2', def);
                    }
                    break;
                }
                case 'cubicBezTo': {
                    var cubicBezTo = def;
                    if (cubicBezTo.pts.length === 3) {
                        var pt1 = cubicBezTo.pts[0];
                        var pt2 = cubicBezTo.pts[1];
                        var pt3 = cubicBezTo.pts[2];
                        var x1 = getVal(pt1.x, vars, wScale);
                        var y1 = getVal(pt1.y, vars, hScale);
                        var x2 = getVal(pt2.x, vars, wScale);
                        var y2 = getVal(pt2.y, vars, hScale);
                        var x3 = getVal(pt3.x, vars, wScale);
                        var y3 = getVal(pt3.y, vars, hScale);
                        paths.push("C ".concat(x1, ",").concat(y1, " ").concat(x2, ",").concat(y2, " ").concat(x3, ",").concat(y3));
                        prevPoint.push({ x: x3, y: y3 });
                    }
                    else {
                        console.warn('cubicBezTo pts length must be 3', def);
                    }
                    break;
                }
                case 'close':
                    paths.push('Z');
                    break;
                default:
                    break;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (defines_1_1 && !defines_1_1.done && (_a = defines_1.return)) _a.call(defines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return paths.join(' ');
}

exports.generateDefines = generateDefines;
