'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var Attributes = require('../openxml/Attributes.js');
var OpenXML = require('../OpenXML.js');

var replaceCache = new Map();
/**
 * 目前不支持这两种 name space
 */
function removeNamespace(tag) {
    if (replaceCache.has(tag)) {
        return replaceCache.get(tag);
    }
    var result = tag.replace('a:', '').replace('xdr:', '').replace('c:', '');
    replaceCache.set(tag, result);
    return result;
}
/**
 * 通用属性解析
 * @param node xml 节点
 * @param attributes 属性定义
 * @param fillDefault 是否补上默认值
 */
function autoParse(node, attributes, fillDefault) {
    if (fillDefault === void 0) { fillDefault = false; }
    var result = {};
    var attrs = (node === null || node === void 0 ? void 0 : node.attrs) || {};
    for (var key in attrs) {
        var resultKey = removeNamespace(key);
        if (resultKey in attributes) {
            var attribute = attributes[resultKey];
            var value = attrs[key];
            if (attribute.type === 'int') {
                result[resultKey] = parseInt(value, 10);
            }
            else if (attribute.type === 'double') {
                result[resultKey] = parseFloat(value);
            }
            else if (attribute.type === 'boolean') {
                result[resultKey] = OpenXML.normalizeBoolean(value, attribute.defaultValue);
            }
            else if (attribute.type === 'string') {
                result[resultKey] = value;
            }
        }
        else {
            result[resultKey] = attrs[key];
            if (key.startsWith('xmlns') || key.startsWith('mc:Ignorable')) {
                continue;
            }
            // xr: 先不处理
            if (result[resultKey] === undefined &&
                !(key.startsWith('xr:') ||
                    key === 'xr3:uid' ||
                    key === 'xr2:uid' ||
                    key === 'x14ac:dyDescent')) {
                console.log("parseAttributes: ".concat(node === null || node === void 0 ? void 0 : node.tag, "'s attribute: ").concat(key, " is not supported"));
            }
        }
    }
    // 补上默认值
    if (fillDefault) {
        for (var key in attributes) {
            var attribute = attributes[key];
            if (attribute.defaultValue !== undefined && result[key] === undefined) {
                result[key] = attribute.defaultValue;
            }
        }
    }
    var _loop_1 = function (attributeKey) {
        var e_1, _a, e_2, _b, e_3, _c;
        var attribute = attributes[attributeKey];
        if (attribute.type === 'child') {
            try {
                for (var _d = (e_1 = void 0, tslib.__values((node === null || node === void 0 ? void 0 : node.children) || [])), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var child = _e.value;
                    var tag = removeNamespace(child.tag);
                    if (tag === attributeKey) {
                        var childElement = autoParse(child, attribute.childAttributes);
                        if (attribute.childIsArray) {
                            if (Array.isArray(result[attributeKey])) {
                                result[attributeKey].push(childElement);
                            }
                            else {
                                result[attributeKey] = [childElement];
                            }
                        }
                        else {
                            result[attributeKey] = childElement;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else if (attribute.childIsArray) {
            // 这种情况是用子节点当成数组，比如 CT_CfRule 里的 formula
            var type_1 = attribute.type;
            if (type_1 === 'string' ||
                type_1 === 'int' ||
                type_1 === 'double' ||
                type_1 === 'boolean' ||
                type_1 === 'child-string' ||
                type_1 === 'child-int') {
                var childArray = (node === null || node === void 0 ? void 0 : node.children) || [];
                var resultArray = childArray
                    .map(function (child) {
                    var tag = removeNamespace(child.tag);
                    var text = child.text || '';
                    if (type_1 === 'int') {
                        return parseInt(text, 10);
                    }
                    if (type_1 === 'double') {
                        return parseFloat(text);
                    }
                    if (type_1 === 'boolean') {
                        return OpenXML.normalizeBoolean(text, false);
                    }
                    if (type_1 === 'child-string') {
                        if (tag === attributeKey) {
                            return text;
                        }
                        else {
                            return undefined;
                        }
                    }
                    if (type_1 === 'child-int') {
                        if (tag === attributeKey) {
                            return parseInt(text, 10);
                        }
                        else {
                            return undefined;
                        }
                    }
                    return text;
                })
                    .filter(function (element) {
                    return element !== undefined;
                });
                result[attributeKey] = resultArray;
            }
            else {
                console.log('unsupported attribute array type', type_1);
            }
        }
        else if (attribute.type === 'child-string') {
            try {
                for (var _f = (e_2 = void 0, tslib.__values((node === null || node === void 0 ? void 0 : node.children) || [])), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var child = _g.value;
                    var tag = removeNamespace(child.tag);
                    if (tag === attributeKey) {
                        result[tag] = child.text;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        else if (attribute.type === 'child-int') {
            try {
                for (var _h = (e_3 = void 0, tslib.__values((node === null || node === void 0 ? void 0 : node.children) || [])), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var child = _j.value;
                    var tag = removeNamespace(child.tag);
                    if (tag === attributeKey) {
                        result[tag] = parseInt(child.text || '0', 10);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else if (attribute.type === 'any') {
            result[Attributes.ANY_KEY] = (node === null || node === void 0 ? void 0 : node.children) || [];
        }
    };
    // 自定义类型
    for (var attributeKey in attributes) {
        _loop_1(attributeKey);
    }
    return result;
}

exports.autoParse = autoParse;
