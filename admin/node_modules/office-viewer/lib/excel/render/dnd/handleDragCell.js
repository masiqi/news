'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var objectEqual = require('../../../util/objectEqual.js');
var Range = require('../../io/excel/util/Range.js');
var cellToMergeCell = require('../cell/cellToMergeCell.js');
var handleMousedown = require('./handleMousedown.js');

/**
 * 判断某个单元格是否在合并单元格内，如果在就扩展选区
 */
function mergeWithNewCell(range, mergeCells, row, col) {
    var mergeCell = cellToMergeCell.cellToMergeCell(row, col, mergeCells);
    return Range.mergeRange(range, mergeCell);
}
/**
 * 判断边缘是否接触到了合并单元格，如果接触到了就扩展选区
 */
function mergeWithAllBorder(range, mergeCells) {
    var newRange = tslib.__assign({}, range);
    // 上边
    for (var i = newRange.startCol; i <= newRange.endCol; i++) {
        newRange = mergeWithNewCell(newRange, mergeCells, newRange.startRow, i);
    }
    // 下边
    for (var i = newRange.startCol; i <= newRange.endCol; i++) {
        newRange = mergeWithNewCell(newRange, mergeCells, newRange.endRow, i);
    }
    // 左边
    for (var i = newRange.startRow; i <= newRange.endRow; i++) {
        newRange = mergeWithNewCell(newRange, mergeCells, i, newRange.startCol);
    }
    // 右边
    for (var i = newRange.startRow; i <= newRange.endRow; i++) {
        newRange = mergeWithNewCell(newRange, mergeCells, i, newRange.endCol);
    }
    // 如果选区变化就需要遍历再执行一次，因为扩展选区后可能又触碰到了另一个合并单元格
    if (!objectEqual.objectEqual(newRange, range)) {
        return mergeWithAllBorder(newRange, mergeCells);
    }
    return newRange;
}
/**
 * 处理拖拽单元格扩展选区
 */
function handleDragCell(offsetX, offsetY) {
    var _a, _b, _c;
    // 没有 selection 的情况不大可能，但避免出错
    if (!handleMousedown.dragState.selection) {
        console.warn('没有 selection');
        return;
    }
    if (handleMousedown.dragState.selection.cellRanges.length === 0) {
        console.warn('没有 cellRanges');
        return;
    }
    // 后续要支持多选得改这里
    var firstCellRange = handleMousedown.dragState.selection.cellRanges[0];
    // 如果超出当前单元格，需要做 hitTest，判断是否在其他单元格内
    var hitTestResult = (_a = handleMousedown.dragState.workbook) === null || _a === void 0 ? void 0 : _a.getActiveSheet().hitTest(offsetX, offsetY);
    // 目前只支持在相同类型的单元格内拖拽
    if (hitTestResult && hitTestResult.type === handleMousedown.dragState.dragType) {
        var mergeCells = ((_b = handleMousedown.dragState.workbook) === null || _b === void 0 ? void 0 : _b.getActiveSheet().getMergeCells()) || [];
        // 如果在选区范围内
        var newRange = Range.mergeRange(handleMousedown.dragState.selection.activeCell, hitTestResult);
        if (mergeCells.length) {
            // 选区扩展过程中可能某个边触碰到另一个合并单元格了，需要遍历四个边来判断
            newRange = mergeWithAllBorder(newRange, mergeCells);
        }
        if (!objectEqual.objectEqual(newRange, firstCellRange)) {
            Object.assign(firstCellRange, newRange);
            (_c = handleMousedown.dragState.workbook) === null || _c === void 0 ? void 0 : _c.uiEvent.emit('CHANGE_SELECTION', handleMousedown.dragState.selection);
        }
    }
}

exports.handleDragCell = handleDragCell;
