'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var drawOffscreenCanvas = require('./canvas/drawOffscreenCanvas.js');
var setPixelRatio = require('./canvas/setPixelRatio.js');

/**
 * Canvas 的简单封装，方便绘制图形
 */
var Canvas = /** @class */ (function () {
    function Canvas(width, height, zoom, className) {
        this.widgets = new Map();
        /**
         * 缩放比例
         */
        this.zoom = 1;
        this.ratio = 1;
        this.lastTarget = null;
        this.imageCache = new Map();
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = width;
        this.height = height;
        this.ratio = setPixelRatio.setPixelRatio(this.canvas, width, height);
        this.canvas.className = className;
        this.zoom = zoom;
        this.setZoom();
        this.canvas.addEventListener('mousemove', this.handleMousemove.bind(this));
    }
    Canvas.prototype.setZoom = function () {
        var zoom = this.zoom;
        if (zoom && zoom !== 1) {
            this.ctx.scale(zoom, zoom);
        }
    };
    Canvas.prototype.renderWidget = function (widget) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var ratio, _a, x, y, imageData;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        ratio = this.ratio * this.zoom;
                        _a = widget.getClientBounding(), x = _a.x, y = _a.y, _a.width, _a.height;
                        return [4 /*yield*/, widget.draw()];
                    case 1:
                        imageData = _b.sent();
                        this.ctx.putImageData(imageData, x * ratio, y * ratio);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 鼠标移动的时候判断是否在某个 widget 上
     */
    Canvas.prototype.handleMousemove = function (event) {
        var e_1, _a;
        var offsetX = event.offsetX, offsetY = event.offsetY;
        offsetX = offsetX / this.zoom;
        offsetY = offsetY / this.zoom;
        try {
            for (var _b = tslib.__values(this.widgets.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var widget = _c.value;
                if (widget.isPointInWidget(offsetX, offsetY)) {
                    if (this.lastTarget && this.lastTarget !== widget) {
                        this.lastTarget.onMouseout();
                    }
                    else {
                        this.lastTarget = widget;
                        widget.onMouseover();
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Canvas.prototype.updateCursor = function (cursor) {
        this.canvas.style.cursor = cursor;
    };
    Canvas.prototype.hasWidget = function (key) {
        return this.widgets.has(key);
    };
    Canvas.prototype.addWidget = function (key, widget) {
        this.widgets.set(key, widget);
        this.renderWidget(widget);
    };
    Canvas.prototype.getRealRatio = function () {
        return this.ratio * this.zoom;
    };
    Canvas.prototype.getCanvasElement = function () {
        return this.canvas;
    };
    Canvas.prototype.getContext = function () {
        return this.ctx;
    };
    Canvas.prototype.updateZoom = function (zoom) {
        this.zoom = zoom;
        this.ctx.resetTransform();
        this.ctx.scale(this.ratio * zoom, this.ratio * zoom);
        this.clearCache();
    };
    /**
     * 清空画布
     */
    Canvas.prototype.clear = function (width, height) {
        var ctx = this.ctx;
        ctx.clearRect(0, 0, (width || this.width) / this.zoom, (height || this.height) / this.zoom);
    };
    Canvas.prototype.clearRect = function (x, y, width, height) {
        var ctx = this.ctx;
        ctx.clearRect(x, y, width, height);
    };
    Canvas.prototype.clearRectPadding = function (x, y, width, height, padding) {
        this.clearRect(x + padding, y + padding, width - padding * 2, height - padding * 2);
    };
    /**
     * 绘制线条
     * @param line 线条配置
     * @param color
     * @param width
     */
    Canvas.prototype.drawLine = function (line, color, width) {
        if (width === void 0) { width = 1; }
        var ctx = this.ctx;
        ctx.beginPath();
        ctx.moveTo(line.x1, line.y1);
        ctx.lineTo(line.x2, line.y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    };
    Canvas.prototype.setLineDash = function (line, segments, color, width) {
        if (width === void 0) { width = 1; }
        var ctx = this.ctx;
        ctx.beginPath();
        ctx.moveTo(line.x1, line.y1);
        ctx.lineTo(line.x2, line.y2);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.setLineDash(segments);
        ctx.stroke();
        ctx.setLineDash([]);
    };
    /**
     * 绘制多个线条
     * @param line 多个线条配置
     * @param width
     * @param height
     * @param color
     */
    Canvas.prototype.drawLines = function (lines, color, width) {
        if (width === void 0) { width = 1; }
        var ctx = this.ctx;
        ctx.beginPath();
        lines.forEach(function (line) {
            ctx.moveTo(line.x1, line.y1);
            ctx.lineTo(line.x2, line.y2);
        });
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    };
    /**
     * 绘制字体
     * @param font
     * @param color
     * @param text
     * @param x
     * @param y
     * @param textBaseline
     */
    Canvas.prototype.drawText = function (font, color, text, x, y, textBaseline) {
        if (color === void 0) { color = '#000'; }
        if (textBaseline === void 0) { textBaseline = 'middle'; }
        var ctx = this.ctx;
        ctx.font = font;
        ctx.fillStyle = color;
        ctx.textBaseline = textBaseline;
        ctx.fillText(text, x, y);
    };
    /**
     * 绘制矩形
     */
    Canvas.prototype.drawRect = function (x, y, width, height, color) {
        var ctx = this.ctx;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, width, height);
    };
    /**
     * 绘制带 padding 的矩形
     */
    Canvas.prototype.drawRectWithPadding = function (x, y, width, height, color, padding) {
        var ctx = this.ctx;
        ctx.fillStyle = color;
        ctx.fillRect(x + padding, y + padding, width - padding * 2, height - padding * 2);
    };
    Canvas.prototype.drawRectLinearGradientWithPadding = function (x, y, width, height, color, colorEnd, padding) {
        var displayWidth = Math.max(1, width - padding * 2);
        var ctx = this.ctx;
        // gradient 坐标是全局的
        var grd = ctx.createLinearGradient(x + padding, y + padding, x + padding + displayWidth, y + padding);
        grd.addColorStop(0, color);
        grd.addColorStop(1, colorEnd);
        ctx.fillStyle = grd;
        ctx.fillRect(x + padding, y + padding, displayWidth, height - padding * 2);
    };
    /**
     * 绘制带透明度的矩形
     */
    Canvas.prototype.drawAlphaRect = function (x, y, width, height, color, alpha) {
        var ctx = this.ctx;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.fillRect(x, y, width, height);
        ctx.globalAlpha = 1;
    };
    /**
     * 绘制带透明度的矩形，加 padding
     */
    Canvas.prototype.drawAlphaRectPadding = function (x, y, width, height, padding, color, alpha) {
        return this.drawAlphaRect(x + padding, y + padding, width - padding * 2, height - padding * 2, color, alpha);
    };
    /**
     * 绘制矩形边框
     */
    Canvas.prototype.drawStrokeRect = function (x, y, width, height, color, lineWidth) {
        if (lineWidth === void 0) { lineWidth = 1; }
        var ctx = this.ctx;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.strokeRect(x, y, width, height);
    };
    /**
     * 绘制带 padding 的矩形边框
     */
    Canvas.prototype.drawStrokeRectPadding = function (x, y, width, height, color, lineWidth, padding) {
        if (lineWidth === void 0) { lineWidth = 1; }
        if (padding === void 0) { padding = 1; }
        this.drawStrokeRect(x + padding, y + padding, width - padding * 2, height - padding * 2, color, lineWidth);
    };
    Canvas.prototype.drawImage = function (url, x, y, width, height) {
        var _this = this;
        var img = new Image();
        img.src = url;
        img.onload = function () {
            _this.ctx.drawImage(img, x, y, width, height);
        };
    };
    /**
     * 绘制图片，并使用缓存
     * @param url
     * @param x
     * @param y
     * @param width
     * @param height
     */
    Canvas.prototype.drawImageWithCache = function (url, x, y, width, height) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var ratio = _this.ratio * _this.zoom;
                        var cacheKey = "".concat(url, "-").concat(width, "-").concat(height);
                        // 根据 mdn 文档，最好是整数
                        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#avoid_floating-point_coordinates_and_use_integers_instead
                        width = Math.floor(width);
                        height = Math.floor(height);
                        // 避免报错
                        if (width === 0 || height === 0) {
                            resolve();
                            return;
                        }
                        var cache = _this.imageCache.get(cacheKey);
                        if (cache) {
                            _this.ctx.drawImage(cache, x, y, width, height);
                            resolve();
                            return;
                        }
                        var img = new Image();
                        img.src = url;
                        img.onload = function () {
                            var imageBitmap = drawOffscreenCanvas.drawOffscreenCanvas(ratio, width, height, function (ctx) {
                                ctx.drawImage(img, 0, 0, width, height);
                            });
                            _this.ctx.drawImage(imageBitmap, x, y, width, height);
                            _this.imageCache.set(cacheKey, imageBitmap);
                            resolve();
                        };
                        img.onerror = reject;
                    })];
            });
        });
    };
    /**
     * 运行绘制并缓存
     */
    Canvas.prototype.customDrawWithCache = function (cacheKey, x, y, width, height, func) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var ratio = _this.ratio * _this.zoom;
                        var cache = _this.imageCache.get(cacheKey);
                        if (cache) {
                            _this.ctx.drawImage(cache, x, y, width, height);
                            resolve();
                            return;
                        }
                        var imageBitmap = drawOffscreenCanvas.drawOffscreenCanvas(ratio, width, height, function (ctx) {
                            func(ctx, ratio);
                        });
                        _this.ctx.drawImage(imageBitmap, x, y, width, height);
                        _this.imageCache.set(cacheKey, imageBitmap);
                        resolve();
                    })];
            });
        });
    };
    /**
     * 清空缓存
     */
    Canvas.prototype.clearCache = function () {
        this.imageCache.clear();
    };
    return Canvas;
}());

exports.Canvas = Canvas;
