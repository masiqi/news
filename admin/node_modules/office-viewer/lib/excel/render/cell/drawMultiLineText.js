'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var isValidURL = require('../../../util/isValidURL.js');
var genFontStr = require('./genFontStr.js');

var debugFontBoundingBox = false;
function drawMultiLineText(excelRender, sheet, ctx, dataProvider, fontStyle, lines, x, y, width, height, padding, horizontal, vertical, text, row, linkPositionCache) {
    var e_1, _a, e_2, _b;
    if (linkPositionCache === void 0) { linkPositionCache = []; }
    // 这样才能让不同字体大小的文字垂直对齐
    ctx.textBaseline = 'alphabetic';
    var defaultFontHeight = dataProvider.getDefaultFontSize().height;
    var textPositions = [];
    var totalLineHeight = lines.reduce(function (acc, line) {
        return acc + (line.maxHeight || defaultFontHeight);
    }, 0);
    // 起始 Y 坐标，默认按垂直居中显示
    var currentY = y + (height - totalLineHeight) / 2;
    if (vertical === 'bottom') {
        currentY = y + height - totalLineHeight;
    }
    else if (vertical === 'top') {
        currentY = y;
    }
    // 计算文本高度
    var textHeight = 0;
    // 行数
    var lineNumber = 0;
    try {
        for (var lines_1 = tslib.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            lineNumber++;
            var tokens = line.tokens;
            // 默认按左对齐
            var currentX = x;
            var totalLineWidth = tokens.reduce(function (acc, token) {
                return acc + (token.w || 0);
            }, 0);
            if (horizontal === 'center') {
                currentX = x + (width - totalLineWidth) / 2;
            }
            else if (horizontal === 'right') {
                currentX = x + width - totalLineWidth;
            }
            try {
                for (var tokens_1 = (e_2 = void 0, tslib.__values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                    var token = tokens_1_1.value;
                    var font = genFontStr.genFontStr(fontStyle);
                    ctx.font = font;
                    ctx.fillStyle = fontStyle.color;
                    if (token.rPr && Object.keys(token.rPr).length > 0) {
                        var font_1 = genFontStr.genFontStrFromRPr(token.rPr, fontStyle);
                        ctx.font = font_1;
                        if (token.rPr.color) {
                            ctx.fillStyle = dataProvider.getColor(token.rPr.color);
                        }
                    }
                    var fontHeight = line.maxHeight || defaultFontHeight;
                    if (debugFontBoundingBox) ;
                    ctx.fillText(token.t, currentX, currentY + fontHeight);
                    textPositions.push({
                        x: currentX,
                        y: currentY,
                        width: token.w || 0,
                        height: fontHeight
                    });
                    // 这里其实不大可能为零
                    currentX = currentX + (token.w || 0);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return)) _b.call(tokens_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var lineHeight = line.maxHeight || defaultFontHeight;
            textHeight += lineHeight;
            currentY = currentY + lineHeight;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // 当文本高度大于单元格高度时，需要重新渲染，目前这个计算还不知道是否合理
    // 阀值，这个主要是为了避免计算差异导致无限重新渲染
    var threadHold = 4;
    if (Math.floor(totalLineHeight - threadHold) > height + padding * 2) {
        sheet.setRowHeight(row, totalLineHeight + padding * 2);
        excelRender.setNeedReDraw();
    }
    if (isValidURL.isValidURL(text)) {
        linkPositionCache.push({
            url: text,
            pos: textPositions
        });
    }
}

exports.drawMultiLineText = drawMultiLineText;
