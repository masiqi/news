'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var ScrollBar = require('./ScrollBar.js');
var SheetCanvas = require('./SheetCanvas.js');
var drawGridLines = require('./grid/drawGridLines.js');
var drawCells = require('./cell/drawCells.js');
var drawRowColHeaders = require('./header/drawRowColHeaders.js');
var debounce = require('../../util/debounce.js');
var drawFrozen = require('./cell/frozen/drawFrozen.js');
var SelectionCanvas = require('./SelectionCanvas.js');
var updateCursor = require('./selection/updateCursor.js');
var handleMousedown = require('./dnd/handleMousedown.js');
var drawDrawing = require('./drawing/drawDrawing.js');
var drawSparkline = require('./sparkline/drawSparkline.js');
var isPointerOnLink = require('./cell/isPointerOnLink.js');
var ResizeBox = require('./drawing/ResizeBox.js');
var renderAutoFilter = require('./autoFilter/renderAutoFilter.js');
var getMouseRelativePosition = require('./dnd/getMouseRelativePosition.js');
var CellEditor = require('../edit/ui/CellEditor.js');
var checkFont = require('./cell/checkFont.js');
var measureTextWithCache = require('./cell/measureTextWithCache.js');

/**
 * 实现 Excel 渲染
 */
var ExcelRender = /** @class */ (function () {
    function ExcelRender(contentContainer, dataContainer, workbook, dataProvider, renderOptions) {
        var _this = this;
        /**
         * 上一次滚动的位置，这个是为了滚动时固定某个方向
         */
        this.lastScroll = { left: 0, top: 0 };
        this.linkPositionCache = [];
        this.autoFiltersUI = [];
        this.lastScrollDirection = 'vertical';
        this.lastScrollDirectionTime = 0;
        this.scrollDirectionLockTime = 100;
        /**
         * 是否需要重新绘制，主要是渲染过程中发现行高变化等情况
         */
        this.needReDraw = false;
        /**
         * 已经加载的字体
         */
        this.loadedFont = new Set();
        this.contentContainer = contentContainer;
        this.dataContainer = dataContainer;
        this.workbook = workbook;
        this.renderOptions = renderOptions;
        this.contentContainer.addEventListener('wheel', this.handleWheel.bind(this), {
            passive: false
        });
        this.contentContainer.addEventListener('mousedown', this.handleMousedown.bind(this));
        this.contentContainer.addEventListener('mouseup', this.handleMouseup.bind(this));
        this.contentContainer.addEventListener('touchstart', this.handleMousedown.bind(this));
        // 避免过于频繁
        this.handleMousemove = debounce.debounce(this.handleMousemove, 16);
        this.contentContainer.addEventListener('mousemove', this.handleMousemove.bind(this));
        this.dataContainer.addEventListener('dblclick', this.handleDblclick.bind(this));
        this.sheetCanvas = new SheetCanvas.SheetCanvas(workbook, dataProvider);
        var sheetCanvasElement = this.sheetCanvas.getCanvasElement();
        this.contentContainer.appendChild(sheetCanvasElement);
        this.selectionCanvas = new SelectionCanvas.SelectionCanvas(workbook, dataProvider);
        this.contentContainer.appendChild(this.selectionCanvas.getCanvasElement());
        this.scrollbar = new ScrollBar.ScrollBar(contentContainer, workbook);
        this.resizeBox = new ResizeBox.ResizeBox(contentContainer);
        this.defaultFontSize = dataProvider.getDefaultFontSize();
        this.dataProvider = dataProvider;
        this.draw = this.draw.bind(this);
        workbook.uiEvent.on('SWITCH_SHEET', function (sheet) {
            // 这里面会有一些 HTML，清空一下避免问题
            _this.dataContainer.innerHTML = '';
            _this.draw();
        });
        workbook.uiEvent.on('CHANGE_ZOOM_LEVEL', function (scale) {
            _this.sheetCanvas.updateZoom(scale);
            _this.selectionCanvas.updateZoom(scale);
            _this.draw();
            _this.selectionCanvas.draw();
        });
        workbook.uiEvent.on('SCROLL_X', function (x) {
            _this.workbook.getActiveSheet().setScrollLeft(x);
            _this.draw();
        });
        workbook.uiEvent.on('SCROLL_Y', function (y) {
            _this.workbook.getActiveSheet().setScrollTop(y);
            _this.draw();
        });
        workbook.uiEvent.on('APPLY_AUTO_FILTER', function (sheetIndex) {
            var currentSheetIndex = _this.workbook.getActiveSheet().getIndex();
            if (currentSheetIndex === sheetIndex) {
                _this.draw();
            }
        });
        workbook.uiEvent.on('UPDATE_RANGE', function (sheetIndex) {
            // 目前简单处理，后面需要支持局部渲染
            var currentSheetIndex = _this.workbook.getActiveSheet().getIndex();
            if (currentSheetIndex === sheetIndex) {
                _this.draw();
            }
        });
        workbook.uiEvent.on('UPDATE_ROW_HEIGHT', function (row, height) {
            _this.draw();
        });
        workbook.uiEvent.on('UPDATE_COL_WIDTH', function (col, width) {
            _this.draw();
        });
        this.watchResize();
    }
    ExcelRender.prototype.getSelectionCanvas = function () {
        return this.selectionCanvas;
    };
    ExcelRender.prototype.watchResize = function () {
        var _this = this;
        var contentContainer = this.contentContainer;
        // 监听容器大小变化
        var lastWidth = contentContainer.clientWidth;
        var lastHeight = contentContainer.clientHeight;
        var containerObserver = new ResizeObserver(function (entries) {
            var entry = entries[0];
            var _a = entry.contentRect, width = _a.width, height = _a.height;
            if (Math.floor(lastWidth) === Math.floor(width) &&
                Math.floor(lastHeight) === Math.floor(height)) {
                return;
            }
            lastWidth = width;
            lastHeight = height;
            _this.draw();
        });
        containerObserver.observe(contentContainer);
    };
    /**
     * 处理滚轮事件
     */
    ExcelRender.prototype.handleWheel = function (event) {
        var deltaX = event.deltaX, deltaY = event.deltaY; event.deltaMode;
        var currentSheet = this.workbook.getActiveSheet();
        // 按住 shift 键就当成水平滚动
        var isScrollingHorizontally = event.shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
        event.preventDefault();
        event.stopPropagation();
        if (this.ignoreScrollDirection(isScrollingHorizontally)) {
            return false;
        }
        deltaX = Math.floor(deltaX);
        deltaY = Math.floor(deltaY);
        // 按住 shift 就只有水平滚动
        if (isScrollingHorizontally) {
            currentSheet.deltaScrollLeft(deltaX);
        }
        else {
            currentSheet.deltaScrollTop(deltaY);
        }
        var scroll = {
            left: Math.floor(currentSheet.getScrollLeft()),
            top: Math.floor(currentSheet.getScrollTop())
        };
        if (this.lastScroll.left !== scroll.left ||
            this.lastScroll.top !== scroll.top) {
            this.lastScroll = scroll;
            this.draw();
            // 滚动结束后触发
            this.afterScroll(scroll);
        }
        return false;
    };
    /**
     * 处理单元格双击事件
     */
    ExcelRender.prototype.handleDblclick = function (event) {
        if (this.renderOptions.editable === false) {
            return;
        }
        var _a = this.getMouseRelativePosition(event), offsetX = _a.offsetX, offsetY = _a.offsetY;
        var hitTestResult = this.workbook
            .getActiveSheet()
            .hitTest(offsetX, offsetY);
        if (hitTestResult && hitTestResult.type === 'cell') {
            new CellEditor.CellEditor(this.dataContainer, this.workbook, hitTestResult);
        }
    };
    /**
     * 处理鼠标按下事件
     */
    ExcelRender.prototype.handleMousedown = function (event) {
        var _a = this.getMouseRelativePosition(event), offsetX = _a.offsetX, offsetY = _a.offsetY;
        var hitTestResult = this.workbook
            .getActiveSheet()
            .hitTest(offsetX, offsetY);
        if (hitTestResult) {
            handleMousedown.handleMousedown(this.workbook, hitTestResult, this.contentContainer, event);
        }
    };
    /**
     * 处理鼠标松开事件，目前主要是处理点击链接的场景
     */
    ExcelRender.prototype.handleMouseup = function (event) {
        // 拖动过程中就不处理这个事件
        if (handleMousedown.dragState.isDragging) {
            return;
        }
        var _a = this.getMouseRelativePosition(event), offsetX = _a.offsetX, offsetY = _a.offsetY;
        var pointerOnLink = isPointerOnLink.isPointerOnLink(offsetX, offsetY, this.linkPositionCache);
        if (pointerOnLink) {
            window.open(pointerOnLink);
        }
        var hitTestResult = this.workbook
            .getActiveSheet()
            .hitTest(offsetX, offsetY);
        this.resizeBox.hide();
        if (hitTestResult) {
            if (hitTestResult.type === 'drawing') {
                this.selectionCanvas.clearSelection();
                this.resizeBox.updatePosition(hitTestResult.x, hitTestResult.y, hitTestResult.width, hitTestResult.height);
            }
        }
    };
    /**
     * 处理鼠标移动事件
     */
    ExcelRender.prototype.handleMousemove = function (event) {
        var _a, _b;
        // 拖动过程中就不处理这个事件
        if (handleMousedown.dragState.isDragging) {
            return;
        }
        var _c = this.getMouseRelativePosition(event), offsetX = _c.offsetX, offsetY = _c.offsetY;
        offsetX = Math.round(offsetX);
        offsetY = Math.round(offsetY);
        // 重置鼠标样式
        this.contentContainer.style.cursor = 'cell';
        var hitTestResult = this.workbook
            .getActiveSheet()
            .hitTest(offsetX, offsetY);
        // 用于快速了解当前鼠标位置
        if (this.renderOptions.debug) {
            (_b = (_a = this.renderOptions).mousePositionTracker) === null || _b === void 0 ? void 0 : _b.call(_a, offsetX, offsetY, hitTestResult);
        }
        // 是否在链接上
        var pointerOnLink = isPointerOnLink.isPointerOnLink(offsetX, offsetY, this.linkPositionCache);
        updateCursor.updateCursor(this.contentContainer, hitTestResult, pointerOnLink);
    };
    /**
     * 获取鼠标相对位置，会考虑缩放
     */
    ExcelRender.prototype.getMouseRelativePosition = function (event) {
        var _a = getMouseRelativePosition.getMouseRelativePosition(this.contentContainer, event), offsetX = _a.offsetX, offsetY = _a.offsetY;
        var zoomLevel = this.workbook.getActiveSheet().getZoomLevel();
        offsetX = offsetX / zoomLevel;
        offsetY = offsetY / zoomLevel;
        return { offsetX: offsetX, offsetY: offsetY };
    };
    /**
     * 是否忽略这个滚动方向
     * @param isScrollingHorizontally
     * @returns 如果返回 true 说明被锁定了，这时要忽略后面的行为
     */
    ExcelRender.prototype.ignoreScrollDirection = function (isScrollingHorizontally) {
        // 避免滚动方向频繁切换，在短时间内只允许一个方向
        if (Date.now() - this.lastScrollDirectionTime <
            this.scrollDirectionLockTime) {
            if (this.lastScrollDirection === 'horizontal' &&
                !isScrollingHorizontally) {
                return true;
            }
            if (this.lastScrollDirection === 'vertical' && isScrollingHorizontally) {
                return true;
            }
        }
        this.lastScrollDirection = isScrollingHorizontally
            ? 'horizontal'
            : 'vertical';
        this.lastScrollDirectionTime = Date.now();
        return false;
    };
    ExcelRender.prototype.afterScroll = function (scroll) {
        this.workbook.uiEvent.emit('AFTER_SCROLL', scroll);
    };
    /**
     * 获取可视区域高宽
     */
    ExcelRender.prototype.getWidthAndHeight = function () {
        var _a = this.workbook.getViewpointSize(), width = _a.width, height = _a.height;
        return {
            width: width,
            height: height
        };
    };
    /**
     * 渲染总入库，包括数据区域和选区
     */
    ExcelRender.prototype.draw = function (fromReRender) {
        if (fromReRender === void 0) { fromReRender = false; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            var startDraw, mainCanvas, currentSheet, _a, width, height, viewRange, displayData, frozenViewRange;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        startDraw = performance.now();
                        mainCanvas = this.sheetCanvas;
                        currentSheet = this.workbook.getActiveSheet();
                        _a = this.getWidthAndHeight(), width = _a.width, height = _a.height;
                        this.linkPositionCache = [];
                        viewRange = currentSheet.getViewPointRange(width, height);
                        this.workbook.getActiveSheet().updateViewRange(viewRange);
                        displayData = currentSheet.getViewPointData(viewRange);
                        mainCanvas.clear();
                        // 这个需要提前执行，保证 rowHeaderWidth 是正确的
                        currentSheet.updateRowHeaderWidth(viewRange);
                        // 绘制网格线
                        drawGridLines.drawGridLines(currentSheet, viewRange, mainCanvas, height, width, this.renderOptions);
                        // 绘制 Sparkline，这个要在单元格前面
                        drawSparkline.drawSparkline(currentSheet, viewRange, mainCanvas);
                        // 绘制单元格
                        drawCells.drawCells(this, currentSheet, this.renderOptions, mainCanvas, displayData, this.linkPositionCache);
                        // 绘制自动筛选功能
                        renderAutoFilter.renderAutoFilter(currentSheet, this.dataContainer);
                        // 绘制图片及文本框
                        drawDrawing.drawDrawing(this, currentSheet, viewRange, mainCanvas);
                        // 表头晚于内容区绘制
                        drawRowColHeaders.drawRowColHeaders(currentSheet, viewRange, mainCanvas, this.renderOptions, this.defaultFontSize, this.dataProvider.getDefaultFontStyle());
                        frozenViewRange = drawFrozen.drawFrozen(this, currentSheet, this.dataProvider, this.renderOptions, mainCanvas, height, width, this.linkPositionCache);
                        this.workbook.getActiveSheet().updateFrozenViewRange(frozenViewRange);
                        if (this.renderOptions.debug) {
                            console.log('draw time', (performance.now() - startDraw).toFixed(2), 'ms');
                        }
                        // 目前只有渲染后才知道字体是否加载
                        return [4 /*yield*/, this.loadFont()];
                    case 1:
                        // 目前只有渲染后才知道字体是否加载
                        _b.sent();
                        if (this.needReDraw && fromReRender === false) {
                            this.needReDraw = false;
                            // 避免死循环
                            this.draw(true);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * 加载字体
     */
    ExcelRender.prototype.loadFont = function () {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var fontURL, notAvailableFonts, needReDraw, notAvailableFonts_1, notAvailableFonts_1_1, font, fontFace, e_1_1, currentSheet;
            var e_1, _a;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        fontURL = this.renderOptions.fontURL;
                        notAvailableFonts = checkFont.getAllNotAvailableFont();
                        needReDraw = false;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 7, 8, 9]);
                        notAvailableFonts_1 = tslib.__values(notAvailableFonts), notAvailableFonts_1_1 = notAvailableFonts_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!notAvailableFonts_1_1.done) return [3 /*break*/, 6];
                        font = notAvailableFonts_1_1.value;
                        if (this.loadedFont.has(font)) {
                            return [3 /*break*/, 5];
                        }
                        if (!(font in fontURL)) return [3 /*break*/, 4];
                        this.loadedFont.add(font);
                        fontFace = new FontFace(font, "url(".concat(fontURL[font], ")"));
                        return [4 /*yield*/, fontFace.load()];
                    case 3:
                        _b.sent();
                        document.fonts.add(fontFace);
                        needReDraw = true;
                        return [3 /*break*/, 5];
                    case 4:
                        console.warn('font not found', font);
                        _b.label = 5;
                    case 5:
                        notAvailableFonts_1_1 = notAvailableFonts_1.next();
                        return [3 /*break*/, 2];
                    case 6: return [3 /*break*/, 9];
                    case 7:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 9];
                    case 8:
                        try {
                            if (notAvailableFonts_1_1 && !notAvailableFonts_1_1.done && (_a = notAvailableFonts_1.return)) _a.call(notAvailableFonts_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 9:
                        if (needReDraw) {
                            // 宽度可能变化
                            measureTextWithCache.inValidTextSizeCache();
                            currentSheet = this.workbook.getActiveSheet();
                            currentSheet.clearFontCache();
                            this.setNeedReDraw();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ExcelRender.prototype.setNeedReDraw = function () {
        var now = new Date().getTime();
        if (this.needReDraw) {
            // 避免频繁调用
            if (now - this.needReDraw < 100) {
                return;
            }
        }
        this.needReDraw = new Date().getTime();
    };
    /**
     * 销毁
     */
    ExcelRender.prototype.destroy = function () {
        this.contentContainer.removeEventListener('wheel', this.handleWheel);
        this.contentContainer.removeEventListener('mousedown', this.handleMousedown);
    };
    return ExcelRender;
}());

exports.ExcelRender = ExcelRender;
