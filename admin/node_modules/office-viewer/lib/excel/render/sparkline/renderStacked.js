'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var applyColor = require('./applyColor.js');
var number = require('../../../util/number.js');

/**
 * render win/loss sparkline
 */
function renderStacked(ctx, width, height, min, max, data, sparklineOptions, getColor) {
    var e_1, _a;
    var color = getColor(sparklineOptions['x14:colorSeries']);
    var colorNegative = getColor(sparklineOptions['x14:colorNegative']);
    // 柱状图之间的间隔
    var gap = 2;
    var columnHeight = height / 2;
    // 只有一个点就只绘制中间
    if (data.length === 1) {
        var firstData = data[0];
        if (firstData !== undefined) {
            var columnWidth_1 = 6;
            if (number.gt(firstData, 0)) {
                ctx.fillStyle = color;
                ctx.fillRect(width / 2, 0, columnWidth_1, columnHeight);
            }
            else {
                ctx.fillStyle = colorNegative;
                ctx.fillRect(width / 2, height - columnHeight, columnWidth_1, columnHeight);
            }
        }
        return;
    }
    var columnWidth = (width - gap * (data.length - 1)) / data.length;
    try {
        for (var _b = tslib.__values(data.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib.__read(_c.value, 2), index = _d[0], value = _d[1];
            if (value === undefined) {
                continue;
            }
            applyColor.applyColor(ctx, data, index, value, min, max, sparklineOptions, color, getColor);
            var x = index * (columnWidth + gap);
            var y = void 0;
            if (number.gt(value, 0)) {
                ctx.fillStyle = color;
                y = 0;
            }
            else {
                ctx.fillStyle = colorNegative;
                y = height - columnHeight;
            }
            ctx.fillRect(x, y, columnWidth, columnHeight);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

exports.renderStacked = renderStacked;
