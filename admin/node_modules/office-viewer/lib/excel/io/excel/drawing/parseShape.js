'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var autoParse = require('../../../../common/autoParse.js');
var ExcelTypes = require('../../../../openxml/ExcelTypes.js');
var ShapeProperties = require('../../../../openxml/drawing/ShapeProperties.js');
var parseChildColor = require('../../../../word/parse/parseChildColor.js');
var getThemeColor = require('../../../data/getThemeColor.js');

function parseShape(workbook, child, twoCellAnchorElement) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var shape = autoParse.autoParse(child, ExcelTypes.CT_Shape_Attributes);
    // 下面是转成渲染需要的数据
    if (twoCellAnchorElement) {
        var spPrs = twoCellAnchorElement.getElementsByTagName('xdr:spPr');
        if (spPrs.length && shape.spPr) {
            var spPr = spPrs[0];
            try {
                for (var _e = tslib.__values(spPr.children || []), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var spPrChild = _f.value;
                    var tag = spPrChild.tagName;
                    switch (tag) {
                        case 'a:ln':
                            var outline = ShapeProperties.parseOutline(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, spPrChild);
                            shape.spPr.outline = outline;
                            break;
                        case 'a:solidFill':
                            shape.spPr.fillColor = parseChildColor.parseChildColor(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, spPrChild);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var style = twoCellAnchorElement.getElementsByTagName('xdr:style');
        if (style.length) {
            var styleColor = {};
            shape.styleColor = styleColor;
            try {
                for (var _g = tslib.__values(style[0].children || []), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var styleChild = _h.value;
                    var tagName = styleChild.tagName;
                    switch (tagName) {
                        case 'a:lnRef':
                            styleColor.lnRefColor = parseChildColor.parseChildColor(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, styleChild);
                            break;
                        case 'a:fillRef':
                            styleColor.fillRefColor = parseChildColor.parseChildColor(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, styleChild);
                            break;
                        case 'a:effectRef':
                            styleColor.effectRefColor = parseChildColor.parseChildColor(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, styleChild);
                            break;
                        case 'a:fontRef':
                            styleColor.fontRefColor = parseChildColor.parseChildColor(function (c) {
                                return getThemeColor.getThemeColor(c, workbook);
                            }, styleChild);
                            break;
                        default:
                            break;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        var txBodies = twoCellAnchorElement.getElementsByTagName('xdr:txBody');
        if (txBodies.length) {
            var txBody = txBodies[0];
            var ts = [];
            // 转成富文本格式方便渲染
            var ps = txBody.getElementsByTagName('a:p');
            try {
                for (var ps_1 = tslib.__values(ps), ps_1_1 = ps_1.next(); !ps_1_1.done; ps_1_1 = ps_1.next()) {
                    var p = ps_1_1.value;
                    var rs = p.getElementsByTagName('a:r');
                    try {
                        for (var rs_1 = (e_4 = void 0, tslib.__values(rs)), rs_1_1 = rs_1.next(); !rs_1_1.done; rs_1_1 = rs_1.next()) {
                            var r = rs_1_1.value;
                            var t = r.getElementsByTagName('a:t');
                            if (t.length) {
                                var rPrNodes = r.getElementsByTagName('a:rPr');
                                var rPr = {};
                                if (rPrNodes.length) {
                                    var rPrNode = rPrNodes[0];
                                    var sz = rPrNode.getAttribute('sz');
                                    if (sz) {
                                        // 不知为何拿到的是 100 倍的值
                                        rPr.sz = parseInt(sz, 10) / 100;
                                    }
                                    var b = rPrNode.getAttribute('b');
                                    if (b) {
                                        rPr.b = true;
                                    }
                                    var solidFill = rPrNode.getElementsByTagName('a:solidFill');
                                    if (solidFill.length) {
                                        rPr.color = {
                                            rgb: parseChildColor.parseChildColor(function (c) {
                                                return getThemeColor.getThemeColor(c, workbook);
                                            }, solidFill[0])
                                        };
                                    }
                                }
                                var text = t[0].textContent;
                                if (text) {
                                    ts.push({
                                        rPr: rPr,
                                        t: text
                                    });
                                }
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (rs_1_1 && !rs_1_1.done && (_d = rs_1.return)) _d.call(rs_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (ps_1_1 && !ps_1_1.done && (_c = ps_1.return)) _c.call(ps_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            shape.richText = {
                type: 'rich',
                richText: ts
            };
        }
    }
    return shape;
}

exports.parseShape = parseShape;
