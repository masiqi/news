'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var autoParse = require('../../../../common/autoParse.js');
var parseRelationship = require('../../../../common/parseRelationship.js');
var ExcelTypes = require('../../../../openxml/ExcelTypes.js');
var xml = require('../../../../util/xml.js');
var getRelPath = require('../getRelPath.js');
var parseAnchorCommon = require('./parseAnchorCommon.js');

/**
 * 解析 xl/drawings/drawing1.xml 文件
 * P3155
 */
function parseDrawing(workbook, parser, drawingPath) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var drawing, drawingXML, relationships, drawingRelationPath, node, nodeElement, oneCellAnchorElements, twoCellAnchorElements, absoluteAnchorElements, _a, _b, _c, index, drawingNode, childTag, _d, oneCellAnchor, oneCellAnchorElement, twoCellAnchor, twoCellAnchorElement, absoluteAnchor, absoluteAnchorElement, e_1_1;
        var e_1, _e;
        return tslib.__generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    drawing = {
                        oneCellAnchors: [],
                        twoCellAnchors: [],
                        absoluteAnchors: []
                    };
                    drawingXML = parser.getString(drawingPath);
                    relationships = [];
                    drawingRelationPath = getRelPath.getRelPath(drawingPath);
                    if (!parser.fileExists(drawingRelationPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, parseRelationship.parseRelationship(parser.getString(drawingRelationPath))];
                case 1:
                    relationships = _f.sent();
                    _f.label = 2;
                case 2: return [4 /*yield*/, xml.xml2json(drawingXML)];
                case 3:
                    node = _f.sent();
                    nodeElement = xml.parseXML(drawingXML);
                    oneCellAnchorElements = nodeElement.getElementsByTagName('xdr:oneCellAnchor');
                    twoCellAnchorElements = nodeElement.getElementsByTagName('xdr:twoCellAnchor');
                    absoluteAnchorElements = nodeElement.getElementsByTagName('xdr:absoluteAnchor');
                    _f.label = 4;
                case 4:
                    _f.trys.push([4, 15, 16, 17]);
                    _a = tslib.__values((node.children || []).entries()), _b = _a.next();
                    _f.label = 5;
                case 5:
                    if (!!_b.done) return [3 /*break*/, 14];
                    _c = tslib.__read(_b.value, 2), index = _c[0], drawingNode = _c[1];
                    childTag = drawingNode.tag;
                    _d = childTag;
                    switch (_d) {
                        case 'xdr:oneCellAnchor': return [3 /*break*/, 6];
                        case 'xdr:twoCellAnchor': return [3 /*break*/, 8];
                        case 'xdr:absoluteAnchor': return [3 /*break*/, 10];
                    }
                    return [3 /*break*/, 12];
                case 6:
                    oneCellAnchor = autoParse.autoParse(drawingNode, ExcelTypes.CT_OneCellAnchor_Attributes);
                    oneCellAnchorElement = oneCellAnchorElements[index];
                    return [4 /*yield*/, parseAnchorCommon.parseAnchorCommon(workbook, parser, drawingPath, drawingNode, relationships, oneCellAnchor, oneCellAnchorElement)];
                case 7:
                    _f.sent();
                    drawing.oneCellAnchors.push(oneCellAnchor);
                    return [3 /*break*/, 13];
                case 8:
                    twoCellAnchor = autoParse.autoParse(drawingNode, ExcelTypes.CT_TwoCellAnchor_Attributes);
                    twoCellAnchorElement = twoCellAnchorElements[index];
                    return [4 /*yield*/, parseAnchorCommon.parseAnchorCommon(workbook, parser, drawingPath, drawingNode, relationships, twoCellAnchor, twoCellAnchorElement)];
                case 9:
                    _f.sent();
                    drawing.twoCellAnchors.push(twoCellAnchor);
                    return [3 /*break*/, 13];
                case 10:
                    absoluteAnchor = autoParse.autoParse(drawingNode, ExcelTypes.CT_AbsoluteAnchor_Attributes);
                    absoluteAnchorElement = absoluteAnchorElements[index];
                    return [4 /*yield*/, parseAnchorCommon.parseAnchorCommon(workbook, parser, drawingPath, drawingNode, relationships, absoluteAnchor, absoluteAnchorElement)];
                case 11:
                    _f.sent();
                    drawing.absoluteAnchors.push(absoluteAnchor);
                    return [3 /*break*/, 13];
                case 12:
                    console.warn("unhandled tag: ".concat(childTag));
                    _f.label = 13;
                case 13:
                    _b = _a.next();
                    return [3 /*break*/, 5];
                case 14: return [3 /*break*/, 17];
                case 15:
                    e_1_1 = _f.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 17];
                case 16:
                    try {
                        if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 17: return [2 /*return*/, drawing];
            }
        });
    });
}

exports.parseDrawing = parseDrawing;
