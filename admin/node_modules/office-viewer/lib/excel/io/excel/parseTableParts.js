'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var autoParse = require('../../../common/autoParse.js');
var ExcelTypes = require('../../../openxml/ExcelTypes.js');
var joinPath = require('../../../util/joinPath.js');
var xml = require('../../../util/xml.js');

function parseTableParts(worksheetPath, parser, relationships, tablePartsNode) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var tables, _loop_1, _a, _b, tableParts, e_1_1;
        var e_1, _c;
        return tslib.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    tables = [];
                    _loop_1 = function (tableParts) {
                        var rId, relationship, target, path, tableXML, tableNode;
                        return tslib.__generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    rId = tableParts.attrs['r:id'];
                                    relationship = relationships.find(function (relationship) { return relationship.id === rId; });
                                    if (!relationship) return [3 /*break*/, 2];
                                    target = relationship.target;
                                    path = joinPath.joinPath(worksheetPath, '..', target);
                                    tableXML = parser.getString(path);
                                    return [4 /*yield*/, xml.xml2json(tableXML)];
                                case 1:
                                    tableNode = _e.sent();
                                    tables.push(autoParse.autoParse(tableNode, ExcelTypes.CT_Table_Attributes));
                                    _e.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    };
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 6, 7, 8]);
                    _a = tslib.__values(tablePartsNode.children || []), _b = _a.next();
                    _d.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 5];
                    tableParts = _b.value;
                    return [5 /*yield**/, _loop_1(tableParts)];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/, tables];
            }
        });
    });
}

exports.parseTableParts = parseTableParts;
