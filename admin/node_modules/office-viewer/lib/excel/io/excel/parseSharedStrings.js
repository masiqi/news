'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var xml = require('../../../util/xml.js');
var parseColor = require('./stylesheet/parseColor.js');

/**
 * 解析 sharedStrings.xml 文件
 */
/**
 * 解析 CT_RPrElt
 */
function parseRPr(node) {
    var e_1, _a;
    var rPr = {};
    try {
        for (var _b = tslib.__values(node.children || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tag = child.tag;
            switch (tag) {
                case 'rFont':
                    rPr.rFont = child.attrs.val;
                    break;
                case 'charset':
                    rPr.charset = parseInt(child.attrs.val, 10);
                    break;
                case 'family':
                    rPr.family = parseInt(child.attrs.val, 10);
                    break;
                case 'b':
                    rPr.b = true;
                    break;
                case 'i':
                    rPr.i = true;
                    break;
                case 'strike':
                    rPr.strike = true;
                    break;
                case 'outline':
                    rPr.outline = true;
                    break;
                case 'shadow':
                    rPr.shadow = true;
                    break;
                case 'condense':
                    rPr.condense = true;
                    break;
                case 'extend':
                    rPr.extend = true;
                    break;
                case 'color':
                    rPr.color = parseColor.parseColor(child);
                    break;
                case 'sz':
                    rPr.sz = parseInt(child.attrs.val, 10);
                    break;
                case 'u':
                    rPr.u = true;
                    break;
                case 'vertAlign':
                    rPr.vertAlign = child.attrs.val;
                    break;
                case 'scheme':
                    rPr.scheme = child.attrs.val;
                    break;
                default:
                    console.warn("parseRPr: ".concat(tag, " is not supported"));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return rPr;
}
/**
 * 这里接口使用字符串是为了方便单测
 * @param xml
 */
function parseSharedStrings(xml$1) {
    return tslib.__awaiter(this, void 0, void 0, function () {
        var sharedStrings, sst, _a, _b, si, isSimple, text, richText, _c, _d, rst, rPr, t, _e, _f, relt, tag;
        var e_2, _g, e_3, _h, e_4, _j;
        return tslib.__generator(this, function (_k) {
            switch (_k.label) {
                case 0:
                    sharedStrings = [];
                    if (!xml$1) {
                        return [2 /*return*/, sharedStrings];
                    }
                    return [4 /*yield*/, xml.xml2json(xml$1)];
                case 1:
                    sst = _k.sent();
                    try {
                        for (_a = tslib.__values(sst.children || []), _b = _a.next(); !_b.done; _b = _a.next()) {
                            si = _b.value;
                            // 对应 CT_Rst 类型，子节点只有可能是 t、r、rPh、phoneticPr
                            if (si.tag === 'si') {
                                isSimple = true;
                                text = '';
                                richText = {
                                    type: 'rich',
                                    richText: []
                                };
                                try {
                                    for (_c = (e_3 = void 0, tslib.__values(si.children || [])), _d = _c.next(); !_d.done; _d = _c.next()) {
                                        rst = _d.value;
                                        if (rst.tag === 'r') {
                                            isSimple = false;
                                            rPr = {};
                                            t = '';
                                            try {
                                                // 对应 CT_RElt
                                                for (_e = (e_4 = void 0, tslib.__values(rst.children || [])), _f = _e.next(); !_f.done; _f = _e.next()) {
                                                    relt = _f.value;
                                                    tag = relt.tag;
                                                    if (tag === 'rPr') {
                                                        rPr = parseRPr(relt);
                                                    }
                                                    if (tag === 't') {
                                                        t = relt.text || '';
                                                    }
                                                }
                                            }
                                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                            finally {
                                                try {
                                                    if (_f && !_f.done && (_j = _e.return)) _j.call(_e);
                                                }
                                                finally { if (e_4) throw e_4.error; }
                                            }
                                            richText.richText.push({
                                                rPr: rPr,
                                                t: t
                                            });
                                        }
                                        if (rst.tag === 't') {
                                            text = rst.text || '';
                                        }
                                    }
                                }
                                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                finally {
                                    try {
                                        if (_d && !_d.done && (_h = _c.return)) _h.call(_c);
                                    }
                                    finally { if (e_3) throw e_3.error; }
                                }
                                if (isSimple) {
                                    sharedStrings.push(text);
                                }
                                else {
                                    sharedStrings.push(richText);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_g = _a.return)) _g.call(_a);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    return [2 /*return*/, sharedStrings];
            }
        });
    });
}

exports.parseSharedStrings = parseSharedStrings;
