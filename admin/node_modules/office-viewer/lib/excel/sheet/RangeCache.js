'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var Range = require('../io/excel/util/Range.js');

/**
 * 范围缓存，方便数据变化的时候自动清空
 */
/**
 * 范围的缓存 key
 */
function rangeCacheKey(range) {
    return "".concat(range.startRow, "-").concat(range.startCol, "-").concat(range.endRow, "-").concat(range.endCol);
}
function rangeCacheKeyToRange(key) {
    var _a = tslib.__read(key.split('-'), 4), startRow = _a[0], startCol = _a[1], endRow = _a[2], endCol = _a[3];
    return {
        startRow: parseInt(startRow, 10),
        startCol: parseInt(startCol, 10),
        endRow: parseInt(endRow, 10),
        endCol: parseInt(endCol, 10)
    };
}
var RangeCache = /** @class */ (function () {
    function RangeCache() {
        /**
         * 缓存
         */
        this.cache = new Map();
    }
    /**
     * 设置缓存
     */
    RangeCache.prototype.set = function (ranges, key, value) {
        var cacheKey = ranges.map(rangeCacheKey).join(' ');
        if (!this.cache.has(cacheKey)) {
            this.cache.set(cacheKey, new Map());
        }
        this.cache.get(cacheKey).set(key, value);
    };
    /**
     * 获取缓存
     */
    RangeCache.prototype.get = function (ranges, key) {
        var cacheKey = ranges.map(rangeCacheKey).join(' ');
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey).get(key);
        }
        return null;
    };
    /**
     * 清理相关缓存，会判断是否相交
     */
    RangeCache.prototype.clear = function (ranges) {
        var e_1, _a, e_2, _b, e_3, _c;
        try {
            for (var ranges_1 = tslib.__values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
                var range = ranges_1_1.value;
                try {
                    for (var _d = (e_2 = void 0, tslib.__values(this.cache.keys())), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var rangeKeys = _e.value;
                        var cacheRanges = rangeKeys.split(' ').map(rangeCacheKeyToRange);
                        try {
                            for (var cacheRanges_1 = (e_3 = void 0, tslib.__values(cacheRanges)), cacheRanges_1_1 = cacheRanges_1.next(); !cacheRanges_1_1.done; cacheRanges_1_1 = cacheRanges_1.next()) {
                                var cacheRange = cacheRanges_1_1.value;
                                if (Range.rangeIntersect(range, cacheRange)) {
                                    this.cache.delete(rangeKeys);
                                    break;
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (cacheRanges_1_1 && !cacheRanges_1_1.done && (_c = cacheRanges_1.return)) _c.call(cacheRanges_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    return RangeCache;
}());

exports.RangeCache = RangeCache;
exports.rangeCacheKey = rangeCacheKey;
exports.rangeCacheKeyToRange = rangeCacheKeyToRange;
