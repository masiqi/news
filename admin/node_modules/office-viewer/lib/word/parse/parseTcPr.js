'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var parseCellMargin = require('./parseCellMargin.js');
var parseColor = require('./parseColor.js');
var OpenXML = require('../../OpenXML.js');
var parseBorder = require('./parseBorder.js');
var parseTextDirection = require('./parseTextDirection.js');
var parseTblWidth = require('./parseTblWidth.js');
var parseInsideBorders = require('./parseInsideBorders.js');

function parseVAlign(element, style) {
    var vAlign = OpenXML.getVal(element);
    switch (vAlign) {
        case 'bottom':
            style['vertical-align'] = 'bottom';
            break;
        case 'center':
            style['vertical-align'] = 'middle';
            break;
        case 'top':
            style['vertical-align'] = 'top';
            break;
    }
}
function parseTblCellSpacing(element, style) {
    var width = parseTblWidth.parseTblWidth(element);
    if (width) {
        style['cell-spacing'] = width;
    }
}
function parseTcW(element, style) {
    var width = parseTblWidth.parseTblWidth(element);
    if (width) {
        style.width = width;
    }
}
function parseTcPr(word, element) {
    var e_1, _a;
    var properties = {};
    var style = {};
    properties.cssStyle = style;
    try {
        for (var _b = tslib.__values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'w:tcMar':
                    parseCellMargin.parseCellMargin(child, style);
                    break;
                case 'w:shd':
                    style['background-color'] = parseColor.parseShdColor(word, child);
                    break;
                case 'w:tcW':
                    parseTcW(child, style);
                    break;
                case 'w:noWrap':
                    // http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/noWrap.html
                    var noWrap = OpenXML.getValBoolean(child);
                    if (noWrap) {
                        style['white-space'] = 'nowrap';
                    }
                    break;
                case 'w:vAlign':
                    parseVAlign(child, style);
                    break;
                case 'w:tcBorders':
                    parseBorder.parseBorders(word, child, style);
                    properties.insideBorder = parseInsideBorders.parseInsideBorders(word, child);
                    break;
                case 'w:gridSpan':
                    properties.gridSpan = OpenXML.getValNumber(child);
                    break;
                case 'w:vMerge':
                    properties.vMerge = OpenXML.getVal(child) || 'continue';
                    break;
                case 'w:textDirection':
                    parseTextDirection.parseTextDirection(child, style);
                    break;
                case 'w:cnfStyle':
                    // 目前是自动计算的，所以不需要这个了
                    break;
                case 'w:hideMark':
                    properties.hideMark = OpenXML.getValBoolean(child, true);
                    break;
                default:
                    console.warn('parseTcPr: ignore', tagName, child);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return properties;
}

exports.parseTblCellSpacing = parseTblCellSpacing;
exports.parseTcPr = parseTcPr;
