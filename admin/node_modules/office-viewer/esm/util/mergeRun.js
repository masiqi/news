import { __values } from 'tslib';
import { parsePr } from '../word/parse/parsePr.js';

/**
 * 合并 p 下相同的文本，主要是为了方便替换变量
 */
/**
 *  是否具有相同样式
 */
function hasSomeStyle(word, first, second) {
    var firstStyle = first ? parsePr(word, first) : {};
    var secondStyle = second ? parsePr(word, second) : {};
    return JSON.stringify(firstStyle) === JSON.stringify(secondStyle);
}
function mergeText(first, second) {
    var firstT = first.getElementsByTagName('w:t')[0];
    var secondT = second.getElementsByTagName('w:t')[0];
    if (firstT && secondT) {
        var secondText = secondT.textContent || '';
        firstT.textContent += secondText || '';
    }
}
/**
 * 只支持处理 w:r 下有 w:t 的情况
 */
function canMerge(element) {
    var e_1, _a;
    var tagName = element.tagName;
    var childChildren = element.children;
    var hasText = false;
    var textHasSpace = false;
    try {
        for (var childChildren_1 = __values(childChildren), childChildren_1_1 = childChildren_1.next(); !childChildren_1_1.done; childChildren_1_1 = childChildren_1.next()) {
            var childChild = childChildren_1_1.value;
            if (childChild.tagName === 'w:t') {
                hasText = true;
                textHasSpace = childChild.getAttribute('xml:space') === 'preserve';
                if (textHasSpace) {
                    break;
                }
            }
            // 有 tab 的情况下不能合并
            if (childChild.tagName === 'w:tab') {
                return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (childChildren_1_1 && !childChildren_1_1.done && (_a = childChildren_1.return)) _a.call(childChildren_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return tagName === 'w:r' && hasText && !textHasSpace;
}
/**
 * 合并 p 下相同的文本
 */
function mergeRunInP(word, p) {
    var e_2, _a, e_3, _b;
    var newElements = [];
    var lastRun = null;
    try {
        for (var _c = __values(p.children), _d = _c.next(); !_d.done; _d = _c.next()) {
            var child = _d.value;
            var tagName = child.tagName;
            // 避免图片和空格被合并了
            if (canMerge(child)) {
                if (lastRun) {
                    var lastRunProps = lastRun.getElementsByTagName('w:rPr')[0];
                    var thisProps = child.getElementsByTagName('w:rPr')[0];
                    if (hasSomeStyle(word, lastRunProps, thisProps)) {
                        mergeText(lastRun, child);
                    }
                    else {
                        lastRun = child;
                        newElements.push(child);
                    }
                }
                else {
                    // 说明是第一次运行
                    lastRun = child;
                    newElements.push(child);
                }
            }
            else {
                // 忽略这个标签
                if (tagName !== 'w:proofErr') {
                    lastRun = null;
                    newElements.push(child);
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_2) throw e_2.error; }
    }
    p.innerHTML = '';
    try {
        for (var newElements_1 = __values(newElements), newElements_1_1 = newElements_1.next(); !newElements_1_1.done; newElements_1_1 = newElements_1.next()) {
            var newElement = newElements_1_1.value;
            p.appendChild(newElement);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (newElements_1_1 && !newElements_1_1.done && (_b = newElements_1.return)) _b.call(newElements_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
/**
 * 合并
 * @param document
 */
function mergeRun(word, doc) {
    var e_4, _a;
    var ps = doc.getElementsByTagName('w:p');
    try {
        for (var ps_1 = __values(ps), ps_1_1 = ps_1.next(); !ps_1_1.done; ps_1_1 = ps_1.next()) {
            var p = ps_1_1.value;
            mergeRunInP(word, p);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (ps_1_1 && !ps_1_1.done && (_a = ps_1.return)) _a.call(ps_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
}

export { canMerge, mergeRun, mergeRunInP };
