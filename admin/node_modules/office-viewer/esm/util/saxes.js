import { __spreadArray, __read, __values, __assign } from 'tslib';
import { isS as isS$1, isChar, isNameStartChar as isNameStartChar$1, isNameChar as isNameChar$1, S_LIST as S_LIST$1, NAME_RE as NAME_RE$1 } from './xmlchars/xml/1.0/ed5.js';
import { isChar as isChar$1 } from './xmlchars/xml/1.1/ed2.js';
import { isNCNameStartChar as isNCNameStartChar$1, isNCNameChar as isNCNameChar$1, NC_NAME_RE as NC_NAME_RE$1 } from './xmlchars/xmlns/1.0/ed3.js';

/**
 * 来自 https://github.com/lddubeau/saxes，修了些类型报错，后续优化性能
 */
var isS = isS$1;
var isChar10 = isChar;
var isNameStartChar = isNameStartChar$1;
var isNameChar = isNameChar$1;
var S_LIST = S_LIST$1;
var NAME_RE = NAME_RE$1;
var isChar11 = isChar$1;
var isNCNameStartChar = isNCNameStartChar$1;
var isNCNameChar = isNCNameChar$1;
var NC_NAME_RE = NC_NAME_RE$1;
var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
var rootNS = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
    __proto__: null,
    xml: XML_NAMESPACE,
    xmlns: XMLNS_NAMESPACE
};
var XML_ENTITIES = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
    __proto__: null,
    amp: '&',
    gt: '>',
    lt: '<',
    quot: '"',
    apos: "'"
};
// EOC: end-of-chunk
var EOC = -1;
var NL_LIKE = -2;
var S_BEGIN = 0; // Initial state.
var S_BEGIN_WHITESPACE = 1; // leading whitespace
var S_DOCTYPE = 2; // <!DOCTYPE
var S_DOCTYPE_QUOTE = 3; // <!DOCTYPE "//blah
var S_DTD = 4; // <!DOCTYPE "//blah" [ ...
var S_DTD_QUOTED = 5; // <!DOCTYPE "//blah" [ "foo
var S_DTD_OPEN_WAKA = 6;
var S_DTD_OPEN_WAKA_BANG = 7;
var S_DTD_COMMENT = 8; // <!--
var S_DTD_COMMENT_ENDING = 9; // <!-- blah -
var S_DTD_COMMENT_ENDED = 10; // <!-- blah --
var S_DTD_PI = 11; // <?
var S_DTD_PI_ENDING = 12; // <?hi "there" ?
var S_TEXT = 13; // general stuff
var S_ENTITY = 14; // &amp and such
var S_OPEN_WAKA = 15; // <
var S_OPEN_WAKA_BANG = 16; // <!...
var S_COMMENT = 17; // <!--
var S_COMMENT_ENDING = 18; // <!-- blah -
var S_COMMENT_ENDED = 19; // <!-- blah --
var S_CDATA = 20; // <![CDATA[ something
var S_CDATA_ENDING = 21; // ]
var S_CDATA_ENDING_2 = 22; // ]]
var S_PI_FIRST_CHAR = 23; // <?hi, first char
var S_PI_REST = 24; // <?hi, rest of the name
var S_PI_BODY = 25; // <?hi there
var S_PI_ENDING = 26; // <?hi "there" ?
var S_XML_DECL_NAME_START = 27; // <?xml
var S_XML_DECL_NAME = 28; // <?xml foo
var S_XML_DECL_EQ = 29; // <?xml foo=
var S_XML_DECL_VALUE_START = 30; // <?xml foo=
var S_XML_DECL_VALUE = 31; // <?xml foo="bar"
var S_XML_DECL_SEPARATOR = 32; // <?xml foo="bar"
var S_XML_DECL_ENDING = 33; // <?xml ... ?
var S_OPEN_TAG = 34; // <strong
var S_OPEN_TAG_SLASH = 35; // <strong /
var S_ATTRIB = 36; // <a
var S_ATTRIB_NAME = 37; // <a foo
var S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _
var S_ATTRIB_VALUE = 39; // <a foo=
var S_ATTRIB_VALUE_QUOTED = 40; // <a foo="bar
var S_ATTRIB_VALUE_CLOSED = 41; // <a foo="bar"
var S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar
var S_CLOSE_TAG = 43; // </a
var S_CLOSE_TAG_SAW_WHITE = 44; // </a   >
var TAB = 9;
var NL = 0xa;
var CR = 0xd;
var SPACE = 0x20;
var BANG = 0x21;
var DQUOTE = 0x22;
var AMP = 0x26;
var SQUOTE = 0x27;
var MINUS = 0x2d;
var FORWARD_SLASH = 0x2f;
var SEMICOLON = 0x3b;
var LESS = 0x3c;
var EQUAL = 0x3d;
var GREATER = 0x3e;
var QUESTION = 0x3f;
var OPEN_BRACKET = 0x5b;
var CLOSE_BRACKET = 0x5d;
var NEL = 0x85;
var LS = 0x2028; // Line Separator
var isQuote = function (c) { return c === DQUOTE || c === SQUOTE; };
var QUOTES = [DQUOTE, SQUOTE];
var DOCTYPE_TERMINATOR = __spreadArray(__spreadArray([], __read(QUOTES), false), [OPEN_BRACKET, GREATER], false);
var DTD_TERMINATOR = __spreadArray(__spreadArray([], __read(QUOTES), false), [LESS, CLOSE_BRACKET], false);
var XML_DECL_NAME_TERMINATOR = __spreadArray([EQUAL, QUESTION], __read(S_LIST), false);
var ATTRIB_VALUE_UNQUOTED_TERMINATOR = __spreadArray(__spreadArray([], __read(S_LIST), false), [GREATER, AMP, LESS], false);
function nsPairCheck(parser, prefix, uri) {
    switch (prefix) {
        case 'xml':
            if (uri !== XML_NAMESPACE) {
                parser.fail("xml prefix must be bound to ".concat(XML_NAMESPACE, "."));
            }
            break;
        case 'xmlns':
            if (uri !== XMLNS_NAMESPACE) {
                parser.fail("xmlns prefix must be bound to ".concat(XMLNS_NAMESPACE, "."));
            }
            break;
    }
    switch (uri) {
        case XMLNS_NAMESPACE:
            parser.fail(prefix === ''
                ? "the default namespace may not be set to ".concat(uri, ".")
                : "may not assign a prefix (even \"xmlns\") to the URI ".concat(XMLNS_NAMESPACE, "."));
            break;
        case XML_NAMESPACE:
            switch (prefix) {
                case 'xml':
                    // Assinging the XML namespace to "xml" is fine.
                    break;
                case '':
                    parser.fail("the default namespace may not be set to ".concat(uri, "."));
                    break;
                default:
                    parser.fail('may not assign the xml namespace to another prefix.');
            }
            break;
    }
}
function nsMappingCheck(parser, mapping) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(mapping)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var local = _c.value;
            nsPairCheck(parser, local, mapping[local]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
var isNCName = function (name) { return NC_NAME_RE.test(name); };
var isName = function (name) { return NAME_RE.test(name); };
var FORBIDDEN_START = 0;
var FORBIDDEN_BRACKET = 1;
var FORBIDDEN_BRACKET_BRACKET = 2;
var EVENT_NAME_TO_HANDLER_NAME = {
    xmldecl: 'xmldeclHandler',
    text: 'textHandler',
    processinginstruction: 'piHandler',
    doctype: 'doctypeHandler',
    comment: 'commentHandler',
    opentagstart: 'openTagStartHandler',
    attribute: 'attributeHandler',
    opentag: 'openTagHandler',
    closetag: 'closeTagHandler',
    cdata: 'cdataHandler',
    error: 'errorHandler',
    end: 'endHandler',
    ready: 'readyHandler'
};
// eslint-disable-next-line @typescript-eslint/ban-types
var SaxesParser = /** @class */ (function () {
    /**
     * @param opt The parser options.
     */
    function SaxesParser(opt) {
        this.opt = opt !== null && opt !== void 0 ? opt : {};
        this.fragmentOpt = !!this.opt.fragment;
        var xmlnsOpt = (this.xmlnsOpt = !!this.opt.xmlns);
        this.trackPosition = this.opt.position !== false;
        this.fileName = this.opt.fileName;
        if (xmlnsOpt) {
            // This is the function we use to perform name checks on PIs and entities.
            // When namespaces are used, colons are not allowed in PI target names or
            // entity names. So the check depends on whether namespaces are used. See:
            //
            // https://www.w3.org/XML/xml-names-19990114-errata.html
            // NE08
            //
            this.nameStartCheck = isNCNameStartChar;
            this.nameCheck = isNCNameChar;
            this.isName = isNCName;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.processAttribs = this.processAttribsNS;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.pushAttrib = this.pushAttribNS;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
            this.ns = __assign({ __proto__: null }, rootNS);
            var additional = this.opt.additionalNamespaces;
            if (additional != null) {
                nsMappingCheck(this, additional);
                Object.assign(this.ns, additional);
            }
        }
        else {
            this.nameStartCheck = isNameStartChar;
            this.nameCheck = isNameChar;
            this.isName = isName;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.processAttribs = this.processAttribsPlain;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.pushAttrib = this.pushAttribPlain;
        }
        //
        // The order of the members in this table needs to correspond to the state
        // numbers given to the states that correspond to the methods being recorded
        // here.
        //
        this.stateTable = [
            /* eslint-disable @typescript-eslint/unbound-method */
            this.sBegin,
            this.sBeginWhitespace,
            this.sDoctype,
            this.sDoctypeQuote,
            this.sDTD,
            this.sDTDQuoted,
            this.sDTDOpenWaka,
            this.sDTDOpenWakaBang,
            this.sDTDComment,
            this.sDTDCommentEnding,
            this.sDTDCommentEnded,
            this.sDTDPI,
            this.sDTDPIEnding,
            this.sText,
            this.sEntity,
            this.sOpenWaka,
            this.sOpenWakaBang,
            this.sComment,
            this.sCommentEnding,
            this.sCommentEnded,
            this.sCData,
            this.sCDataEnding,
            this.sCDataEnding2,
            this.sPIFirstChar,
            this.sPIRest,
            this.sPIBody,
            this.sPIEnding,
            this.sXMLDeclNameStart,
            this.sXMLDeclName,
            this.sXMLDeclEq,
            this.sXMLDeclValueStart,
            this.sXMLDeclValue,
            this.sXMLDeclSeparator,
            this.sXMLDeclEnding,
            this.sOpenTag,
            this.sOpenTagSlash,
            this.sAttrib,
            this.sAttribName,
            this.sAttribNameSawWhite,
            this.sAttribValue,
            this.sAttribValueQuoted,
            this.sAttribValueClosed,
            this.sAttribValueUnquoted,
            this.sCloseTag,
            this.sCloseTagSawWhite
            /* eslint-enable @typescript-eslint/unbound-method */
        ];
        this._init();
    }
    Object.defineProperty(SaxesParser.prototype, "closed", {
        /**
         * Indicates whether or not the parser is closed. If ``true``, wait for
         * the ``ready`` event to write again.
         */
        get: function () {
            return this._closed;
        },
        enumerable: false,
        configurable: true
    });
    SaxesParser.prototype._init = function () {
        var _a;
        this.openWakaBang = '';
        this.text = '';
        this.name = '';
        this.piTarget = '';
        this.entity = '';
        this.q = null;
        this.tags = [];
        this.tag = null;
        this.topNS = null;
        this.chunk = '';
        this.chunkPosition = 0;
        this.i = 0;
        this.prevI = 0;
        this.carriedFromPrevious = undefined;
        this.forbiddenState = FORBIDDEN_START;
        this.attribList = [];
        // The logic is organized so as to minimize the need to check
        // this.opt.fragment while parsing.
        var fragmentOpt = this.fragmentOpt;
        this.state = fragmentOpt ? S_TEXT : S_BEGIN;
        // We want these to be all true if we are dealing with a fragment.
        this.reportedTextBeforeRoot =
            this.reportedTextAfterRoot =
                this.closedRoot =
                    this.sawRoot =
                        fragmentOpt;
        // An XML declaration is intially possible only when parsing whole
        // documents.
        this.xmlDeclPossible = !fragmentOpt;
        this.xmlDeclExpects = ['version'];
        this.entityReturnState = undefined;
        var defaultXMLVersion = this.opt.defaultXMLVersion;
        if (defaultXMLVersion === undefined) {
            if (this.opt.forceXMLVersion === true) {
                throw new Error('forceXMLVersion set but defaultXMLVersion is not set');
            }
            defaultXMLVersion = '1.0';
        }
        this.setXMLVersion(defaultXMLVersion);
        this.positionAtNewLine = 0;
        this.doctype = false;
        this._closed = false;
        this.xmlDecl = {
            version: undefined,
            encoding: undefined,
            standalone: undefined
        };
        this.line = 1;
        this.column = 0;
        this.ENTITIES = Object.create(XML_ENTITIES);
        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
    };
    Object.defineProperty(SaxesParser.prototype, "position", {
        /**
         * The stream position the parser is currently looking at. This field is
         * zero-based.
         *
         * This field is not based on counting Unicode characters but is to be
         * interpreted as a plain index into a JavaScript string.
         */
        get: function () {
            return this.chunkPosition + this.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SaxesParser.prototype, "columnIndex", {
        /**
         * The column number of the next character to be read by the parser.  *
         * This field is zero-based. (The first column in a line is 0.)
         *
         * This field reports the index at which the next character would be in the
         * line if the line were represented as a JavaScript string.  Note that this
         * *can* be different to a count based on the number of *Unicode characters*
         * due to how JavaScript handles astral plane characters.
         *
         * See [[column]] for a number that corresponds to a count of Unicode
         * characters.
         */
        get: function () {
            return this.position - this.positionAtNewLine;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Set an event listener on an event. The parser supports one handler per
     * event type. If you try to set an event handler over an existing handler,
     * the old handler is silently overwritten.
     *
     * @param name The event to listen to.
     *
     * @param handler The handler to set.
     */
    SaxesParser.prototype.on = function (name, handler) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
    };
    /**
     * Unset an event handler.
     *
     * @parma name The event to stop listening to.
     */
    SaxesParser.prototype.off = function (name) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;
    };
    /**
     * Make an error object. The error object will have a message that contains
     * the ``fileName`` option passed at the creation of the parser. If position
     * tracking was turned on, it will also have line and column number
     * information.
     *
     * @param message The message describing the error to report.
     *
     * @returns An error object with a properly formatted message.
     */
    SaxesParser.prototype.makeError = function (message) {
        var _a;
        var msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : '';
        if (this.trackPosition) {
            if (msg.length > 0) {
                msg += ':';
            }
            msg += "".concat(this.line, ":").concat(this.column);
        }
        if (msg.length > 0) {
            msg += ': ';
        }
        return new Error(msg + message);
    };
    /**
     * Report a parsing error. This method is made public so that client code may
     * check for issues that are outside the scope of this project and can report
     * errors.
     *
     * @param message The error to report.
     *
     * @returns this
     */
    SaxesParser.prototype.fail = function (message) {
        var err = this.makeError(message);
        var handler = this.errorHandler;
        if (handler === undefined) {
            throw err;
        }
        else {
            handler(err);
        }
        return this;
    };
    /**
     * Write a XML data to the parser.
     *
     * @param chunk The XML data to write.
     *
     * @returns this
     */
    // We do need object for the type here. Yes, it often causes problems
    // but not in this case.
    SaxesParser.prototype.write = function (chunk) {
        if (this.closed) {
            return this.fail('cannot write after close; assign an onready handler.');
        }
        var end = false;
        if (chunk === null) {
            // We cannot return immediately because carriedFromPrevious may need
            // processing.
            end = true;
            chunk = '';
        }
        else if (typeof chunk === 'object') {
            chunk = chunk.toString();
        }
        // We checked if performing a pre-decomposition of the string into an array
        // of single complete characters (``Array.from(chunk)``) would be faster
        // than the current repeated calls to ``charCodeAt``. As of August 2018, it
        // isn't. (There may be Node-specific code that would perform faster than
        // ``Array.from`` but don't want to be dependent on Node.)
        if (this.carriedFromPrevious !== undefined) {
            // The previous chunk had char we must carry over.
            chunk = "".concat(this.carriedFromPrevious).concat(chunk);
            this.carriedFromPrevious = undefined;
        }
        var limit = chunk.length;
        var lastCode = chunk.charCodeAt(limit - 1);
        if (!end &&
            // A trailing CR or surrogate must be carried over to the next
            // chunk.
            (lastCode === CR || (lastCode >= 0xd800 && lastCode <= 0xdbff))) {
            // The chunk ends with a character that must be carried over. We cannot
            // know how to handle it until we get the next chunk or the end of the
            // stream. So save it for later.
            this.carriedFromPrevious = chunk[limit - 1];
            limit--;
            chunk = chunk.slice(0, limit);
        }
        var stateTable = this.stateTable;
        this.chunk = chunk;
        this.i = 0;
        while (this.i < limit) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
            stateTable[this.state].call(this);
        }
        this.chunkPosition += limit;
        return end ? this.end() : this;
    };
    /**
     * Close the current stream. Perform final well-formedness checks and reset
     * the parser tstate.
     *
     * @returns this
     */
    SaxesParser.prototype.close = function () {
        return this.write(null);
    };
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.0.
     *
     * @returns The character read.
     */
    SaxesParser.prototype.getCode10 = function () {
        var _a = this, chunk = _a.chunk, i = _a.i;
        this.prevI = i;
        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
        // read this.i again, which is a bit faster.
        this.i = i + 1;
        if (i >= chunk.length) {
            return EOC;
        }
        // Using charCodeAt and handling the surrogates ourselves is faster
        // than using codePointAt.
        var code = chunk.charCodeAt(i);
        this.column++;
        if (code < 0xd800) {
            if (code >= SPACE || code === TAB) {
                return code;
            }
            switch (code) {
                case NL:
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL;
                case CR:
                    // We may get NaN if we read past the end of the chunk, which is fine.
                    if (chunk.charCodeAt(i + 1) === NL) {
                        // A \r\n sequence is converted to \n so we have to skip over the
                        // next character. We already know it has a size of 1 so ++ is fine
                        // here.
                        this.i = i + 2;
                    }
                    // Otherwise, a \r is just converted to \n, so we don't have to skip
                    // ahead.
                    // In either case, \r becomes \n.
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL_LIKE;
                default:
                    // If we get here, then code < SPACE and it is not NL CR or TAB.
                    this.fail('disallowed character.');
                    return code;
            }
        }
        if (code > 0xdbff) {
            // This is a specialized version of isChar10 that takes into account
            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not
            // test cases that don't need testing.
            if (!(code >= 0xe000 && code <= 0xfffd)) {
                this.fail('disallowed character.');
            }
            return code;
        }
        var final = 0x10000 + (code - 0xd800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xdc00);
        this.i = i + 2;
        // This is a specialized version of isChar10 that takes into account that in
        // this context necessarily final >= 0x10000.
        if (final > 0x10ffff) {
            this.fail('disallowed character.');
        }
        return final;
    };
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.1.
     *
     * @returns {number} The character read.
     */
    SaxesParser.prototype.getCode11 = function () {
        var _a = this, chunk = _a.chunk, i = _a.i;
        this.prevI = i;
        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
        // read this.i again, which is a bit faster.
        this.i = i + 1;
        if (i >= chunk.length) {
            return EOC;
        }
        // Using charCodeAt and handling the surrogates ourselves is faster
        // than using codePointAt.
        var code = chunk.charCodeAt(i);
        this.column++;
        if (code < 0xd800) {
            if ((code > 0x1f && code < 0x7f) ||
                (code > 0x9f && code !== LS) ||
                code === TAB) {
                return code;
            }
            switch (code) {
                case NL: // 0xA
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL;
                case CR: {
                    // 0xD
                    // We may get NaN if we read past the end of the chunk, which is
                    // fine.
                    var next = chunk.charCodeAt(i + 1);
                    if (next === NL || next === NEL) {
                        // A CR NL or CR NEL sequence is converted to NL so we have to skip
                        // over the next character. We already know it has a size of 1.
                        this.i = i + 2;
                    }
                    // Otherwise, a CR is just converted to NL, no skip.
                }
                /* yes, fall through */
                case NEL: // 0x85
                case LS: // Ox2028
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL_LIKE;
                default:
                    this.fail('disallowed character.');
                    return code;
            }
        }
        if (code > 0xdbff) {
            // This is a specialized version of isCharAndNotRestricted that takes into
            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it
            // does not test cases that don't need testing.
            if (!(code >= 0xe000 && code <= 0xfffd)) {
                this.fail('disallowed character.');
            }
            return code;
        }
        var final = 0x10000 + (code - 0xd800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xdc00);
        this.i = i + 2;
        // This is a specialized version of isCharAndNotRestricted that takes into
        // account that in this context necessarily final >= 0x10000.
        if (final > 0x10ffff) {
            this.fail('disallowed character.');
        }
        return final;
    };
    /**
     * Like ``getCode`` but with the return value normalized so that ``NL`` is
     * returned for ``NL_LIKE``.
     */
    SaxesParser.prototype.getCodeNorm = function () {
        var c = this.getCode();
        return c === NL_LIKE ? NL : c;
    };
    SaxesParser.prototype.unget = function () {
        this.i = this.prevI;
        this.column--;
    };
    /**
     * Capture characters into a buffer until encountering one of a set of
     * characters.
     *
     * @param chars An array of codepoints. Encountering a character in the array
     * ends the capture. (``chars`` may safely contain ``NL``.)
     *
     * @return The character code that made the capture end, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    SaxesParser.prototype.captureTo = function (chars) {
        var start = this.i;
        var chunk = this.chunk;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var c = this.getCode();
            var isNLLike = c === NL_LIKE;
            var final = isNLLike ? NL : c;
            if (final === EOC || chars.includes(final)) {
                this.text += chunk.slice(start, this.prevI);
                return final;
            }
            if (isNLLike) {
                this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                start = this.i;
            }
        }
    };
    /**
     * Capture characters into a buffer until encountering a character.
     *
     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
     *
     * @return ``true`` if we ran into the character. Otherwise, we ran into the
     * end of the current chunk.
     */
    SaxesParser.prototype.captureToChar = function (char) {
        var start = this.i;
        var chunk = this.chunk;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var c = this.getCode();
            switch (c) {
                case NL_LIKE:
                    this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                    start = this.i;
                    c = NL;
                    break;
                case EOC:
                    this.text += chunk.slice(start);
                    return false;
            }
            if (c === char) {
                this.text += chunk.slice(start, this.prevI);
                return true;
            }
        }
    };
    /**
     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
     * this parser.
     *
     * @return The character code that made the test fail, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    SaxesParser.prototype.captureNameChars = function () {
        var _a = this, chunk = _a.chunk, start = _a.i;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var c = this.getCode();
            if (c === EOC) {
                this.name += chunk.slice(start);
                return EOC;
            }
            // NL is not a name char so we don't have to test specifically for it.
            if (!isNameChar(c)) {
                this.name += chunk.slice(start, this.prevI);
                return c === NL_LIKE ? NL : c;
            }
        }
    };
    /**
     * Skip white spaces.
     *
     * @return The character that ended the skip, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    SaxesParser.prototype.skipSpaces = function () {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var c = this.getCodeNorm();
            if (c === EOC || !isS(c)) {
                return c;
            }
        }
    };
    SaxesParser.prototype.setXMLVersion = function (version) {
        this.currentXMLVersion = version;
        /*  eslint-disable @typescript-eslint/unbound-method */
        if (version === '1.0') {
            this.isChar = isChar10;
            this.getCode = this.getCode10;
        }
        else {
            this.isChar = isChar11;
            this.getCode = this.getCode11;
        }
        /* eslint-enable @typescript-eslint/unbound-method */
    };
    // STATE ENGINE METHODS
    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
    // to be sure never to come back to this state later.
    SaxesParser.prototype.sBegin = function () {
        // We are essentially peeking at the first character of the chunk. Since
        // S_BEGIN can be in effect only when we start working on the first chunk,
        // the index at which we must look is necessarily 0. Note also that the
        // following test does not depend on decoding surrogates.
        // If the initial character is 0xFEFF, ignore it.
        if (this.chunk.charCodeAt(0) === 0xfeff) {
            this.i++;
            this.column++;
        }
        this.state = S_BEGIN_WHITESPACE;
    };
    SaxesParser.prototype.sBeginWhitespace = function () {
        // We need to know whether we've encountered spaces or not because as soon
        // as we run into a space, an XML declaration is no longer possible. Rather
        // than slow down skipSpaces even in places where we don't care whether it
        // skipped anything or not, we check whether prevI is equal to the value of
        // i from before we skip spaces.
        var iBefore = this.i;
        var c = this.skipSpaces();
        if (this.prevI !== iBefore) {
            this.xmlDeclPossible = false;
        }
        switch (c) {
            case LESS:
                this.state = S_OPEN_WAKA;
                // We could naively call closeText but in this state, it is not normal
                // to have text be filled with any data.
                if (this.text.length !== 0) {
                    throw new Error('no-empty text at start');
                }
                break;
            case EOC:
                break;
            default:
                this.unget();
                this.state = S_TEXT;
                this.xmlDeclPossible = false;
        }
    };
    SaxesParser.prototype.sDoctype = function () {
        var _a;
        var c = this.captureTo(DOCTYPE_TERMINATOR);
        switch (c) {
            case GREATER: {
                (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                this.text = '';
                this.state = S_TEXT;
                this.doctype = true; // just remember that we saw it.
                break;
            }
            case EOC:
                break;
            default:
                this.text += String.fromCodePoint(c);
                if (c === OPEN_BRACKET) {
                    this.state = S_DTD;
                }
                else if (isQuote(c)) {
                    this.state = S_DOCTYPE_QUOTE;
                    this.q = c;
                }
        }
    };
    SaxesParser.prototype.sDoctypeQuote = function () {
        var q = this.q;
        if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.q = null;
            this.state = S_DOCTYPE;
        }
    };
    SaxesParser.prototype.sDTD = function () {
        var c = this.captureTo(DTD_TERMINATOR);
        if (c === EOC) {
            return;
        }
        this.text += String.fromCodePoint(c);
        if (c === CLOSE_BRACKET) {
            this.state = S_DOCTYPE;
        }
        else if (c === LESS) {
            this.state = S_DTD_OPEN_WAKA;
        }
        else if (isQuote(c)) {
            this.state = S_DTD_QUOTED;
            this.q = c;
        }
    };
    SaxesParser.prototype.sDTDQuoted = function () {
        var q = this.q;
        if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.state = S_DTD;
            this.q = null;
        }
    };
    SaxesParser.prototype.sDTDOpenWaka = function () {
        var c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        switch (c) {
            case BANG:
                this.state = S_DTD_OPEN_WAKA_BANG;
                this.openWakaBang = '';
                break;
            case QUESTION:
                this.state = S_DTD_PI;
                break;
            default:
                this.state = S_DTD;
        }
    };
    SaxesParser.prototype.sDTDOpenWakaBang = function () {
        var char = String.fromCodePoint(this.getCodeNorm());
        var owb = (this.openWakaBang += char);
        this.text += char;
        if (owb !== '-') {
            this.state = owb === '--' ? S_DTD_COMMENT : S_DTD;
            this.openWakaBang = '';
        }
    };
    SaxesParser.prototype.sDTDComment = function () {
        if (this.captureToChar(MINUS)) {
            this.text += '-';
            this.state = S_DTD_COMMENT_ENDING;
        }
    };
    SaxesParser.prototype.sDTDCommentEnding = function () {
        var c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
    };
    SaxesParser.prototype.sDTDCommentEnded = function () {
        var c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
            this.state = S_DTD;
        }
        else {
            this.fail('malformed comment.');
            // <!-- blah -- bloo --> will be recorded as
            // a comment of " blah -- bloo "
            this.state = S_DTD_COMMENT;
        }
    };
    SaxesParser.prototype.sDTDPI = function () {
        if (this.captureToChar(QUESTION)) {
            this.text += '?';
            this.state = S_DTD_PI_ENDING;
        }
    };
    SaxesParser.prototype.sDTDPIEnding = function () {
        var c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
            this.state = S_DTD;
        }
    };
    SaxesParser.prototype.sText = function () {
        //
        // We did try a version of saxes where the S_TEXT state was split in two
        // states: one for text inside the root element, and one for text
        // outside. This was avoiding having to test this.tags.length to decide
        // what implementation to actually use.
        //
        // Peformance testing on gigabyte-size files did not show any advantage to
        // using the two states solution instead of the current one. Conversely, it
        // made the code a bit more complicated elsewhere. For instance, a comment
        // can appear before the root element so when a comment ended it was
        // necessary to determine whether to return to the S_TEXT state or to the
        // new text-outside-root state.
        //
        if (this.tags.length !== 0) {
            this.handleTextInRoot();
        }
        else {
            this.handleTextOutsideRoot();
        }
    };
    SaxesParser.prototype.sEntity = function () {
        // This is essentially a specialized version of captureToChar(SEMICOLON...)
        var start = this.i;
        var chunk = this.chunk;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        // eslint-disable-next-line no-constant-condition
        loop: while (true) {
            switch (this.getCode()) {
                case NL_LIKE:
                    this.entity += "".concat(chunk.slice(start, this.prevI), "\n");
                    start = this.i;
                    break;
                case SEMICOLON: {
                    var entityReturnState = this.entityReturnState;
                    var entity = this.entity + chunk.slice(start, this.prevI);
                    this.state = entityReturnState;
                    var parsed = void 0;
                    if (entity === '') {
                        this.fail('empty entity name.');
                        parsed = '&;';
                    }
                    else {
                        parsed = this.parseEntity(entity);
                        this.entity = '';
                    }
                    if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {
                        this.text += parsed;
                    }
                    // eslint-disable-next-line no-labels
                    break loop;
                }
                case EOC:
                    this.entity += chunk.slice(start);
                    // eslint-disable-next-line no-labels
                    break loop;
            }
        }
    };
    SaxesParser.prototype.sOpenWaka = function () {
        // Reminder: a state handler is called with at least one character
        // available in the current chunk. So the first call to get code inside of
        // a state handler cannot return ``EOC``. That's why we don't test
        // for it.
        var c = this.getCode();
        // either a /, ?, !, or text is coming next.
        if (isNameStartChar(c)) {
            this.state = S_OPEN_TAG;
            this.unget();
            this.xmlDeclPossible = false;
        }
        else {
            switch (c) {
                case FORWARD_SLASH:
                    this.state = S_CLOSE_TAG;
                    this.xmlDeclPossible = false;
                    break;
                case BANG:
                    this.state = S_OPEN_WAKA_BANG;
                    this.openWakaBang = '';
                    this.xmlDeclPossible = false;
                    break;
                case QUESTION:
                    this.state = S_PI_FIRST_CHAR;
                    break;
                default:
                    this.fail('disallowed character in tag name');
                    this.state = S_TEXT;
                    this.xmlDeclPossible = false;
            }
        }
    };
    SaxesParser.prototype.sOpenWakaBang = function () {
        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
        switch (this.openWakaBang) {
            case '[CDATA[':
                if (!this.sawRoot && !this.reportedTextBeforeRoot) {
                    this.fail('text data outside of root node.');
                    this.reportedTextBeforeRoot = true;
                }
                if (this.closedRoot && !this.reportedTextAfterRoot) {
                    this.fail('text data outside of root node.');
                    this.reportedTextAfterRoot = true;
                }
                this.state = S_CDATA;
                this.openWakaBang = '';
                break;
            case '--':
                this.state = S_COMMENT;
                this.openWakaBang = '';
                break;
            case 'DOCTYPE':
                this.state = S_DOCTYPE;
                if (this.doctype || this.sawRoot) {
                    this.fail('inappropriately located doctype declaration.');
                }
                this.openWakaBang = '';
                break;
            default:
                // 7 happens to be the maximum length of the string that can possibly
                // match one of the cases above.
                if (this.openWakaBang.length >= 7) {
                    this.fail('incorrect syntax.');
                }
        }
    };
    SaxesParser.prototype.sComment = function () {
        if (this.captureToChar(MINUS)) {
            this.state = S_COMMENT_ENDING;
        }
    };
    SaxesParser.prototype.sCommentEnding = function () {
        var _a;
        var c = this.getCodeNorm();
        if (c === MINUS) {
            this.state = S_COMMENT_ENDED;
            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = '';
        }
        else {
            this.text += "-".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
        }
    };
    SaxesParser.prototype.sCommentEnded = function () {
        var c = this.getCodeNorm();
        if (c !== GREATER) {
            this.fail('malformed comment.');
            // <!-- blah -- bloo --> will be recorded as
            // a comment of " blah -- bloo "
            this.text += "--".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
        }
        else {
            this.state = S_TEXT;
        }
    };
    SaxesParser.prototype.sCData = function () {
        if (this.captureToChar(CLOSE_BRACKET)) {
            this.state = S_CDATA_ENDING;
        }
    };
    SaxesParser.prototype.sCDataEnding = function () {
        var c = this.getCodeNorm();
        if (c === CLOSE_BRACKET) {
            this.state = S_CDATA_ENDING_2;
        }
        else {
            this.text += "]".concat(String.fromCodePoint(c));
            this.state = S_CDATA;
        }
    };
    SaxesParser.prototype.sCDataEnding2 = function () {
        var _a;
        var c = this.getCodeNorm();
        switch (c) {
            case GREATER: {
                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                this.text = '';
                this.state = S_TEXT;
                break;
            }
            case CLOSE_BRACKET:
                this.text += ']';
                break;
            default:
                this.text += "]]".concat(String.fromCodePoint(c));
                this.state = S_CDATA;
        }
    };
    // We need this separate state to check the first character fo the pi target
    // with this.nameStartCheck which allows less characters than this.nameCheck.
    SaxesParser.prototype.sPIFirstChar = function () {
        var c = this.getCodeNorm();
        // This is first because in the case where the file is well-formed this is
        // the branch taken. We optimize for well-formedness.
        if (this.nameStartCheck(c)) {
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
        }
        else if (c === QUESTION || isS(c)) {
            this.fail('processing instruction without a target.');
            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
        }
        else {
            this.fail('disallowed character in processing instruction name.');
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
        }
    };
    SaxesParser.prototype.sPIRest = function () {
        // Capture characters into a piTarget while ``this.nameCheck`` run on the
        // character read returns true.
        var _a = this, chunk = _a.chunk, start = _a.i;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            var c = this.getCodeNorm();
            if (c === EOC) {
                this.piTarget += chunk.slice(start);
                return;
            }
            // NL cannot satisfy this.nameCheck so we don't have to test specifically
            // for it.
            if (!this.nameCheck(c)) {
                this.piTarget += chunk.slice(start, this.prevI);
                var isQuestion = c === QUESTION;
                if (isQuestion || isS(c)) {
                    if (this.piTarget === 'xml') {
                        if (!this.xmlDeclPossible) {
                            this.fail('an XML declaration must be at the start of the document.');
                        }
                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
                    }
                    else {
                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
                    }
                }
                else {
                    this.fail('disallowed character in processing instruction name.');
                    this.piTarget += String.fromCodePoint(c);
                }
                break;
            }
        }
    };
    SaxesParser.prototype.sPIBody = function () {
        if (this.text.length === 0) {
            var c = this.getCodeNorm();
            if (c === QUESTION) {
                this.state = S_PI_ENDING;
            }
            else if (!isS(c)) {
                this.text = String.fromCodePoint(c);
            }
        }
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        else if (this.captureToChar(QUESTION)) {
            this.state = S_PI_ENDING;
        }
    };
    SaxesParser.prototype.sPIEnding = function () {
        var _a;
        var c = this.getCodeNorm();
        if (c === GREATER) {
            var piTarget = this.piTarget;
            if (piTarget.toLowerCase() === 'xml') {
                this.fail('the XML declaration must appear at the start of the document.');
            }
            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
                target: piTarget,
                body: this.text
            });
            this.piTarget = this.text = '';
            this.state = S_TEXT;
        }
        else if (c === QUESTION) {
            // We ran into ?? as part of a processing instruction. We initially took
            // the first ? as a sign that the PI was ending, but it is not. So we have
            // to add it to the body but we take the new ? as a sign that the PI is
            // ending.
            this.text += '?';
        }
        else {
            this.text += "?".concat(String.fromCodePoint(c));
            this.state = S_PI_BODY;
        }
        this.xmlDeclPossible = false;
    };
    SaxesParser.prototype.sXMLDeclNameStart = function () {
        var c = this.skipSpaces();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            // It is valid to go to S_XML_DECL_ENDING from this state.
            this.state = S_XML_DECL_ENDING;
            return;
        }
        if (c !== EOC) {
            this.state = S_XML_DECL_NAME;
            this.name = String.fromCodePoint(c);
        }
    };
    SaxesParser.prototype.sXMLDeclName = function () {
        var c = this.captureTo(XML_DECL_NAME_TERMINATOR);
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.name += this.text;
            this.text = '';
            this.fail('XML declaration is incomplete.');
            return;
        }
        if (!(isS(c) || c === EQUAL)) {
            return;
        }
        this.name += this.text;
        this.text = '';
        if (!this.xmlDeclExpects.includes(this.name)) {
            switch (this.name.length) {
                case 0:
                    this.fail('did not expect any more name/value pairs.');
                    break;
                case 1:
                    this.fail("expected the name ".concat(this.xmlDeclExpects[0], "."));
                    break;
                default:
                    this.fail("expected one of ".concat(this.xmlDeclExpects.join(', ')));
            }
        }
        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
    };
    SaxesParser.prototype.sXMLDeclEq = function () {
        var c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail('XML declaration is incomplete.');
            return;
        }
        if (isS(c)) {
            return;
        }
        if (c !== EQUAL) {
            this.fail('value required.');
        }
        this.state = S_XML_DECL_VALUE_START;
    };
    SaxesParser.prototype.sXMLDeclValueStart = function () {
        var c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail('XML declaration is incomplete.');
            return;
        }
        if (isS(c)) {
            return;
        }
        if (!isQuote(c)) {
            this.fail('value must be quoted.');
            this.q = SPACE;
        }
        else {
            this.q = c;
        }
        this.state = S_XML_DECL_VALUE;
    };
    SaxesParser.prototype.sXMLDeclValue = function () {
        var c = this.captureTo([this.q, QUESTION]);
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.text = '';
            this.fail('XML declaration is incomplete.');
            return;
        }
        if (c === EOC) {
            return;
        }
        var value = this.text;
        this.text = '';
        switch (this.name) {
            case 'version': {
                this.xmlDeclExpects = ['encoding', 'standalone'];
                var version = value;
                this.xmlDecl.version = version;
                // This is the test specified by XML 1.0 but it is fine for XML 1.1.
                if (!/^1\.[0-9]+$/.test(version)) {
                    this.fail('version number must match /^1\\.[0-9]+$/.');
                }
                // When forceXMLVersion is set, the XML declaration is ignored.
                else if (!this.opt.forceXMLVersion) {
                    this.setXMLVersion(version);
                }
                break;
            }
            case 'encoding':
                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
                    this.fail('encoding value must match \
/^[A-Za-z0-9][A-Za-z0-9._-]*$/.');
                }
                this.xmlDeclExpects = ['standalone'];
                this.xmlDecl.encoding = value;
                break;
            case 'standalone':
                if (value !== 'yes' && value !== 'no') {
                    this.fail('standalone value must match "yes" or "no".');
                }
                this.xmlDeclExpects = [];
                this.xmlDecl.standalone = value;
                break;
            // We don't need to raise an error here since we've already raised one
            // when checking what name was expected.
        }
        this.name = '';
        this.state = S_XML_DECL_SEPARATOR;
    };
    SaxesParser.prototype.sXMLDeclSeparator = function () {
        var c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            // It is valid to go to S_XML_DECL_ENDING from this state.
            this.state = S_XML_DECL_ENDING;
            return;
        }
        if (!isS(c)) {
            this.fail('whitespace required.');
            this.unget();
        }
        this.state = S_XML_DECL_NAME_START;
    };
    SaxesParser.prototype.sXMLDeclEnding = function () {
        var _a;
        var c = this.getCodeNorm();
        if (c === GREATER) {
            if (this.piTarget !== 'xml') {
                this.fail('processing instructions are not allowed before root.');
            }
            else if (this.name !== 'version' &&
                this.xmlDeclExpects.includes('version')) {
                this.fail('XML declaration must contain a version.');
            }
            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
            this.name = '';
            this.piTarget = this.text = '';
            this.state = S_TEXT;
        }
        else {
            // We got here because the previous character was a ?, but the question
            // mark character is not valid inside any of the XML declaration
            // name/value pairs.
            this.fail('The character ? is disallowed anywhere in XML declarations.');
        }
        this.xmlDeclPossible = false;
    };
    SaxesParser.prototype.sOpenTag = function () {
        var _a;
        var c = this.captureNameChars();
        if (c === EOC) {
            return;
        }
        var tag = (this.tag = {
            name: this.name,
            attributes: Object.create(null)
        });
        this.name = '';
        if (this.xmlnsOpt) {
            this.topNS = tag.ns = Object.create(null);
        }
        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        this.sawRoot = true;
        if (!this.fragmentOpt && this.closedRoot) {
            this.fail('documents may contain only one root.');
        }
        switch (c) {
            case GREATER:
                this.openTag();
                break;
            case FORWARD_SLASH:
                this.state = S_OPEN_TAG_SLASH;
                break;
            default:
                if (!isS(c)) {
                    this.fail('disallowed character in tag name.');
                }
                this.state = S_ATTRIB;
        }
    };
    SaxesParser.prototype.sOpenTagSlash = function () {
        if (this.getCode() === GREATER) {
            this.openSelfClosingTag();
        }
        else {
            this.fail('forward-slash in opening tag not followed by >.');
            this.state = S_ATTRIB;
        }
    };
    SaxesParser.prototype.sAttrib = function () {
        var c = this.skipSpaces();
        if (c === EOC) {
            return;
        }
        if (isNameStartChar(c)) {
            this.unget();
            this.state = S_ATTRIB_NAME;
        }
        else if (c === GREATER) {
            this.openTag();
        }
        else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
        }
        else {
            this.fail('disallowed character in attribute name.');
        }
    };
    SaxesParser.prototype.sAttribName = function () {
        var c = this.captureNameChars();
        if (c === EQUAL) {
            this.state = S_ATTRIB_VALUE;
        }
        else if (isS(c)) {
            this.state = S_ATTRIB_NAME_SAW_WHITE;
        }
        else if (c === GREATER) {
            this.fail('attribute without value.');
            this.pushAttrib(this.name, this.name);
            this.name = this.text = '';
            this.openTag();
        }
        else if (c !== EOC) {
            this.fail('disallowed character in attribute name.');
        }
    };
    SaxesParser.prototype.sAttribNameSawWhite = function () {
        var c = this.skipSpaces();
        switch (c) {
            case EOC:
                return;
            case EQUAL:
                this.state = S_ATTRIB_VALUE;
                break;
            default:
                this.fail('attribute without value.');
                // Should we do this???
                // this.tag.attributes[this.name] = "";
                this.text = '';
                this.name = '';
                if (c === GREATER) {
                    this.openTag();
                }
                else if (isNameStartChar(c)) {
                    this.unget();
                    this.state = S_ATTRIB_NAME;
                }
                else {
                    this.fail('disallowed character in attribute name.');
                    this.state = S_ATTRIB;
                }
        }
    };
    SaxesParser.prototype.sAttribValue = function () {
        var c = this.getCodeNorm();
        if (isQuote(c)) {
            this.q = c;
            this.state = S_ATTRIB_VALUE_QUOTED;
        }
        else if (!isS(c)) {
            this.fail('unquoted attribute value.');
            this.state = S_ATTRIB_VALUE_UNQUOTED;
            this.unget();
        }
    };
    SaxesParser.prototype.sAttribValueQuoted = function () {
        // We deliberately do not use captureTo here. The specialized code we use
        // here is faster than using captureTo.
        var _a = this, q = _a.q, chunk = _a.chunk;
        var start = this.i;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            switch (this.getCode()) {
                case q:
                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
                    this.name = this.text = '';
                    this.q = null;
                    this.state = S_ATTRIB_VALUE_CLOSED;
                    return;
                case AMP:
                    this.text += chunk.slice(start, this.prevI);
                    this.state = S_ENTITY;
                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
                    return;
                case NL:
                case NL_LIKE:
                case TAB:
                    this.text += "".concat(chunk.slice(start, this.prevI), " ");
                    start = this.i;
                    break;
                case LESS:
                    this.text += chunk.slice(start, this.prevI);
                    this.fail('disallowed character.');
                    return;
                case EOC:
                    this.text += chunk.slice(start);
                    return;
            }
        }
    };
    SaxesParser.prototype.sAttribValueClosed = function () {
        var c = this.getCodeNorm();
        if (isS(c)) {
            this.state = S_ATTRIB;
        }
        else if (c === GREATER) {
            this.openTag();
        }
        else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
        }
        else if (isNameStartChar(c)) {
            this.fail('no whitespace between attributes.');
            this.unget();
            this.state = S_ATTRIB_NAME;
        }
        else {
            this.fail('disallowed character in attribute name.');
        }
    };
    SaxesParser.prototype.sAttribValueUnquoted = function () {
        // We don't do anything regarding EOL or space handling for unquoted
        // attributes. We already have failed by the time we get here, and the
        // contract that saxes upholds states that upon failure, it is not safe to
        // rely on the data passed to event handlers (other than
        // ``onerror``). Passing "bad" data is not a problem.
        var c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
        switch (c) {
            case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
                break;
            case LESS:
                this.fail('disallowed character.');
                break;
            case EOC:
                break;
            default:
                if (this.text.includes(']]>')) {
                    this.fail('the string "]]>" is disallowed in char data.');
                }
                this.pushAttrib(this.name, this.text);
                this.name = this.text = '';
                if (c === GREATER) {
                    this.openTag();
                }
                else {
                    this.state = S_ATTRIB;
                }
        }
    };
    SaxesParser.prototype.sCloseTag = function () {
        var c = this.captureNameChars();
        if (c === GREATER) {
            this.closeTag();
        }
        else if (isS(c)) {
            this.state = S_CLOSE_TAG_SAW_WHITE;
        }
        else if (c !== EOC) {
            this.fail('disallowed character in closing tag.');
        }
    };
    SaxesParser.prototype.sCloseTagSawWhite = function () {
        switch (this.skipSpaces()) {
            case GREATER:
                this.closeTag();
                break;
            case EOC:
                break;
            default:
                this.fail('disallowed character in closing tag.');
        }
    };
    // END OF STATE ENGINE METHODS
    SaxesParser.prototype.handleTextInRoot = function () {
        // This is essentially a specialized version of captureTo which is optimized
        // for performing the ]]> check. A previous version of this code, checked
        // ``this.text`` for the presence of ]]>. It simplified the code but was
        // very costly when character data contained a lot of entities to be parsed.
        //
        // Since we are using a specialized loop, we also keep track of the presence
        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.
        //
        var _a = this, start = _a.i, forbiddenState = _a.forbiddenState;
        var _b = this, chunk = _b.chunk, handler = _b.textHandler;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        // eslint-disable-next-line no-constant-condition
        scanLoop: while (true) {
            switch (this.getCode()) {
                case LESS: {
                    this.state = S_OPEN_WAKA;
                    if (handler !== undefined) {
                        var text = this.text;
                        var slice = chunk.slice(start, this.prevI);
                        if (text.length !== 0) {
                            handler(text + slice);
                            this.text = '';
                        }
                        else if (slice.length !== 0) {
                            handler(slice);
                        }
                    }
                    forbiddenState = FORBIDDEN_START;
                    // eslint-disable-next-line no-labels
                    break scanLoop;
                }
                case AMP:
                    this.state = S_ENTITY;
                    this.entityReturnState = S_TEXT;
                    if (handler !== undefined) {
                        this.text += chunk.slice(start, this.prevI);
                    }
                    forbiddenState = FORBIDDEN_START;
                    // eslint-disable-next-line no-labels
                    break scanLoop;
                case CLOSE_BRACKET:
                    switch (forbiddenState) {
                        case FORBIDDEN_START:
                            forbiddenState = FORBIDDEN_BRACKET;
                            break;
                        case FORBIDDEN_BRACKET:
                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                            break;
                        case FORBIDDEN_BRACKET_BRACKET:
                            break;
                        default:
                            throw new Error('impossible state');
                    }
                    break;
                case GREATER:
                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                        this.fail('the string "]]>" is disallowed in char data.');
                    }
                    forbiddenState = FORBIDDEN_START;
                    break;
                case NL_LIKE:
                    if (handler !== undefined) {
                        this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                    }
                    start = this.i;
                    forbiddenState = FORBIDDEN_START;
                    break;
                case EOC:
                    if (handler !== undefined) {
                        this.text += chunk.slice(start);
                    }
                    // eslint-disable-next-line no-labels
                    break scanLoop;
                default:
                    forbiddenState = FORBIDDEN_START;
            }
        }
        this.forbiddenState = forbiddenState;
    };
    SaxesParser.prototype.handleTextOutsideRoot = function () {
        // This is essentially a specialized version of captureTo which is optimized
        // for a specialized task. We keep track of the presence of non-space
        // characters in the text since these are errors when appearing outside the
        // document root element.
        var start = this.i;
        var _a = this, chunk = _a.chunk, handler = _a.textHandler;
        var nonSpace = false;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        // eslint-disable-next-line no-constant-condition
        outRootLoop: while (true) {
            var code = this.getCode();
            switch (code) {
                case LESS: {
                    this.state = S_OPEN_WAKA;
                    if (handler !== undefined) {
                        var text = this.text;
                        var slice = chunk.slice(start, this.prevI);
                        if (text.length !== 0) {
                            handler(text + slice);
                            this.text = '';
                        }
                        else if (slice.length !== 0) {
                            handler(slice);
                        }
                    }
                    // eslint-disable-next-line no-labels
                    break outRootLoop;
                }
                case AMP:
                    this.state = S_ENTITY;
                    this.entityReturnState = S_TEXT;
                    if (handler !== undefined) {
                        this.text += chunk.slice(start, this.prevI);
                    }
                    nonSpace = true;
                    // eslint-disable-next-line no-labels
                    break outRootLoop;
                case NL_LIKE:
                    if (handler !== undefined) {
                        this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                    }
                    start = this.i;
                    break;
                case EOC:
                    if (handler !== undefined) {
                        this.text += chunk.slice(start);
                    }
                    // eslint-disable-next-line no-labels
                    break outRootLoop;
                default:
                    if (!isS(code)) {
                        nonSpace = true;
                    }
            }
        }
        if (!nonSpace) {
            return;
        }
        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags
        // to avoid reporting errors for every single character that is out of
        // place.
        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
            this.fail('text data outside of root node.');
            this.reportedTextBeforeRoot = true;
        }
        if (this.closedRoot && !this.reportedTextAfterRoot) {
            this.fail('text data outside of root node.');
            this.reportedTextAfterRoot = true;
        }
    };
    SaxesParser.prototype.pushAttribNS = function (name, value) {
        var _a;
        var _b = this.qname(name), prefix = _b.prefix, local = _b.local;
        var attr = { name: name, prefix: prefix, local: local, value: value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
        if (prefix === 'xmlns') {
            var trimmed = value.trim();
            if (this.currentXMLVersion === '1.0' && trimmed === '') {
                this.fail('invalid attempt to undefine prefix in XML 1.0');
            }
            this.topNS[local] = trimmed;
            nsPairCheck(this, local, trimmed);
        }
        else if (name === 'xmlns') {
            var trimmed = value.trim();
            this.topNS[''] = trimmed;
            nsPairCheck(this, '', trimmed);
        }
    };
    SaxesParser.prototype.pushAttribPlain = function (name, value) {
        var _a;
        var attr = { name: name, value: value };
        this.attribList.push(attr);
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
    };
    /**
     * End parsing. This performs final well-formedness checks and resets the
     * parser to a clean state.
     *
     * @returns this
     */
    SaxesParser.prototype.end = function () {
        var _a, _b;
        if (!this.sawRoot) {
            this.fail('document must contain a root element.');
        }
        var tags = this.tags;
        while (tags.length > 0) {
            var tag = tags.pop();
            this.fail("unclosed tag: ".concat(tag.name));
        }
        if (this.state !== S_BEGIN && this.state !== S_TEXT) {
            this.fail('unexpected end.');
        }
        var text = this.text;
        if (text.length !== 0) {
            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
            this.text = '';
        }
        this._closed = true;
        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
        this._init();
        return this;
    };
    /**
     * Resolve a namespace prefix.
     *
     * @param prefix The prefix to resolve.
     *
     * @returns The namespace URI or ``undefined`` if the prefix is not defined.
     */
    SaxesParser.prototype.resolve = function (prefix) {
        var _a, _b;
        var uri = this.topNS[prefix];
        if (uri !== undefined) {
            return uri;
        }
        var tags = this.tags;
        for (var index = tags.length - 1; index >= 0; index--) {
            uri = tags[index].ns[prefix];
            if (uri !== undefined) {
                return uri;
            }
        }
        uri = this.ns[prefix];
        if (uri !== undefined) {
            return uri;
        }
        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
    };
    /**
     * Parse a qname into its prefix and local name parts.
     *
     * @param name The name to parse
     *
     * @returns
     */
    SaxesParser.prototype.qname = function (name) {
        // This is faster than using name.split(":").
        var colon = name.indexOf(':');
        if (colon === -1) {
            return { prefix: '', local: name };
        }
        var local = name.slice(colon + 1);
        var prefix = name.slice(0, colon);
        if (prefix === '' || local === '' || local.includes(':')) {
            this.fail("malformed name: ".concat(name, "."));
        }
        return { prefix: prefix, local: local };
    };
    SaxesParser.prototype.processAttribsNS = function () {
        var e_2, _a;
        var _b;
        var attribList = this.attribList;
        var tag = this.tag;
        {
            // add namespace info to tag
            var _c = this.qname(tag.name), prefix = _c.prefix, local = _c.local;
            tag.prefix = prefix;
            tag.local = local;
            var uri = (tag.uri = (_b = this.resolve(prefix)) !== null && _b !== void 0 ? _b : '');
            if (prefix !== '') {
                if (prefix === 'xmlns') {
                    this.fail('tags may not have "xmlns" as prefix.');
                }
                if (uri === '') {
                    this.fail("unbound namespace prefix: ".concat(JSON.stringify(prefix), "."));
                    tag.uri = prefix;
                }
            }
        }
        if (attribList.length === 0) {
            return;
        }
        var attributes = tag.attributes;
        var seen = new Set();
        try {
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for (var _d = __values(attribList), _e = _d.next(); !_e.done; _e = _d.next()) {
                var attr = _e.value;
                var name_1 = attr.name, prefix = attr.prefix, local = attr.local;
                var uri = void 0;
                var eqname = void 0;
                if (prefix === '') {
                    uri = name_1 === 'xmlns' ? XMLNS_NAMESPACE : '';
                    eqname = name_1;
                }
                else {
                    uri = this.resolve(prefix);
                    // if there's any attributes with an undefined namespace,
                    // then fail on them now.
                    if (uri === undefined) {
                        this.fail("unbound namespace prefix: ".concat(JSON.stringify(prefix), "."));
                        uri = prefix;
                    }
                    eqname = "{".concat(uri, "}").concat(local);
                }
                if (seen.has(eqname)) {
                    this.fail("duplicate attribute: ".concat(eqname, "."));
                }
                seen.add(eqname);
                attr.uri = uri;
                attributes[name_1] = attr;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.attribList = [];
    };
    SaxesParser.prototype.processAttribsPlain = function () {
        var e_3, _a;
        var attribList = this.attribList;
        // eslint-disable-next-line prefer-destructuring
        var attributes = this.tag.attributes;
        try {
            for (var attribList_1 = __values(attribList), attribList_1_1 = attribList_1.next(); !attribList_1_1.done; attribList_1_1 = attribList_1.next()) {
                var _b = attribList_1_1.value, name_2 = _b.name, value = _b.value;
                if (attributes[name_2] !== undefined) {
                    this.fail("duplicate attribute: ".concat(name_2, "."));
                }
                attributes[name_2] = value;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (attribList_1_1 && !attribList_1_1.done && (_a = attribList_1.return)) _a.call(attribList_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        this.attribList = [];
    };
    /**
     * Handle a complete open tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onopentag``.
     */
    SaxesParser.prototype.openTag = function () {
        var _a;
        this.processAttribs();
        var tags = this.tags;
        var tag = this.tag;
        tag.isSelfClosing = false;
        // There cannot be any pending text here due to the onopentagstart that was
        // necessarily emitted before we get here. So we do not check text.
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        tags.push(tag);
        this.state = S_TEXT;
        this.name = '';
    };
    /**
     * Handle a complete self-closing tag. This parser code calls this once it has
     * seen the whole tag. This method checks for well-formeness and then emits
     * ``onopentag`` and ``onclosetag``.
     */
    SaxesParser.prototype.openSelfClosingTag = function () {
        var _a, _b, _c;
        this.processAttribs();
        var tags = this.tags;
        var tag = this.tag;
        tag.isSelfClosing = true;
        // There cannot be any pending text here due to the onopentagstart that was
        // necessarily emitted before we get here. So we do not check text.
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
        var top = (this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null);
        if (top === null) {
            this.closedRoot = true;
        }
        this.state = S_TEXT;
        this.name = '';
    };
    /**
     * Handle a complete close tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onclosetag``.
     */
    SaxesParser.prototype.closeTag = function () {
        var _a = this, tags = _a.tags, name = _a.name;
        // Our state after this will be S_TEXT, no matter what, and we can clear
        // tagName now.
        this.state = S_TEXT;
        this.name = '';
        if (name === '') {
            this.fail('weird empty close tag.');
            this.text += '</>';
            return;
        }
        var handler = this.closeTagHandler;
        var l = tags.length;
        while (l-- > 0) {
            var tag = (this.tag = tags.pop());
            this.topNS = tag.ns;
            handler === null || handler === void 0 ? void 0 : handler(tag);
            if (tag.name === name) {
                break;
            }
            this.fail('unexpected close tag.');
        }
        if (l === 0) {
            this.closedRoot = true;
        }
        else if (l < 0) {
            this.fail("unmatched closing tag: ".concat(name, "."));
            this.text += "</".concat(name, ">");
        }
    };
    /**
     * Resolves an entity. Makes any necessary well-formedness checks.
     *
     * @param entity The entity to resolve.
     *
     * @returns The parsed entity.
     */
    SaxesParser.prototype.parseEntity = function (entity) {
        // startsWith would be significantly slower for this test.
        if (entity[0] !== '#') {
            var defined = this.ENTITIES[entity];
            if (defined !== undefined) {
                return defined;
            }
            this.fail(this.isName(entity)
                ? 'undefined entity.'
                : 'disallowed character in entity name.');
            return "&".concat(entity, ";");
        }
        var num = NaN;
        if (entity[1] === 'x' && /^#x[0-9a-f]+$/i.test(entity)) {
            num = parseInt(entity.slice(2), 16);
        }
        else if (/^#[0-9]+$/.test(entity)) {
            num = parseInt(entity.slice(1), 10);
        }
        // The character reference is required to match the CHAR production.
        if (!this.isChar(num)) {
            this.fail('malformed character entity.');
            return "&".concat(entity, ";");
        }
        return String.fromCodePoint(num);
    };
    return SaxesParser;
}());

export { SaxesParser };
