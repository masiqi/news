import { __values } from 'tslib';
import { Paragraph } from '../../openxml/word/Paragraph.js';
import { appendChild, applyStyle } from '../../util/dom.js';
import renderParagraph from './renderParagraph.js';
import renderTable from './renderTable.js';
import { Table } from '../../openxml/word/Table.js';
import { renderGeom } from './renderGeom.js';
import { renderCustGeom } from './renderCustGeom.js';

/**
 * 渲染图片
 */
function renderPic(pic, word, wpg) {
    var _a, _b, _c;
    if (wpg === void 0) { wpg = null; }
    var blip = (_a = pic.blipFill) === null || _a === void 0 ? void 0 : _a.blip;
    if (blip && blip.src) {
        var img = document.createElement('img');
        img.style.position = 'relative';
        img.alt = pic.alt || '';
        img.src = blip.src;
        if (pic.alt && word.renderOptions.enableVar) {
            if (pic.altVar) {
                img.src = pic.altVar;
            }
            else if (pic.alt.startsWith('{{')) {
                var src = word.replaceText(pic.alt);
                if (src) {
                    img.src = src;
                }
            }
        }
        var xfrm = (_b = pic.spPr) === null || _b === void 0 ? void 0 : _b.xfrm;
        if (xfrm) {
            if (wpg) {
                var rect = getRectInGroup(xfrm, (_c = wpg.spPr) === null || _c === void 0 ? void 0 : _c.xfrm);
                if (rect) {
                    img.style.position = 'absolute';
                    img.style.left = rect.left + 'px';
                    img.style.top = rect.top + 'px';
                    img.style.width = rect.width + 'px';
                    img.style.height = rect.height + 'px';
                }
            }
            else {
                var off = xfrm.off;
                if (off) {
                    img.style.left = off.x;
                    img.style.top = off.y;
                }
                var ext = xfrm.ext;
                if (ext) {
                    img.style.width = ext.cx;
                    img.style.height = ext.cy;
                }
            }
            if (xfrm.rot) {
                img.style.transform = "rotate(".concat(xfrm.rot, "deg)");
            }
        }
        return img;
    }
    return null;
}
/**
 * 获取在 group 中的位置
 * @param xfrm 元素的位置定义
 *  @param groupXfrm 分组中的位置定义
 */
function getRectInGroup(xfrm, groupXfrm) {
    var off = xfrm.off;
    var width = parseFloat(xfrm.ext.cx.replace('px', ''));
    var height = parseFloat(xfrm.ext.cy.replace('px', ''));
    if (off && groupXfrm.chOff && groupXfrm.ext && groupXfrm.chExt) {
        // 先算缩放比
        var scaleX = parseFloat(groupXfrm.ext.cx.replace('px', '')) /
            parseFloat(groupXfrm.chExt.cx.replace('px', ''));
        var scaleY = parseFloat(groupXfrm.ext.cy.replace('px', '')) /
            parseFloat(groupXfrm.chExt.cy.replace('px', ''));
        var groupOffX = parseFloat(groupXfrm.chOff.x.replace('px', ''));
        var groupOffY = parseFloat(groupXfrm.chOff.y.replace('px', ''));
        var x = parseFloat(off.x.replace('px', ''));
        var y = parseFloat(off.y.replace('px', ''));
        return {
            left: scaleX * (x - groupOffX),
            top: scaleY * (y - groupOffY),
            width: scaleX * width,
            height: scaleY * height
        };
    }
    return null;
}
/**
 * 渲染文本框
 */
function renderWps(word, container, wps, wpg) {
    var e_1, _a;
    var _b;
    if (wpg === void 0) { wpg = null; }
    var wpsStyle = wps.wpsStyle;
    var spPr = wps.spPr;
    applyStyle(container, wps.style);
    if (wpsStyle === null || wpsStyle === void 0 ? void 0 : wpsStyle.fontColor) {
        container.style.color = wpsStyle.fontColor;
    }
    if (spPr === null || spPr === void 0 ? void 0 : spPr.xfrm) {
        var ext = spPr.xfrm.ext;
        if (ext) {
            var width = parseFloat(ext.cx.replace('px', ''));
            var height = parseFloat(ext.cy.replace('px', ''));
            // 在分组中的计算方式不一样，另外在分组中还需要绝对定位
            // 这个计算方法在官方文档里没找到
            if (wpg) {
                container.style.position = 'absolute';
                var rect = getRectInGroup(spPr.xfrm, (_b = wpg.spPr) === null || _b === void 0 ? void 0 : _b.xfrm);
                if (rect) {
                    container.style.left = rect.left + 'px';
                    container.style.top = rect.top + 'px';
                    width = rect.width;
                    height = rect.height;
                }
            }
            container.style.width = width + 'px';
            container.style.height = height + 'px';
            if (spPr.geom) {
                appendChild(container, renderGeom(spPr.geom, spPr, width, height, wps.wpsStyle));
            }
            if (spPr.custGeom) {
                appendChild(container, renderCustGeom(spPr.custGeom, spPr, width, height, wps.wpsStyle));
            }
        }
        if (spPr.xfrm.rot) {
            container.style.transform = "rotate(".concat(spPr.xfrm.rot, "deg)");
        }
    }
    var txbxContent = wps.txbxContent;
    if (txbxContent.length) {
        // 为了实现垂直居中，将父容器改成 table 布局
        var textContainer = document.createElement('div');
        textContainer.dataset.name = 'textContainer';
        container.style.display = 'table';
        textContainer.style.display = 'table-cell';
        textContainer.style.verticalAlign = 'middle';
        if (wps.style && wps.style['vertical-align']) {
            textContainer.style.verticalAlign = wps.style['vertical-align'];
            // 容器的 vertical-align 需要去掉，虽然也不影响
            container.style.verticalAlign = '';
        }
        appendChild(container, textContainer);
        try {
            for (var txbxContent_1 = __values(txbxContent), txbxContent_1_1 = txbxContent_1.next(); !txbxContent_1_1.done; txbxContent_1_1 = txbxContent_1.next()) {
                var txbxContentChild = txbxContent_1_1.value;
                if (txbxContentChild instanceof Paragraph) {
                    appendChild(textContainer, renderParagraph(word, txbxContentChild));
                }
                else if (txbxContentChild instanceof Table) {
                    appendChild(textContainer, renderTable(word, txbxContentChild));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (txbxContent_1_1 && !txbxContent_1_1.done && (_a = txbxContent_1.return)) _a.call(txbxContent_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
function renderWpg(word, wpg) {
    var e_2, _a, e_3, _b;
    var _c, _d;
    var container = document.createElement('div');
    var wpgContainer = document.createElement('div');
    var spPr = wpg.spPr;
    if (spPr === null || spPr === void 0 ? void 0 : spPr.xfrm) {
        var ext = (_c = spPr === null || spPr === void 0 ? void 0 : spPr.xfrm) === null || _c === void 0 ? void 0 : _c.ext;
        if (ext) {
            wpgContainer.style.width = ext.cx;
            wpgContainer.style.height = ext.cy;
        }
        var rot = (_d = spPr === null || spPr === void 0 ? void 0 : spPr.xfrm) === null || _d === void 0 ? void 0 : _d.rot;
        if (rot) {
            wpgContainer.style.transform = "rotate(".concat(rot, "deg)");
        }
    }
    try {
        for (var _e = __values(wpg.wps), _f = _e.next(); !_f.done; _f = _e.next()) {
            var wps = _f.value;
            var wpsContainer = document.createElement('div');
            renderWps(word, wpsContainer, wps, wpg);
            appendChild(wpgContainer, wpsContainer);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        }
        finally { if (e_2) throw e_2.error; }
    }
    try {
        for (var _g = __values(wpg.wpg), _h = _g.next(); !_h.done; _h = _g.next()) {
            var childWpg = _h.value;
            appendChild(container, renderWpg(word, childWpg));
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (wpg.pic) {
        appendChild(wpgContainer, renderPic(wpg.pic, word, wpg));
    }
    appendChild(container, wpgContainer);
    return container;
}
/**
 * 渲染图片，目前只支持 picture
 * http://officeopenxml.com/drwOverview.php
 * @param inHeader，如果在 header 中，位置计算要特殊处理
 *
 */
function renderDrawing(word, drawing, inHeader) {
    var container = document.createElement('div');
    if (drawing.position === 'inline') {
        container.style.display = 'inline-block';
    }
    else if (drawing.position === 'anchor') ;
    if (drawing.pic) {
        appendChild(container, renderPic(drawing.pic, word));
    }
    if (drawing.relativeFromV === 'page') {
        console.warn('暂不支持 drawing.relativeFromV === "page"');
    }
    applyStyle(container, drawing.containerStyle);
    container.dataset.id = drawing.id || '';
    container.dataset.name = drawing.name || '';
    if (drawing.wps) {
        renderWps(word, container, drawing.wps);
    }
    if (drawing.wpg) {
        appendChild(container, renderWpg(word, drawing.wpg));
    }
    // 如果没内容就不渲染了，避免高度导致撑开父节点
    if (container.children.length === 0) {
        return null;
    }
    return container;
}

export { renderDrawing };
