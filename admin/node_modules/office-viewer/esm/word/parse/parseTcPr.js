import { __values } from 'tslib';
import { parseCellMargin } from './parseCellMargin.js';
import { parseShdColor } from './parseColor.js';
import { getValBoolean, getVal, getValNumber } from '../../OpenXML.js';
import { parseBorders } from './parseBorder.js';
import { parseTextDirection } from './parseTextDirection.js';
import { parseTblWidth } from './parseTblWidth.js';
import { parseInsideBorders } from './parseInsideBorders.js';

function parseVAlign(element, style) {
    var vAlign = getVal(element);
    switch (vAlign) {
        case 'bottom':
            style['vertical-align'] = 'bottom';
            break;
        case 'center':
            style['vertical-align'] = 'middle';
            break;
        case 'top':
            style['vertical-align'] = 'top';
            break;
    }
}
function parseTblCellSpacing(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style['cell-spacing'] = width;
    }
}
function parseTcW(element, style) {
    var width = parseTblWidth(element);
    if (width) {
        style.width = width;
    }
}
function parseTcPr(word, element) {
    var e_1, _a;
    var properties = {};
    var style = {};
    properties.cssStyle = style;
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'w:tcMar':
                    parseCellMargin(child, style);
                    break;
                case 'w:shd':
                    style['background-color'] = parseShdColor(word, child);
                    break;
                case 'w:tcW':
                    parseTcW(child, style);
                    break;
                case 'w:noWrap':
                    // http://webapp.docx4java.org/OnlineDemo/ecma376/WordML/noWrap.html
                    var noWrap = getValBoolean(child);
                    if (noWrap) {
                        style['white-space'] = 'nowrap';
                    }
                    break;
                case 'w:vAlign':
                    parseVAlign(child, style);
                    break;
                case 'w:tcBorders':
                    parseBorders(word, child, style);
                    properties.insideBorder = parseInsideBorders(word, child);
                    break;
                case 'w:gridSpan':
                    properties.gridSpan = getValNumber(child);
                    break;
                case 'w:vMerge':
                    properties.vMerge = getVal(child) || 'continue';
                    break;
                case 'w:textDirection':
                    parseTextDirection(child, style);
                    break;
                case 'w:cnfStyle':
                    // 目前是自动计算的，所以不需要这个了
                    break;
                case 'w:hideMark':
                    properties.hideMark = getValBoolean(child, true);
                    break;
                default:
                    console.warn('parseTcPr: ignore', tagName, child);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return properties;
}

export { parseTblCellSpacing, parseTcPr };
