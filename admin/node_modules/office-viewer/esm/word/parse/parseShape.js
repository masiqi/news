import { __values } from 'tslib';
import { getAttrBoolean } from '../../OpenXML.js';

/**
 * 解析 shape
 */
function parsePts(element) {
    var e_1, _a;
    var pts = [];
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            if (tagName === 'a:pt' || tagName === 'pt') {
                var x = child.getAttribute('x');
                var y = child.getAttribute('y');
                if (x && y) {
                    pts.push({ x: x, y: y });
                }
            }
            else {
                console.warn('unknown pt', tagName, child);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return pts;
}
// http://webapp.docx4java.org/OnlineDemo/ecma376/DrawingML/path_2.html
function parsePath(element) {
    var e_2, _a;
    var pathChild = [];
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'a:moveTo':
                case 'moveTo':
                    var moveToPt = parsePts(child);
                    if (moveToPt.length) {
                        var moveTo_1 = {
                            type: 'moveTo',
                            pt: moveToPt[0]
                        };
                        pathChild.push(moveTo_1);
                    }
                    break;
                case 'a:lnTo':
                case 'lnTo':
                    var lnToPt = parsePts(child);
                    if (lnToPt.length) {
                        var lnTo = {
                            type: 'lnTo',
                            pt: lnToPt[0]
                        };
                        pathChild.push(lnTo);
                    }
                    break;
                case 'a:quadBezTo':
                case 'quadBezTo':
                    var quadBezToPt = parsePts(child);
                    if (quadBezToPt.length) {
                        var quadBezTo = {
                            type: 'quadBezTo',
                            pts: quadBezToPt
                        };
                        pathChild.push(quadBezTo);
                    }
                    break;
                case 'a:cubicBezTo':
                case 'cubicBezTo':
                    var cubicBezToPt = parsePts(child);
                    if (cubicBezToPt.length) {
                        var cubicBezTo = {
                            type: 'cubicBezTo',
                            pts: cubicBezToPt
                        };
                        pathChild.push(cubicBezTo);
                    }
                    break;
                case 'a:arcTo':
                case 'arcTo':
                    var wR = child.getAttribute('wR');
                    var hR = child.getAttribute('hR');
                    var stAng = child.getAttribute('stAng');
                    var swAng = child.getAttribute('swAng');
                    if (wR && hR && stAng && swAng) {
                        var arcTo = {
                            type: 'arcTo',
                            wR: wR,
                            hR: hR,
                            stAng: stAng,
                            swAng: swAng
                        };
                        pathChild.push(arcTo);
                    }
                    break;
                case 'a:close':
                case 'close':
                    pathChild.push({
                        type: 'close'
                    });
                    break;
                default:
                    console.warn('parsePath: unknown tag', tagName, child);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var path = { defines: pathChild };
    var fill = element.getAttribute('fill');
    if (fill) {
        path.fill = fill;
    }
    path.extrusionOk = getAttrBoolean(element, 'extrusionOk', false);
    path.stroke = getAttrBoolean(element, 'stroke', true);
    var w = element.getAttribute('w');
    if (w) {
        path.w = parseInt(w, 10);
    }
    var h = element.getAttribute('h');
    if (h) {
        path.h = parseInt(h, 10);
    }
    return path;
}
function parsePathLst(element) {
    var e_3, _a;
    var pathLst = [];
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'a:path':
                case 'path':
                    pathLst.push(parsePath(child));
                    break;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return pathLst;
}
function parseShapeGuide(element) {
    var e_4, _a;
    var gds = [];
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'a:gd':
                case 'gd':
                    var name_1 = child.getAttribute('name');
                    var fmla = child.getAttribute('fmla');
                    if (name_1 && fmla) {
                        var gd = {
                            n: name_1,
                            f: fmla
                        };
                        gds.push(gd);
                    }
                    break;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return gds;
}
function parseShape(element) {
    var e_5, _a;
    var shape = {};
    try {
        for (var _b = __values(element.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var tagName = child.tagName;
            switch (tagName) {
                case 'a:avLst':
                case 'avLst':
                    shape.avLst = parseShapeGuide(child);
                    break;
                case 'a:gdLst':
                case 'gdLst':
                    shape.gdLst = parseShapeGuide(child);
                    break;
                case 'a:rect':
                case 'react':
                    var rect = {
                        b: child.getAttribute('b') || '',
                        l: child.getAttribute('l') || '',
                        r: child.getAttribute('r') || '',
                        t: child.getAttribute('t') || ''
                    };
                    shape.rect = rect;
                    break;
                case 'a:pathLst':
                case 'pathLst':
                    shape.pathLst = parsePathLst(child);
                    break;
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return shape;
}

export { parsePath, parsePathLst, parsePts, parseShape, parseShapeGuide };
