function isDoubleBorder(borderPr) {
    return borderPr && borderPr.style === 'double';
}
function drawDoubleBorder(ctx, border, position, startX, startY, endX, endY) {
    ctx.lineWidth = 1;
    var lineOffset = 1;
    switch (position) {
        case 'top':
            ctx.moveTo(startX - lineOffset, startY - lineOffset);
            ctx.lineTo(endX + lineOffset, startY - lineOffset);
            // 避免双边框重叠
            if (isDoubleBorder(border.left)) {
                startX += 1;
            }
            if (isDoubleBorder(border.right)) {
                endX -= 1;
            }
            ctx.moveTo(startX, startY + lineOffset);
            ctx.lineTo(endX, startY + lineOffset);
            break;
        case 'bottom':
            ctx.moveTo(startX - lineOffset, endY + lineOffset);
            ctx.lineTo(endX + lineOffset, endY + lineOffset);
            // 避免双边框重叠
            if (isDoubleBorder(border.left)) {
                startX += 1;
            }
            if (isDoubleBorder(border.right)) {
                endX -= 1;
            }
            ctx.moveTo(startX, endY - lineOffset);
            ctx.lineTo(endX, endY - lineOffset);
            break;
        case 'left':
            ctx.moveTo(startX - lineOffset, startY - lineOffset);
            ctx.lineTo(startX - lineOffset, endY + lineOffset);
            // 避免双边框重叠
            if (isDoubleBorder(border.top)) {
                startY += 1;
            }
            if (isDoubleBorder(border.bottom)) {
                endY -= 1;
            }
            ctx.moveTo(startX + lineOffset, startY);
            ctx.lineTo(startX + lineOffset, endY);
            break;
        case 'right':
            ctx.moveTo(endX + lineOffset, startY - lineOffset);
            ctx.lineTo(endX + lineOffset, endY + lineOffset);
            // 避免双边框重叠
            if (isDoubleBorder(border.top)) {
                startY += 1;
            }
            if (isDoubleBorder(border.bottom)) {
                endY -= 1;
            }
            ctx.moveTo(endX - lineOffset, startY);
            ctx.lineTo(endX - lineOffset, endY);
            break;
        case 'diagonalDown':
            ctx.moveTo(startX - lineOffset, startY + lineOffset);
            ctx.lineTo(endX - lineOffset, endY + lineOffset);
            ctx.moveTo(startX + lineOffset, startY - lineOffset);
            ctx.lineTo(endX + lineOffset, endY - lineOffset);
            break;
        case 'diagonalUp':
            ctx.moveTo(startX - lineOffset, startY - lineOffset);
            ctx.lineTo(endX - lineOffset, endY - lineOffset);
            ctx.moveTo(startX + lineOffset, startY + lineOffset);
            ctx.lineTo(endX + lineOffset, endY + lineOffset);
            break;
    }
}

export { drawDoubleBorder };
