import { __values, __assign } from 'tslib';
import { stringToArray } from '../../../util/stringToArray.js';
import { genFontStr, genFontStrFromRPr } from './genFontStr.js';
import { measureTextWithCache } from './measureTextWithCache.js';
import { tokenizer } from './tokenizer.js';

/**
 * 自动换行
 */
/**
 * 自动折行
 * @param ctx canvas context
 * @param text 文字
 * @param fontStyle 字体样式
 * @returns 拆分的行，有可能空行
 */
function autoWrapText(ctx, text, width, fontStyle) {
    var e_1, _a, e_2, _b, e_3, _c;
    ctx.save();
    var tokens = [];
    var lines = [];
    if (typeof text === 'string') {
        tokens = tokenizer(text);
    }
    else {
        var _loop_1 = function (t) {
            var newTokens = tokenizer(t.t);
            newTokens.forEach(function (token) {
                token.rPr = t.rPr;
            });
            tokens = tokens.concat(newTokens);
        };
        try {
            for (var text_1 = __values(text), text_1_1 = text_1.next(); !text_1_1.done; text_1_1 = text_1.next()) {
                var t = text_1_1.value;
                _loop_1(t);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (text_1_1 && !text_1_1.done && (_a = text_1.return)) _a.call(text_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // 限制一千 token 避免性能问题
    if (tokens.length > 1000) {
        tokens = tokens.slice(0, 1000);
    }
    var defaultFont = genFontStr(fontStyle);
    var currentWidth = 0;
    // 计算默认字体高度
    var defaultSize = measureTextWithCache(ctx, defaultFont, '1');
    var defaultFontHeight = defaultSize.fontHeight;
    var currentMaxHeight = defaultFontHeight;
    var currentToken = [];
    function pushToken(newToken) {
        lines.push({
            tokens: currentToken,
            maxHeight: currentMaxHeight
        });
        if (newToken) {
            currentToken = [newToken];
        }
        else {
            currentToken = [];
        }
        currentWidth = 0;
        currentMaxHeight = defaultFontHeight;
    }
    try {
        for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
            var token = tokens_1_1.value;
            var font = defaultFont;
            if (token.type === 'br') {
                pushToken();
                continue;
            }
            if (token.rPr && Object.keys(token.rPr).length > 0) {
                font = genFontStrFromRPr(token.rPr, fontStyle);
            }
            var size = measureTextWithCache(ctx, font, token.t);
            var tokenWidth = size.width;
            // 字体高度
            var tokenFontHeight = size.fontHeight;
            token.w = tokenWidth;
            if (tokenFontHeight > currentMaxHeight) {
                currentMaxHeight = tokenFontHeight;
            }
            // 如果这一行宽度就比要求高度宽了，那还得拆分，这时就只能一个个字母算了
            if (tokenWidth > width) {
                var currentText = '';
                // 当前拆分出来的文字宽度
                var currentSplitWidth = 0;
                try {
                    for (var _d = (e_3 = void 0, __values(stringToArray(token.t))), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var char = _e.value;
                        // 避免太多 token，这里会对 token 进行合并
                        var charSize = measureTextWithCache(ctx, font, char);
                        var charWidth = charSize.width;
                        if (currentWidth + charWidth > width) {
                            var splitToken = __assign(__assign({}, token), { w: currentSplitWidth, t: currentText });
                            currentToken.push(splitToken);
                            // 后面会处理新行
                            pushToken();
                            currentText = char;
                            currentWidth = charWidth;
                            currentSplitWidth = charWidth;
                            currentMaxHeight = currentMaxHeight;
                        }
                        else {
                            currentWidth += charWidth;
                            currentSplitWidth += charWidth;
                            currentText += char;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (currentText) {
                    var splitToken = __assign(__assign({}, token), { w: currentSplitWidth, t: currentText });
                    currentToken.push(splitToken);
                }
            }
            else if (currentWidth + tokenWidth > width) {
                pushToken(token);
            }
            else {
                currentWidth += size.width;
                currentToken.push(token);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return)) _b.call(tokens_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (currentToken.length) {
        lines.push({
            tokens: currentToken,
            maxHeight: currentMaxHeight
        });
    }
    ctx.restore();
    return lines;
}

export { autoWrapText };
