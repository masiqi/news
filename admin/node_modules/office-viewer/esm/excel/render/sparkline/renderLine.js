import { __values, __read } from 'tslib';
import { applyColor } from './applyColor.js';

/**
 * 绘制折线图
 */
function renderLine(ctx, width, height, min, max, data, sparklineOptions, getColor) {
    var e_1, _a, e_2, _b, e_3, _c;
    var padding = 2;
    // 为了避免线跑出去，需要在两边加上一些空白
    height -= padding * 2;
    width -= padding * 2;
    var color = getColor(sparklineOptions['x14:colorSeries']);
    // 只有一个点没法画
    if (data.length < 1) {
        console.warn('sparkline 只有一个数据', data);
        return;
    }
    var step = width / (data.length - 1);
    // 绘制坐标轴
    if (sparklineOptions.displayXAxis) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = sparklineOptions.lineWeight || 1.2;
        ctx.moveTo(0 + padding, height / 2 + padding);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
    }
    // 画线
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = sparklineOptions.lineWeight || 1.2;
    var points = [];
    // 上一个是空值，则需要 moveTo
    var lastIsUndefined = false;
    try {
        for (var _d = __values(data.entries()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var _f = __read(_e.value, 2), index = _f[0], value = _f[1];
            if (value === undefined) {
                lastIsUndefined = true;
                continue;
            }
            var x = index * step + padding;
            var y = height - ((value - min) / (max - min)) * height + padding;
            if (index === 0 && lastIsUndefined) {
                ctx.moveTo(x, y);
                lastIsUndefined = false;
            }
            else {
                ctx.lineTo(x, y);
            }
            points.push({ x: x, y: y, index: index, value: value });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
    ctx.stroke();
    // 画点
    if (sparklineOptions.markers) {
        try {
            for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
                var point = points_1_1.value;
                ctx.beginPath();
                applyColor(ctx, data, point.index, point.value, min, max, sparklineOptions, color, getColor);
                ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (points_1_1 && !points_1_1.done && (_b = points_1.return)) _b.call(points_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    else {
        try {
            // 画特定的点
            for (var points_2 = __values(points), points_2_1 = points_2.next(); !points_2_1.done; points_2_1 = points_2.next()) {
                var point = points_2_1.value;
                var showRender = applyColor(ctx, data, point.index, point.value, min, max, sparklineOptions, color, getColor);
                if (!showRender) {
                    continue;
                }
                ctx.beginPath();
                ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (points_2_1 && !points_2_1.done && (_c = points_2.return)) _c.call(points_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
    }
}

export { renderLine };
