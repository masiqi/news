import { rectIntersect } from '../Rect.js';
import { EChartsRender } from './EChartsRender.js';
import { convertToEChartOptions } from './convertToEChartOptions.js';

var EChartsMap = {};
function drawChart(currentSheet, displayRect, rowHeaderWidth, colHeaderHeight, chartRect, chartSpace) {
    var workbook = currentSheet.getWorkbook();
    // Excel 渲染在数据容器内，可以被表头遮挡
    var dataContainer = workbook.getDataContainer();
    var gid = chartSpace.gid;
    // 因为前面算的是相对位置，所以这里也得转成相对位置
    var relativeDisplayRect = {
        x: 0,
        y: 0,
        width: displayRect.width,
        height: displayRect.height
    };
    var renderRect = {
        x: chartRect.x - rowHeaderWidth,
        y: chartRect.y - colHeaderHeight,
        width: chartRect.width,
        height: chartRect.height
    };
    if (rectIntersect(renderRect, relativeDisplayRect)) {
        var echartsRender = void 0;
        // 目前 sheet 切换的时候会清空
        var chartElement = dataContainer.querySelector("[data-gid=\"".concat(gid, "\"]"));
        if (EChartsMap[gid] && chartElement) {
            echartsRender = EChartsMap[gid];
            echartsRender.updatePosition(renderRect);
            echartsRender.show();
        }
        else {
            echartsRender = new EChartsRender(dataContainer, renderRect, gid);
            EChartsMap[gid] = echartsRender;
            var echartsOption = convertToEChartOptions(workbook, chartSpace);
            if (echartsOption) {
                echartsRender.render(echartsOption);
            }
        }
    }
    else {
        if (EChartsMap[gid]) {
            EChartsMap[gid].hide();
        }
    }
}

export { drawChart };
