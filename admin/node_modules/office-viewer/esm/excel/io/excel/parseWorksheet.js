import { __awaiter, __generator, __values } from 'tslib';
import { xml2json } from '../../../util/xml.js';
import { parseChildrenAttributes } from '../../../common/parseAttributes.js';
import { parseSheetData } from './worksheet/parseSheetData.js';
import { CT_SheetPr_Attributes, CT_AutoFilter_Attributes, CT_ConditionalFormatting_Attributes, CT_Col_Attributes, CT_SheetFormatPr_Attributes, CT_SheetView_Attributes } from '../../../openxml/ExcelTypes.js';
import { decodeAddress } from './util/decodeAddress.js';
import { joinPath } from '../../../util/joinPath.js';
import { parseDrawing } from './drawing/parseDrawing.js';
import { autoParse } from '../../../common/autoParse.js';
import { CT_ExtensionList_Attributes } from '../../types/CT_ExtensionList.js';
import { initValueForContainsBlanks } from './initValueForContainsBlanks.js';
import { parseTableParts } from './parseTableParts.js';
import { initValueForTable } from './initValueForTable.js';

/**
 * 解析 xl/worksheets/sheet*.xml 文件
 */
function parseWorksheet(workbook, parser, worksheetPath, xml, relationships, sharedStrings) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var node, worksheet, _loop_1, _b, _c, child, e_1_1;
        var e_1, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    if (!xml) {
                        return [2 /*return*/, null];
                    }
                    return [4 /*yield*/, xml2json(xml)];
                case 1:
                    node = _e.sent();
                    worksheet = {
                        cols: [],
                        rows: [],
                        cellData: [],
                        mergeCells: [],
                        conditionalFormatting: []
                    };
                    _loop_1 = function (child) {
                        var tag, _f, cols, cols_1, cols_1_1, col, sheetData, mergeCellNodes, mergeCellNodes_1, mergeCellNodes_1_1, mergeCellNode, ref, refs, startIndex, endIndex, conditionalFormatting, rId_1, relationship, target, path, _g, _h;
                        var e_2, _j, e_3, _k;
                        return __generator(this, function (_l) {
                            switch (_l.label) {
                                case 0:
                                    tag = child.tag;
                                    _f = tag;
                                    switch (_f) {
                                        case 'dimension': return [3 /*break*/, 1];
                                        case 'sheetViews': return [3 /*break*/, 2];
                                        case 'sheetFormatPr': return [3 /*break*/, 3];
                                        case 'cols': return [3 /*break*/, 4];
                                        case 'sheetData': return [3 /*break*/, 5];
                                        case 'mergeCells': return [3 /*break*/, 6];
                                        case 'conditionalFormatting': return [3 /*break*/, 7];
                                        case 'drawing': return [3 /*break*/, 8];
                                        case 'phoneticPr': return [3 /*break*/, 11];
                                        case 'pageMargins': return [3 /*break*/, 11];
                                        case 'extLst': return [3 /*break*/, 12];
                                        case 'tableParts': return [3 /*break*/, 13];
                                        case 'autoFilter': return [3 /*break*/, 15];
                                        case 'sheetPr': return [3 /*break*/, 16];
                                    }
                                    return [3 /*break*/, 17];
                                case 1:
                                    worksheet.dimension = {
                                        ref: child.attrs.ref
                                    };
                                    return [3 /*break*/, 18];
                                case 2:
                                    worksheet.sheetViews = parseChildrenAttributes(child, CT_SheetView_Attributes, true);
                                    return [3 /*break*/, 18];
                                case 3:
                                    worksheet.sheetFormatPr = autoParse(child, CT_SheetFormatPr_Attributes);
                                    return [3 /*break*/, 18];
                                case 4:
                                    cols = parseChildrenAttributes(child, CT_Col_Attributes);
                                    try {
                                        // 修正一下索引为 0 开始
                                        for (cols_1 = (e_2 = void 0, __values(cols)), cols_1_1 = cols_1.next(); !cols_1_1.done; cols_1_1 = cols_1.next()) {
                                            col = cols_1_1.value;
                                            col.min = (col.min || 1) - 1;
                                            col.max = (col.max || 1) - 1;
                                        }
                                    }
                                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                    finally {
                                        try {
                                            if (cols_1_1 && !cols_1_1.done && (_j = cols_1.return)) _j.call(cols_1);
                                        }
                                        finally { if (e_2) throw e_2.error; }
                                    }
                                    worksheet.cols = cols;
                                    return [3 /*break*/, 18];
                                case 5:
                                    sheetData = parseSheetData(child, sharedStrings);
                                    worksheet.rows = sheetData.rows;
                                    worksheet.cellData = sheetData.cellData;
                                    return [3 /*break*/, 18];
                                case 6:
                                    mergeCellNodes = child.children || [];
                                    try {
                                        for (mergeCellNodes_1 = (e_3 = void 0, __values(mergeCellNodes)), mergeCellNodes_1_1 = mergeCellNodes_1.next(); !mergeCellNodes_1_1.done; mergeCellNodes_1_1 = mergeCellNodes_1.next()) {
                                            mergeCellNode = mergeCellNodes_1_1.value;
                                            ref = (_a = mergeCellNode.attrs) === null || _a === void 0 ? void 0 : _a.ref;
                                            if (ref) {
                                                refs = ref.split(':');
                                                if (refs.length === 2) {
                                                    startIndex = decodeAddress(refs[0]);
                                                    endIndex = decodeAddress(refs[1]);
                                                    worksheet.mergeCells.push({
                                                        startCol: startIndex.col,
                                                        startRow: startIndex.row,
                                                        endCol: endIndex.col,
                                                        endRow: endIndex.row
                                                    });
                                                }
                                                else {
                                                    console.warn('error ref', ref);
                                                }
                                            }
                                        }
                                    }
                                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                                    finally {
                                        try {
                                            if (mergeCellNodes_1_1 && !mergeCellNodes_1_1.done && (_k = mergeCellNodes_1.return)) _k.call(mergeCellNodes_1);
                                        }
                                        finally { if (e_3) throw e_3.error; }
                                    }
                                    return [3 /*break*/, 18];
                                case 7:
                                    conditionalFormatting = autoParse(child, CT_ConditionalFormatting_Attributes);
                                    worksheet.conditionalFormatting.push(conditionalFormatting);
                                    return [3 /*break*/, 18];
                                case 8:
                                    rId_1 = child.attrs['r:id'];
                                    relationship = relationships.find(function (relationship) { return relationship.id === rId_1; });
                                    if (!relationship) return [3 /*break*/, 10];
                                    target = relationship.target;
                                    path = joinPath(worksheetPath, '..', target);
                                    _g = worksheet;
                                    return [4 /*yield*/, parseDrawing(workbook, parser, path)];
                                case 9:
                                    _g.drawing = _l.sent();
                                    _l.label = 10;
                                case 10: return [3 /*break*/, 18];
                                case 11: 
                                // 暂时不处理
                                return [3 /*break*/, 18];
                                case 12:
                                    worksheet.extLst = autoParse(child, CT_ExtensionList_Attributes);
                                    return [3 /*break*/, 18];
                                case 13:
                                    _h = worksheet;
                                    return [4 /*yield*/, parseTableParts(worksheetPath, parser, relationships, child)];
                                case 14:
                                    _h.tableParts = _l.sent();
                                    return [3 /*break*/, 18];
                                case 15:
                                    worksheet.autoFilter = autoParse(child, CT_AutoFilter_Attributes);
                                    return [3 /*break*/, 18];
                                case 16:
                                    worksheet.sheetPr = autoParse(child, CT_SheetPr_Attributes);
                                    return [3 /*break*/, 18];
                                case 17:
                                    console.warn('unknown tag', tag);
                                    return [3 /*break*/, 18];
                                case 18: return [2 /*return*/];
                            }
                        });
                    };
                    _e.label = 2;
                case 2:
                    _e.trys.push([2, 7, 8, 9]);
                    _b = __values(node.children), _c = _b.next();
                    _e.label = 3;
                case 3:
                    if (!!_c.done) return [3 /*break*/, 6];
                    child = _c.value;
                    return [5 /*yield**/, _loop_1(child)];
                case 4:
                    _e.sent();
                    _e.label = 5;
                case 5:
                    _c = _b.next();
                    return [3 /*break*/, 3];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9:
                    initValueForContainsBlanks(worksheet);
                    initValueForTable(worksheet);
                    return [2 /*return*/, worksheet];
            }
        });
    });
}

export { parseWorksheet };
