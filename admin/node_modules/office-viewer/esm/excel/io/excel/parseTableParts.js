import { __awaiter, __generator, __values } from 'tslib';
import { autoParse } from '../../../common/autoParse.js';
import { CT_Table_Attributes } from '../../../openxml/ExcelTypes.js';
import { joinPath } from '../../../util/joinPath.js';
import { xml2json } from '../../../util/xml.js';

function parseTableParts(worksheetPath, parser, relationships, tablePartsNode) {
    return __awaiter(this, void 0, void 0, function () {
        var tables, _loop_1, _a, _b, tableParts, e_1_1;
        var e_1, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    tables = [];
                    _loop_1 = function (tableParts) {
                        var rId, relationship, target, path, tableXML, tableNode;
                        return __generator(this, function (_e) {
                            switch (_e.label) {
                                case 0:
                                    rId = tableParts.attrs['r:id'];
                                    relationship = relationships.find(function (relationship) { return relationship.id === rId; });
                                    if (!relationship) return [3 /*break*/, 2];
                                    target = relationship.target;
                                    path = joinPath(worksheetPath, '..', target);
                                    tableXML = parser.getString(path);
                                    return [4 /*yield*/, xml2json(tableXML)];
                                case 1:
                                    tableNode = _e.sent();
                                    tables.push(autoParse(tableNode, CT_Table_Attributes));
                                    _e.label = 2;
                                case 2: return [2 /*return*/];
                            }
                        });
                    };
                    _d.label = 1;
                case 1:
                    _d.trys.push([1, 6, 7, 8]);
                    _a = __values(tablePartsNode.children || []), _b = _a.next();
                    _d.label = 2;
                case 2:
                    if (!!_b.done) return [3 /*break*/, 5];
                    tableParts = _b.value;
                    return [5 /*yield**/, _loop_1(tableParts)];
                case 3:
                    _d.sent();
                    _d.label = 4;
                case 4:
                    _b = _a.next();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    e_1_1 = _d.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 8];
                case 7:
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/, tables];
            }
        });
    });
}

export { parseTableParts };
