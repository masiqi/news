import { __values } from 'tslib';
import { parseRange } from './util/Range.js';
import { makeBlankValue } from './util/makeBlankValue.js';

/**
 * 后面判断 containsBlanks 时需要单元格有值，不然 getViewPointData 会拿不到数据导致无法判断
 * 这个方法的作用是保证在 containsBlanks 检测范围内的单元格都有值
 */
function initValueForContainsBlanks(worksheet) {
    var e_1, _a, e_2, _b, e_3, _c;
    try {
        for (var _d = __values(worksheet.conditionalFormatting), _e = _d.next(); !_e.done; _e = _d.next()) {
            var formatting = _e.value;
            var cfRules = formatting.cfRule || [];
            try {
                for (var cfRules_1 = (e_2 = void 0, __values(cfRules)), cfRules_1_1 = cfRules_1.next(); !cfRules_1_1.done; cfRules_1_1 = cfRules_1.next()) {
                    var cfRule = cfRules_1_1.value;
                    if (cfRule.type === 'containsBlanks') {
                        var sqref = formatting.sqref;
                        if (!sqref) {
                            continue;
                        }
                        var ranges = sqref.split(' ').map(parseRange);
                        try {
                            for (var ranges_1 = (e_3 = void 0, __values(ranges)), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
                                var range = ranges_1_1.value;
                                makeBlankValue(worksheet.cellData, range);
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (ranges_1_1 && !ranges_1_1.done && (_c = ranges_1.return)) _c.call(ranges_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (cfRules_1_1 && !cfRules_1_1.done && (_b = cfRules_1.return)) _b.call(cfRules_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        }
        finally { if (e_1) throw e_1.error; }
    }
}

export { initValueForContainsBlanks };
