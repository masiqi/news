import { __values } from 'tslib';

/**
 * 使用二分查找第一个大于等于目标值的索引，也就是在某个偏移量下能看到的第一个单元格
 * @param rangeCache
 * @param target
 * @returns
 */
function findStartInCache(rangeCache, target) {
    var start = 0, end = rangeCache.length - 1;
    var found = -1;
    while (start < end) {
        var mid = Math.floor((start + end) / 2);
        var indexInfo = rangeCache[mid];
        // 找不到说明 bug 了
        if (!indexInfo) {
            console.error('findStartInCache indexInfo is undefined');
            break;
        }
        var indexRange = indexInfo.offset + indexInfo.size;
        if (indexRange === target) {
            found = mid;
            break;
        }
        else if (indexRange < target) {
            start = mid + 1;
        }
        else {
            end = mid;
        }
    }
    if (found !== -1) {
        return found;
    }
    else {
        return start;
    }
}
/**
 * 获取范围内的索引列表
 * @param offset 滚动条偏移
 * @param shift 表头导致的偏移
 * @param totalLength 总长度
 * @param getHeight 获取长度的方法
 * @param hiddenRange 隐藏的范围
 * @param rangeCache 位置信息缓存
 * @returns
 */
function getRange(offset, shift, totalLength, getHeight, hiddenRange, rangeCache) {
    var e_1, _a;
    if (hiddenRange === void 0) { hiddenRange = []; }
    if (rangeCache === void 0) { rangeCache = []; }
    // 从零开始遍历直到找到
    var foundStart = false;
    var foundEnd = false;
    var index = 0;
    var startOffset = 0;
    var currentOffset = 0;
    // 这些都不能为 undefined，避免后面计算死循环
    offset = offset || 0;
    totalLength = totalLength || 0;
    var indexes = [];
    var sizes = [];
    var MAX_LOOP = 10000;
    var loop = 0;
    if (rangeCache.length) {
        var lastRangeCache = rangeCache[rangeCache.length - 1];
        if (lastRangeCache.offset < offset) {
            index = rangeCache.length;
            currentOffset = lastRangeCache.offset;
        }
        else {
            var foundIndex = findStartInCache(rangeCache, offset);
            // 这时肯定有找到，为 -1 基本上是 bug
            if (foundIndex !== -1) {
                index = foundIndex;
                currentOffset = rangeCache[index].offset;
            }
        }
    }
    while (!(foundStart && foundEnd)) {
        try {
            // 如果有隐藏列就直接跳到下一个不隐藏的列，避免很大隐藏列导致性能卡顿
            for (var hiddenRange_1 = (e_1 = void 0, __values(hiddenRange)), hiddenRange_1_1 = hiddenRange_1.next(); !hiddenRange_1_1.done; hiddenRange_1_1 = hiddenRange_1.next()) {
                var range = hiddenRange_1_1.value;
                if (index >= range.min && index <= range.max) {
                    index = range.max + 1;
                    // 将索引信息加入到缓存中，只处理一次
                    if (range.max > rangeCache.length - 1) {
                        for (var i = range.min; i <= range.max; i++) {
                            rangeCache[i] = {
                                offset: currentOffset,
                                size: 0
                            };
                        }
                    }
                    continue;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (hiddenRange_1_1 && !hiddenRange_1_1.done && (_a = hiddenRange_1.return)) _a.call(hiddenRange_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var cellLength = getHeight(index) || 0;
        rangeCache[index] = {
            offset: currentOffset,
            size: cellLength
        };
        // 第一次大于 offset 就找到了开始位置
        if (currentOffset + cellLength >= offset && !foundStart) {
            startOffset = currentOffset - offset;
            foundStart = true;
            indexes.push(index);
            sizes.push({
                size: cellLength,
                offset: currentOffset - offset + shift
            });
            currentOffset += cellLength;
            index = index + 1;
            continue;
        }
        // 第一次大于结束位置就找到了结束位置
        if (currentOffset + cellLength >= offset + totalLength && !foundEnd) {
            foundEnd = true;
            indexes.push(index);
            sizes.push({
                size: cellLength,
                offset: currentOffset - offset + shift
            });
        }
        // 中间节点
        if (foundStart && !foundEnd) {
            indexes.push(index);
            sizes.push({
                size: cellLength,
                offset: currentOffset - offset + shift
            });
        }
        currentOffset += cellLength;
        // 避免是死循环
        if (loop++ > MAX_LOOP) {
            console.error('getRange loop too many times');
            break;
        }
        index = index + 1;
    }
    return {
        indexes: indexes,
        sizes: sizes,
        startOffset: startOffset,
        length: totalLength + shift
    };
}
/**
 * 获取视口范围的单元格区域，拆分单独函数是为了方便单元测试，这部分逻辑不需要依赖 UI 展现
 *
 * @param scrollLeft 水平滚动条
 * @param scrollTop 垂直滚动条
 * @param leftShift 左偏移量，主要是表头导致的偏移量
 * @param topShift 上偏移量，主要是表头导致的偏移量
 * @param height 窗口高度
 * @param width 窗口宽度
 * @param defaultRowHeight 行默认高度
 * @param defaultColWidth 列默认宽度
 * @param customRowHeight 自定义行高
 * @param customColWidth 自定义列宽
 *
 * @returns 从 0 开始的行和列，以及初始的坐标
 */
function getViewRange(scrollLeft, scrollTop, leftShift, topShift, height, width, getRowHeight, rowPositionCache, getColWidth, colPositionCache, colHiddenRange) {
    if (rowPositionCache === void 0) { rowPositionCache = []; }
    if (colPositionCache === void 0) { colPositionCache = []; }
    if (colHiddenRange === void 0) { colHiddenRange = []; }
    var _a = getRange(scrollTop, topShift, height, getRowHeight, [], rowPositionCache), rows = _a.indexes, startRowOffset = _a.startOffset, rowSizes = _a.sizes;
    var _b = getRange(scrollLeft, leftShift, width, getColWidth, colHiddenRange, colPositionCache), cols = _b.indexes, startColOffset = _b.startOffset, colSizes = _b.sizes;
    return {
        region: 'normal',
        rows: rows,
        rowSizes: rowSizes,
        height: height,
        startRowOffset: startRowOffset,
        cols: cols,
        colSizes: colSizes,
        width: width,
        startColOffset: startColOffset
    };
}

export { findStartInCache, getRange, getViewRange };
