import { __values } from 'tslib';
import { hasValue } from '../types/worksheet/CellData.js';

/**
 * 计算单元格的高宽，主要是得考虑合并单元格的情况
 * @param row
 * @param col
 * @param rowHeight
 * @param colWidth
 * @param mergeCells
 * @returns
 */
function calcCellDisplaySize(row, col, rowHeight, colWidth, getRowHeight, getColWidth, mergeCells) {
    var e_1, _a;
    var displayWidth = colWidth;
    var displayHeight = rowHeight;
    var isMergeCell = false;
    var matchMergeCell = undefined;
    // 用于标识是哪个合并单元格
    var mergeCellId = '';
    try {
        for (var mergeCells_1 = __values(mergeCells), mergeCells_1_1 = mergeCells_1.next(); !mergeCells_1_1.done; mergeCells_1_1 = mergeCells_1.next()) {
            var mergeCell = mergeCells_1_1.value;
            var startRow = mergeCell.startRow, endRow = mergeCell.endRow, startCol = mergeCell.startCol, endCol = mergeCell.endCol;
            if (row >= startRow && row <= endRow && col >= startCol && col <= endCol) {
                mergeCellId = "".concat(startRow, "-").concat(endRow, "-").concat(startCol, "-").concat(endCol);
                isMergeCell = true;
                matchMergeCell = mergeCell;
                // 补上合并单元格的高宽
                if (startRow !== endRow) {
                    for (var i = row + 1; i <= endRow; i++) {
                        displayHeight += getRowHeight(i);
                    }
                }
                if (startCol !== endCol) {
                    for (var i = col + 1; i <= endCol; i++) {
                        displayWidth += getColWidth(i);
                    }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (mergeCells_1_1 && !mergeCells_1_1.done && (_a = mergeCells_1.return)) _a.call(mergeCells_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return {
        isMergeCell: isMergeCell,
        mergeCell: matchMergeCell,
        mergeCellId: mergeCellId,
        displayHeight: displayHeight,
        displayWidth: displayWidth
    };
}
/**
 * 返回可视区域的数据及位置信息，拆分函数方便但要测试
 */
function getViewPointData(getSheetRowData, getMergeCells, getRowHeight, getColWidth, viewRange) {
    var e_2, _a, e_3, _b;
    var rows = viewRange.rows, rowSizes = viewRange.rowSizes, cols = viewRange.cols, colSizes = viewRange.colSizes;
    var displayData = [];
    var mergeCells = getMergeCells();
    // 已经渲染的合并单元格
    var renderedMergeCell = new Set();
    var rIndex = 0;
    try {
        for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
            var rowIndex = rows_1_1.value;
            var rowHeight = rowSizes[rIndex].size;
            var rowData = getSheetRowData(rowIndex);
            var cIndex = 0;
            try {
                for (var cols_1 = (e_3 = void 0, __values(cols)), cols_1_1 = cols_1.next(); !cols_1_1.done; cols_1_1 = cols_1.next()) {
                    var colIndex = cols_1_1.value;
                    var colWidth = colSizes[cIndex].size;
                    if (rowData[colIndex] !== undefined) {
                        var value = rowData[colIndex];
                        var displayWidth = colWidth;
                        var displayHeight = rowHeight;
                        var needClear = false;
                        // 是否忽略渲染，这种情况主要是发生在合并单元格的时候
                        var ignore = false;
                        if (mergeCells.length) {
                            var displaySize = calcCellDisplaySize(rowIndex, colIndex, rowHeight, colWidth, getRowHeight, getColWidth, mergeCells);
                            if (displaySize.isMergeCell) {
                                displayWidth = displaySize.displayWidth;
                                displayHeight = displaySize.displayHeight;
                                if (hasValue(value)) {
                                    needClear = true;
                                    renderedMergeCell.add(displaySize.mergeCellId);
                                }
                                else {
                                    // 没有值的情况下，不需要渲染
                                    ignore = true;
                                    // 还有另一个情况是在合并单元格下，第一个单元格不再显示，这时需要手动将第一个单元格信息补上
                                    // 目前这个逻辑是比较复杂，但目前这样做性能最好
                                    if (!renderedMergeCell.has(displaySize.mergeCellId) &&
                                        displaySize.mergeCell) {
                                        // 反算第一个单元格的位置
                                        var x = colSizes[cIndex].offset;
                                        var y = rowSizes[rIndex].offset;
                                        var _c = displaySize.mergeCell, startCol = _c.startCol, startRow = _c.startRow;
                                        // 当前单元格相对于第一个单元格在 x 方向的偏移
                                        var xOffset = 0;
                                        for (var i = startCol; i < colIndex; i++) {
                                            xOffset += getColWidth(i);
                                        }
                                        x -= xOffset;
                                        // 当前单元格相对于第一个单元格在 y 方向的偏移
                                        var yOffset = 0;
                                        for (var i = startRow; i < rowIndex; i++) {
                                            yOffset += getRowHeight(i);
                                        }
                                        y -= yOffset;
                                        var value_1 = getSheetRowData(startRow)[startCol];
                                        displayData.push({
                                            x: x,
                                            y: y,
                                            width: displayWidth + xOffset,
                                            height: displayHeight + yOffset,
                                            row: startRow,
                                            col: startCol,
                                            value: value_1,
                                            needClear: true
                                        });
                                        // 避免再次添加
                                        renderedMergeCell.add(displaySize.mergeCellId);
                                    }
                                }
                            }
                        }
                        if (!ignore) {
                            displayData.push({
                                x: colSizes[cIndex].offset,
                                y: rowSizes[rIndex].offset,
                                width: displayWidth,
                                height: displayHeight,
                                row: rowIndex,
                                col: colIndex,
                                value: value,
                                needClear: needClear
                            });
                        }
                    }
                    cIndex++;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (cols_1_1 && !cols_1_1.done && (_b = cols_1.return)) _b.call(cols_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            rIndex++;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return displayData;
}

export { calcCellDisplaySize, getViewPointData };
