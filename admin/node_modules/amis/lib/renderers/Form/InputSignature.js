/**
 * amis v6.13.0
 * build time: 2025-08-12
 * Copyright 2018-2025 baidu
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _Signature = require('amis-ui/lib/components/Signature');
var tslib = require('tslib');
var React = require('react');
var amisCore = require('amis-core');
var pick = require('lodash/pick');
var file64 = require('file64');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _Signature__default = /*#__PURE__*/_interopDefaultLegacy(_Signature);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var pick__default = /*#__PURE__*/_interopDefaultLegacy(pick);

var __react_jsx__ = require('react');
var _J$X_ = (__react_jsx__["default"] || __react_jsx__).createElement;
var _J$F_ = (__react_jsx__["default"] || __react_jsx__).Fragment;


;var InputSignatureComp = /** @class */function (_super) {
  tslib.__extends(InputSignatureComp, _super);
  function InputSignatureComp() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  InputSignatureComp.prototype.uploadFile = function (file, uploadApi) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var api, fd, fileBlob;
      return tslib.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            api = amisCore.normalizeApi(uploadApi, 'post');
            if (!!api.data) return [3 /*break*/, 2];
            fd = new FormData();
            return [4 /*yield*/, file64.base64ToBlob(file)];
          case 1:
            fileBlob = _a.sent();
            fd.append('file', fileBlob, 'signature.png');
            api.data = fd;
            _a.label = 2;
          case 2:
            return [2 /*return*/, this.props.env.fetcher(api, amisCore.createObject(this.props.data, {
              file: file
            }))];
        }
      });
    });
  };
  InputSignatureComp.prototype.handleChange = function (val) {
    var _a, _b;
    return tslib.__awaiter(this, void 0, void 0, function () {
      var _c, __, uploadApi, embed, onChange, res, value, error_1;
      return tslib.__generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            _c = this.props, __ = _c.translate, uploadApi = _c.uploadApi, embed = _c.embed, onChange = _c.onChange;
            // 非内嵌模式 没有上传api 或是清空直接onChange
            if (!embed || !uploadApi || val === undefined) {
              onChange === null || onChange === void 0 ? void 0 : onChange(val);
              return [2 /*return*/];
            }
            _d.label = 1;
          case 1:
            _d.trys.push([1, 3,, 4]);
            return [4 /*yield*/, this.uploadFile(val, uploadApi)];
          case 2:
            res = _d.sent();
            if (!res.ok || res.status && res.status !== '0' || !res.data) {
              throw new Error(res.msg || __('File.errorRetry'));
            }
            value = res.data.value || res.data.url || res.data;
            onChange === null || onChange === void 0 ? void 0 : onChange(value);
            return [3 /*break*/, 4];
          case 3:
            error_1 = _d.sent();
            // 失败清空签名组件内的数据，传空字符串会重新触发amis的渲染，underfined不会被重新渲染（连续的空字符串不会被重新渲染，amis底层会对value值进行diff对比）
            onChange === null || onChange === void 0 ? void 0 : onChange('');
            (_b = (_a = this.props.env) === null || _a === void 0 ? void 0 : _a.alert) === null || _b === void 0 ? void 0 : _b.call(_a, error_1.message || __('File.errorRetry'));
            return [3 /*break*/, 4];
          case 4:
            return [2 /*return*/];
        }
      });
    });
  };
  InputSignatureComp.prototype.render = function () {
    var _a = this.props,
      cx = _a.classnames,
      className = _a.className;
    var props = pick__default["default"](this.props, ['value', 'width', 'height', 'mobileUI', 'embed', 'color', 'bgColor', 'clearBtnLabel', 'clearBtnIcon', 'undoBtnLabel', 'undoBtnIcon', 'confirmBtnLabel', 'confirmBtnIcon', 'embedConfirmLabel', 'embedConfirmIcon', 'ebmedCancelLabel', 'ebmedCancelIcon', 'embedBtnIcon', 'embedBtnLabel', 'uploadApi']);
    return _J$X_(_Signature__default["default"], tslib.__assign({
      classnames: cx,
      className: className,
      onChange: this.handleChange
    }, props));
  };
  tslib.__decorate([amisCore.autobind, tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [String, String]), tslib.__metadata("design:returntype", Promise)], InputSignatureComp.prototype, "uploadFile", null);
  tslib.__decorate([amisCore.autobind, tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", Promise)], InputSignatureComp.prototype, "handleChange", null);
  return InputSignatureComp;
}(React__default["default"].Component);
var InputSignatureRenderer = /** @class */function (_super) {
  tslib.__extends(InputSignatureRenderer, _super);
  function InputSignatureRenderer(props, context) {
    var _this = _super.call(this, props) || this;
    var scoped = context;
    scoped.registerComponent(_this);
    return _this;
  }
  InputSignatureRenderer.prototype.componentWillUnmount = function () {
    var _a;
    (_a = _super.prototype.componentWillUnmount) === null || _a === void 0 ? void 0 : _a.call(this);
    var scoped = this.context;
    scoped.unRegisterComponent(this);
  };
  InputSignatureRenderer.contextType = amisCore.ScopedContext;
  InputSignatureRenderer = tslib.__decorate([amisCore.FormItem({
    type: 'input-signature',
    sizeMutable: false
  }), tslib.__metadata("design:paramtypes", [Object, Object])], InputSignatureRenderer);
  return InputSignatureRenderer;
}(InputSignatureComp);

exports.InputSignatureRenderer = InputSignatureRenderer;
exports["default"] = InputSignatureComp;
