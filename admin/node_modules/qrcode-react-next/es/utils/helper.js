import y from "../material/eyes/index.js";
import E from "../material/points/index.js";
import c from "../third-party/qrcodegen/index.js";
const Q = c.QrCode, z = {
  L: c.QrCode.Ecc.LOW,
  M: c.QrCode.Ecc.MEDIUM,
  Q: c.QrCode.Ecc.QUARTILE,
  H: c.QrCode.Ecc.HIGH
};
function a(r, t) {
  const {
    level: e = "L",
    minVersion: n = 2,
    maxVersion: o,
    mask: m,
    boostLevel: f
  } = t || {}, l = c.QrSegment.makeSegments(r), i = Q.encodeSegments(
    l,
    z[e],
    n,
    o,
    m,
    f
  ), d = [];
  for (let s = 0; s < i.size; s++) {
    d.push([]);
    for (let u = 0; u < i.size; u++)
      d[s].push(i.getModule(u, s));
  }
  return d;
}
function L(r, t, e) {
  const n = t * 7, o = [
    { x: e, y: e },
    { x: e, y: r - n - e },
    { x: r - n - e, y: e }
  ];
  return {
    eyeSize: n,
    positions: o
  };
}
function x(r, t, e) {
  const n = r.length, o = 8;
  return t < o && e < o || t < o && e > n - o || t > n - o && e < o;
}
function R(r) {
  const {
    modules: t,
    size: e,
    dotSize: n,
    margin: o = 0,
    eyeType: m = "default",
    eyeBorderSize: f = "default",
    pointType: l = "default",
    customSize: i,
    pointSize: d = "default"
  } = r, s = E(l)({
    margin: o,
    modules: t,
    dotSize: n,
    pointSize: d,
    customSize: i
  }), { eyeBorder: u, eyeInner: p } = y(m)({
    margin: o,
    dotSize: n,
    borderSize: f,
    size: e
  });
  return {
    points: s,
    eyeBorder: u,
    eyeInner: p
  };
}
function M(r, t = 2) {
  return Number(r.toFixed(t));
}
export {
  R as generatePath,
  a as generateQRCode,
  L as getEyeSizeAndPositions,
  x as isQrCodeEye,
  M as toFixedNumber
};
