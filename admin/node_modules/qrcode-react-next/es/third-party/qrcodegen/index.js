var A;
((w) => {
  const n = class n {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(t, s, e, i) {
      if (this.version = t, this.errorCorrectionLevel = s, this.modules = [], this.isFunction = [], t < n.MIN_VERSION || t > n.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (i < -1 || i > 7) throw new RangeError("Mask value out of range");
      this.size = t * 4 + 17;
      let o = [];
      for (let r = 0; r < this.size; r++) o.push(!1);
      for (let r = 0; r < this.size; r++)
        this.modules.push(o.slice()), this.isFunction.push(o.slice());
      this.drawFunctionPatterns();
      const a = this.addEccAndInterleave(e);
      if (this.drawCodewords(a), i == -1) {
        let r = 1e9;
        for (let u = 0; u < 8; u++) {
          this.applyMask(u), this.drawFormatBits(u);
          const h = this.getPenaltyScore();
          h < r && (i = u, r = h), this.applyMask(u);
        }
      }
      m(0 <= i && i <= 7), this.mask = i, this.applyMask(i), this.drawFormatBits(i), this.isFunction = [];
    }
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(t, s) {
      const e = w.QrSegment.makeSegments(t);
      return n.encodeSegments(e, s);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(t, s) {
      const e = w.QrSegment.makeBytes(t);
      return n.encodeSegments([e], s);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(t, s, e = 1, i = 40, o = -1, a = !0) {
      if (!(n.MIN_VERSION <= e && e <= i && i <= n.MAX_VERSION) || o < -1 || o > 7)
        throw new RangeError("Invalid value");
      let r, u;
      for (r = e; ; r++) {
        const f = n.getNumDataCodewords(r, s) * 8, E = g.getTotalBits(t, r);
        if (E <= f) {
          u = E;
          break;
        }
        if (r >= i)
          throw new RangeError("Data too long");
      }
      for (const f of [
        n.Ecc.MEDIUM,
        n.Ecc.QUARTILE,
        n.Ecc.HIGH
      ])
        a && u <= n.getNumDataCodewords(r, f) * 8 && (s = f);
      let h = [];
      for (const f of t) {
        d(f.mode.modeBits, 4, h), d(f.numChars, f.mode.numCharCountBits(r), h);
        for (const E of f.getData()) h.push(E);
      }
      m(h.length == u);
      const P = n.getNumDataCodewords(r, s) * 8;
      m(h.length <= P), d(0, Math.min(4, P - h.length), h), d(0, (8 - h.length % 8) % 8, h), m(h.length % 8 == 0);
      for (let f = 236; h.length < P; f ^= 253)
        d(f, 8, h);
      let M = [];
      for (; M.length * 8 < h.length; ) M.push(0);
      return h.forEach(
        (f, E) => M[E >>> 3] |= f << 7 - (E & 7)
      ), new n(r, s, M, o);
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(t, s) {
      return 0 <= t && t < this.size && 0 <= s && s < this.size && this.modules[s][t];
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let e = 0; e < this.size; e++)
        this.setFunctionModule(6, e, e % 2 == 0), this.setFunctionModule(e, 6, e % 2 == 0);
      this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4);
      const t = this.getAlignmentPatternPositions(), s = t.length;
      for (let e = 0; e < s; e++)
        for (let i = 0; i < s; i++)
          e == 0 && i == 0 || e == 0 && i == s - 1 || e == s - 1 && i == 0 || this.drawAlignmentPattern(t[e], t[i]);
      this.drawFormatBits(0), this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(t) {
      const s = this.errorCorrectionLevel.formatBits << 3 | t;
      let e = s;
      for (let o = 0; o < 10; o++) e = e << 1 ^ (e >>> 9) * 1335;
      const i = (s << 10 | e) ^ 21522;
      m(i >>> 15 == 0);
      for (let o = 0; o <= 5; o++)
        this.setFunctionModule(8, o, l(i, o));
      this.setFunctionModule(8, 7, l(i, 6)), this.setFunctionModule(8, 8, l(i, 7)), this.setFunctionModule(7, 8, l(i, 8));
      for (let o = 9; o < 15; o++)
        this.setFunctionModule(14 - o, 8, l(i, o));
      for (let o = 0; o < 8; o++)
        this.setFunctionModule(this.size - 1 - o, 8, l(i, o));
      for (let o = 8; o < 15; o++)
        this.setFunctionModule(8, this.size - 15 + o, l(i, o));
      this.setFunctionModule(8, this.size - 8, !0);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7) return;
      let t = this.version;
      for (let e = 0; e < 12; e++) t = t << 1 ^ (t >>> 11) * 7973;
      const s = this.version << 12 | t;
      m(s >>> 18 == 0);
      for (let e = 0; e < 18; e++) {
        const i = l(s, e), o = this.size - 11 + e % 3, a = Math.floor(e / 3);
        this.setFunctionModule(o, a, i), this.setFunctionModule(a, o, i);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(t, s) {
      for (let e = -4; e <= 4; e++)
        for (let i = -4; i <= 4; i++) {
          const o = Math.max(Math.abs(i), Math.abs(e)), a = t + i, r = s + e;
          0 <= a && a < this.size && 0 <= r && r < this.size && this.setFunctionModule(a, r, o != 2 && o != 4);
        }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(t, s) {
      for (let e = -2; e <= 2; e++)
        for (let i = -2; i <= 2; i++)
          this.setFunctionModule(
            t + i,
            s + e,
            Math.max(Math.abs(i), Math.abs(e)) != 1
          );
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(t, s, e) {
      this.modules[s][t] = e, this.isFunction[s][t] = !0;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(t) {
      const s = this.version, e = this.errorCorrectionLevel;
      if (t.length != n.getNumDataCodewords(s, e))
        throw new RangeError("Invalid argument");
      const i = n.NUM_ERROR_CORRECTION_BLOCKS[e.ordinal][s], o = n.ECC_CODEWORDS_PER_BLOCK[e.ordinal][s], a = Math.floor(
        n.getNumRawDataModules(s) / 8
      ), r = i - a % i, u = Math.floor(a / i);
      let h = [];
      const P = n.reedSolomonComputeDivisor(o);
      for (let f = 0, E = 0; f < i; f++) {
        let N = t.slice(
          E,
          E + u - o + (f < r ? 0 : 1)
        );
        E += N.length;
        const p = n.reedSolomonComputeRemainder(N, P);
        f < r && N.push(0), h.push(N.concat(p));
      }
      let M = [];
      for (let f = 0; f < h[0].length; f++)
        h.forEach((E, N) => {
          (f != u - o || N >= r) && M.push(E[f]);
        });
      return m(M.length == a), M;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(t) {
      if (t.length != Math.floor(n.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let s = 0;
      for (let e = this.size - 1; e >= 1; e -= 2) {
        e == 6 && (e = 5);
        for (let i = 0; i < this.size; i++)
          for (let o = 0; o < 2; o++) {
            const a = e - o, u = (e + 1 & 2) == 0 ? this.size - 1 - i : i;
            !this.isFunction[u][a] && s < t.length * 8 && (this.modules[u][a] = l(t[s >>> 3], 7 - (s & 7)), s++);
          }
      }
      m(s == t.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(t) {
      if (t < 0 || t > 7) throw new RangeError("Mask value out of range");
      for (let s = 0; s < this.size; s++)
        for (let e = 0; e < this.size; e++) {
          let i;
          switch (t) {
            case 0:
              i = (e + s) % 2 == 0;
              break;
            case 1:
              i = s % 2 == 0;
              break;
            case 2:
              i = e % 3 == 0;
              break;
            case 3:
              i = (e + s) % 3 == 0;
              break;
            case 4:
              i = (Math.floor(e / 3) + Math.floor(s / 2)) % 2 == 0;
              break;
            case 5:
              i = e * s % 2 + e * s % 3 == 0;
              break;
            case 6:
              i = (e * s % 2 + e * s % 3) % 2 == 0;
              break;
            case 7:
              i = ((e + s) % 2 + e * s % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          !this.isFunction[s][e] && i && (this.modules[s][e] = !this.modules[s][e]);
        }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let t = 0;
      for (let o = 0; o < this.size; o++) {
        let a = !1, r = 0, u = [0, 0, 0, 0, 0, 0, 0];
        for (let h = 0; h < this.size; h++)
          this.modules[o][h] == a ? (r++, r == 5 ? t += n.PENALTY_N1 : r > 5 && t++) : (this.finderPenaltyAddHistory(r, u), a || (t += this.finderPenaltyCountPatterns(u) * n.PENALTY_N3), a = this.modules[o][h], r = 1);
        t += this.finderPenaltyTerminateAndCount(a, r, u) * n.PENALTY_N3;
      }
      for (let o = 0; o < this.size; o++) {
        let a = !1, r = 0, u = [0, 0, 0, 0, 0, 0, 0];
        for (let h = 0; h < this.size; h++)
          this.modules[h][o] == a ? (r++, r == 5 ? t += n.PENALTY_N1 : r > 5 && t++) : (this.finderPenaltyAddHistory(r, u), a || (t += this.finderPenaltyCountPatterns(u) * n.PENALTY_N3), a = this.modules[h][o], r = 1);
        t += this.finderPenaltyTerminateAndCount(a, r, u) * n.PENALTY_N3;
      }
      for (let o = 0; o < this.size - 1; o++)
        for (let a = 0; a < this.size - 1; a++) {
          const r = this.modules[o][a];
          r == this.modules[o][a + 1] && r == this.modules[o + 1][a] && r == this.modules[o + 1][a + 1] && (t += n.PENALTY_N2);
        }
      let s = 0;
      for (const o of this.modules)
        s = o.reduce((a, r) => a + (r ? 1 : 0), s);
      const e = this.size * this.size, i = Math.ceil(Math.abs(s * 20 - e * 10) / e) - 1;
      return m(0 <= i && i <= 9), t += i * n.PENALTY_N4, m(0 <= t && t <= 2568888), t;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1) return [];
      {
        const t = Math.floor(this.version / 7) + 2, s = Math.floor(
          (this.version * 8 + t * 3 + 5) / (t * 4 - 4)
        ) * 2;
        let e = [6];
        for (let i = this.size - 7; e.length < t; i -= s)
          e.splice(1, 0, i);
        return e;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(t) {
      if (t < n.MIN_VERSION || t > n.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let s = (16 * t + 128) * t + 64;
      if (t >= 2) {
        const e = Math.floor(t / 7) + 2;
        s -= (25 * e - 10) * e - 55, t >= 7 && (s -= 36);
      }
      return m(208 <= s && s <= 29648), s;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(t, s) {
      return Math.floor(n.getNumRawDataModules(t) / 8) - n.ECC_CODEWORDS_PER_BLOCK[s.ordinal][t] * n.NUM_ERROR_CORRECTION_BLOCKS[s.ordinal][t];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(t) {
      if (t < 1 || t > 255)
        throw new RangeError("Degree out of range");
      let s = [];
      for (let i = 0; i < t - 1; i++) s.push(0);
      s.push(1);
      let e = 1;
      for (let i = 0; i < t; i++) {
        for (let o = 0; o < s.length; o++)
          s[o] = n.reedSolomonMultiply(s[o], e), o + 1 < s.length && (s[o] ^= s[o + 1]);
        e = n.reedSolomonMultiply(e, 2);
      }
      return s;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(t, s) {
      let e = s.map((i) => 0);
      for (const i of t) {
        const o = i ^ e.shift();
        e.push(0), s.forEach(
          (a, r) => e[r] ^= n.reedSolomonMultiply(a, o)
        );
      }
      return e;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(t, s) {
      if (t >>> 8 || s >>> 8)
        throw new RangeError("Byte out of range");
      let e = 0;
      for (let i = 7; i >= 0; i--)
        e = e << 1 ^ (e >>> 7) * 285, e ^= (s >>> i & 1) * t;
      return m(e >>> 8 == 0), e;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(t) {
      const s = t[1];
      m(s <= this.size * 3);
      const e = s > 0 && t[2] == s && t[3] == s * 3 && t[4] == s && t[5] == s;
      return (e && t[0] >= s * 4 && t[6] >= s ? 1 : 0) + (e && t[6] >= s * 4 && t[0] >= s ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(t, s, e) {
      return t && (this.finderPenaltyAddHistory(s, e), s = 0), s += this.size, this.finderPenaltyAddHistory(s, e), this.finderPenaltyCountPatterns(e);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(t, s) {
      s[0] == 0 && (t += this.size), s.pop(), s.unshift(t);
    }
  };
  n.MIN_VERSION = 1, n.MAX_VERSION = 40, n.PENALTY_N1 = 3, n.PENALTY_N2 = 3, n.PENALTY_N3 = 40, n.PENALTY_N4 = 10, n.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [
      -1,
      7,
      10,
      15,
      20,
      26,
      18,
      20,
      24,
      30,
      18,
      20,
      24,
      26,
      30,
      22,
      24,
      28,
      30,
      28,
      28,
      28,
      28,
      30,
      30,
      26,
      28,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30
    ],
    // Low
    [
      -1,
      10,
      16,
      26,
      18,
      24,
      16,
      18,
      22,
      22,
      26,
      30,
      22,
      22,
      24,
      24,
      28,
      28,
      26,
      26,
      26,
      26,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28,
      28
    ],
    // Medium
    [
      -1,
      13,
      22,
      18,
      26,
      18,
      24,
      18,
      22,
      20,
      24,
      28,
      26,
      24,
      20,
      30,
      24,
      28,
      28,
      26,
      30,
      28,
      30,
      30,
      30,
      30,
      28,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30
    ],
    // Quartile
    [
      -1,
      17,
      28,
      22,
      16,
      22,
      28,
      26,
      26,
      24,
      28,
      24,
      28,
      22,
      24,
      24,
      30,
      28,
      28,
      26,
      28,
      30,
      24,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30,
      30
    ]
    // High
  ], n.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [
      -1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      4,
      4,
      4,
      4,
      4,
      6,
      6,
      6,
      6,
      7,
      8,
      8,
      9,
      9,
      10,
      12,
      12,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      19,
      20,
      21,
      22,
      24,
      25
    ],
    // Low
    [
      -1,
      1,
      1,
      1,
      2,
      2,
      4,
      4,
      4,
      5,
      5,
      5,
      8,
      9,
      9,
      10,
      10,
      11,
      13,
      14,
      16,
      17,
      17,
      18,
      20,
      21,
      23,
      25,
      26,
      28,
      29,
      31,
      33,
      35,
      37,
      38,
      40,
      43,
      45,
      47,
      49
    ],
    // Medium
    [
      -1,
      1,
      1,
      2,
      2,
      4,
      4,
      6,
      6,
      8,
      8,
      8,
      10,
      12,
      16,
      12,
      17,
      16,
      18,
      21,
      20,
      23,
      23,
      25,
      27,
      29,
      34,
      34,
      35,
      38,
      40,
      43,
      45,
      48,
      51,
      53,
      56,
      59,
      62,
      65,
      68
    ],
    // Quartile
    [
      -1,
      1,
      1,
      2,
      4,
      4,
      4,
      5,
      6,
      8,
      8,
      11,
      11,
      16,
      16,
      18,
      16,
      19,
      21,
      25,
      25,
      25,
      34,
      30,
      32,
      35,
      37,
      40,
      42,
      45,
      48,
      51,
      54,
      57,
      60,
      63,
      66,
      70,
      74,
      77,
      81
    ]
    // High
  ];
  let C = n;
  w.QrCode = C;
  function d(R, t, s) {
    if (t < 0 || t > 31 || R >>> t)
      throw new RangeError("Value out of range");
    for (let e = t - 1; e >= 0; e--)
      s.push(R >>> e & 1);
  }
  function l(R, t) {
    return (R >>> t & 1) != 0;
  }
  function m(R) {
    if (!R) throw new Error("Assertion error");
  }
  const c = class c {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(t, s, e) {
      if (this.mode = t, this.numChars = s, this.bitData = e, s < 0) throw new RangeError("Invalid argument");
      this.bitData = e.slice();
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(t) {
      let s = [];
      for (const e of t) d(e, 8, s);
      return new c(c.Mode.BYTE, t.length, s);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(t) {
      if (!c.isNumeric(t))
        throw new RangeError("String contains non-numeric characters");
      let s = [];
      for (let e = 0; e < t.length; ) {
        const i = Math.min(t.length - e, 3);
        d(parseInt(t.substring(e, e + i), 10), i * 3 + 1, s), e += i;
      }
      return new c(c.Mode.NUMERIC, t.length, s);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(t) {
      if (!c.isAlphanumeric(t))
        throw new RangeError(
          "String contains unencodable characters in alphanumeric mode"
        );
      let s = [], e;
      for (e = 0; e + 2 <= t.length; e += 2) {
        let i = c.ALPHANUMERIC_CHARSET.indexOf(t.charAt(e)) * 45;
        i += c.ALPHANUMERIC_CHARSET.indexOf(t.charAt(e + 1)), d(i, 11, s);
      }
      return e < t.length && d(
        c.ALPHANUMERIC_CHARSET.indexOf(t.charAt(e)),
        6,
        s
      ), new c(c.Mode.ALPHANUMERIC, t.length, s);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(t) {
      return t == "" ? [] : c.isNumeric(t) ? [c.makeNumeric(t)] : c.isAlphanumeric(t) ? [c.makeAlphanumeric(t)] : [c.makeBytes(c.toUtf8ByteArray(t))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(t) {
      let s = [];
      if (t < 0)
        throw new RangeError("ECI assignment value out of range");
      if (t < 128) d(t, 8, s);
      else if (t < 16384)
        d(2, 2, s), d(t, 14, s);
      else if (t < 1e6)
        d(6, 3, s), d(t, 21, s);
      else throw new RangeError("ECI assignment value out of range");
      return new c(c.Mode.ECI, 0, s);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(t) {
      return c.NUMERIC_REGEX.test(t);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(t) {
      return c.ALPHANUMERIC_REGEX.test(t);
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(t, s) {
      let e = 0;
      for (const i of t) {
        const o = i.mode.numCharCountBits(s);
        if (i.numChars >= 1 << o) return 1 / 0;
        e += 4 + o + i.bitData.length;
      }
      return e;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(t) {
      t = encodeURI(t);
      let s = [];
      for (let e = 0; e < t.length; e++)
        t.charAt(e) != "%" ? s.push(t.charCodeAt(e)) : (s.push(parseInt(t.substring(e + 1, e + 3), 16)), e += 2);
      return s;
    }
  };
  c.NUMERIC_REGEX = /^[0-9]*$/, c.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, c.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  let g = c;
  w.QrSegment = g;
})(A || (A = {}));
((w) => {
  ((C) => {
    const l = class l {
      // The QR Code can tolerate about 30% erroneous codewords
      /*-- Constructor and fields --*/
      constructor(g, n) {
        this.ordinal = g, this.formatBits = n;
      }
    };
    l.LOW = new l(0, 1), l.MEDIUM = new l(1, 0), l.QUARTILE = new l(2, 3), l.HIGH = new l(3, 2);
    let d = l;
    C.Ecc = d;
  })(w.QrCode || (w.QrCode = {}));
})(A || (A = {}));
((w) => {
  ((C) => {
    const l = class l {
      /*-- Constructor and fields --*/
      constructor(g, n) {
        this.modeBits = g, this.numBitsCharCount = n;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(g) {
        return this.numBitsCharCount[Math.floor((g + 7) / 17)];
      }
    };
    l.NUMERIC = new l(1, [10, 12, 14]), l.ALPHANUMERIC = new l(2, [9, 11, 13]), l.BYTE = new l(4, [8, 16, 16]), l.KANJI = new l(8, [8, 10, 12]), l.ECI = new l(7, [0, 0, 0]);
    let d = l;
    C.Mode = d;
  })(w.QrSegment || (w.QrSegment = {}));
})(A || (A = {}));
const I = A;
export {
  I as default
};
